[{"content":"TBD\n","description":"","tags":null,"title":"Getting Started","uri":"/libembeddedhal/installation/getting_started/"},{"content":"Quick Start TBD\n","description":"","tags":null,"title":"Installation","uri":"/libembeddedhal/installation/"},{"content":"TBD\n","description":"","tags":null,"title":"Flashing","uri":"/libembeddedhal/installation/flashing/"},{"content":"Guides TBD\n","description":"","tags":null,"title":"Guides","uri":"/libembeddedhal/guides/"},{"content":"API The following chapter contains detailed API documentation for every class and function in the code base. These descriptions include, but are not limited to, descriptions of the available classes, their method, what parameters those methods take, and a description of those parameters and how to use them. These sort of descriptions are also available for functions, type definitions, structures and inline defined variables within header files.\nClasses The classes section contains every single documented class in the project. This area can be quite large and hard to navigate unless you know exactly what you are looking for. If you are not sure exactly what you are looking for but know what catagory of library you are looking for, use the modules section.\nModules Modules chapter categorizes drivers in like groups which makes navigation easier.\n","description":"","tags":null,"title":"API","uri":"/libembeddedhal/api/"},{"content":"TBD\n","description":"","tags":null,"title":"Debugging","uri":"/libembeddedhal/installation/jtag/"},{"content":"TBD\n","description":"","tags":null,"title":"Exploring the Ecosystem","uri":"/libembeddedhal/installation/exploring_the_ecosystem/"},{"content":"TBD\n","description":"","tags":null,"title":"Creating a Device Driver","uri":"/libembeddedhal/expanding/creating_device/"},{"content":"TBD\n","description":"","tags":null,"title":"Creating a Project","uri":"/libembeddedhal/guides/new_project/"},{"content":"Design Documentation This section goes into detail on the design choices of each aspect of each part of the libembeddedhal library. This section will go into why things are the way they are. If you are looking to just know how to use aspects of libembeddedhal please see the “guides” and “api” chapters.\nThis section is meant to explain to users of libembeddedhal why certain design choices were made, what the alternatives options were, what are the pros and cons of a system and why the pros outweigh the cons. If you disagree with these design choices, feel free to add an issue to the official repo.\n","description":"","tags":null,"title":"Design","uri":"/libembeddedhal/design/"},{"content":"TBD\n","description":"","tags":null,"title":"Driver Interface Design","uri":"/libembeddedhal/design/driver_design/"},{"content":"Expanding the Ecosystem TBD\n","description":"","tags":null,"title":"Expanding the Ecosystem","uri":"/libembeddedhal/expanding/"},{"content":"Contributing to libembeddedhal Code of conduct Please read the CODE_OF_CONDUCT.md file before contributing.\nStyle Guide  ","description":"","tags":null,"title":"Contributing","uri":"/libembeddedhal/contribution/"},{"content":"TBD\n","description":"","tags":null,"title":"Creating a Platform","uri":"/libembeddedhal/expanding/creating_platform/"},{"content":"TBD\n","description":"","tags":null,"title":"Error Handling Design","uri":"/libembeddedhal/design/error_handling_design/"},{"content":"TBD\n","description":"","tags":null,"title":"How to Use Drivers","uri":"/libembeddedhal/guides/driver_usage/"},{"content":"TBD\n","description":"","tags":null,"title":"Creating a Utility Library","uri":"/libembeddedhal/expanding/creating_utilities/"},{"content":"TBD\n","description":"","tags":null,"title":"Driver Wrappers Design","uri":"/libembeddedhal/design/driver_wrappers/"},{"content":"TBD\n","description":"","tags":null,"title":"Error Handling","uri":"/libembeddedhal/guides/error_handling/"},{"content":"TBD\n","description":"","tags":null,"title":"Multiplatform Applications","uri":"/libembeddedhal/guides/multiplatform_apps/"},{"content":"TBD\n","description":"","tags":null,"title":"Unit Testing","uri":"/libembeddedhal/guides/unit_testing/"},{"content":"TBD\n","description":"","tags":null,"title":"Handwritten Driver Mocks","uri":"/libembeddedhal/design/handmade_mocks/"},{"content":"Runtime Cost  https://blog.segger.com/wp-content/uploads/2019/11/Bench_Comparison.pdf https://blog.segger.com/floating-point-face-off-part-2-comparing-performance/  Space Cost Each was tested with the following operators (+, -, *, /, \u003c, \u003e, ==, \u003c=, \u003e=):\n32-bit integer conversion only:  Floats: 1392 bytes Doubles: 1968 bytes  64-bit integer conversion only:  Floats: 3088 bytes Doubles: 2128 bytes  Both 32-bit \u0026 64-bit conversion:  Doubles + Floats: 3072 bytes Doubles + Floats: 3592 bytes  Problems with Floats  Infinties \u0026 NaN Lose of precision Conversion to integer types Floating-point environment  https://en.cppreference.com/w/cpp/numeric/fenv Requires TLS which is disabled for stock arm-none-eabi-gcc    ","description":"","tags":null,"title":"Using Floats","uri":"/libembeddedhal/guides/using_floats/"},{"content":"","description":"","tags":null,"title":"Categories","uri":"/libembeddedhal/categories/"},{"content":" namespace embed  class adc Analog to Digital Converter (ADC) hardware abstraction interface. struct bit_depth A type based on bit width that contains a value. class bit_limits class can Controller Area Network (CAN bus) hardware abstraction interface.  struct message_t Attributes of a can message.   class can_network Manage, store, and organize messages received on the can bus.  class node_t A can network node stores the can messages in a lock free way.   struct can_settings Generic settings for a can peripheral. namespace config  namespace defaults   class counter Counter hardware abstraction interface. Use this interface for devices and peripherals that have counting capabilities. Such devices can count up or down. Useful for keeping time. Expect counters to overflow when they reach the end of counting register’s limits. class dac Digital to Analog Converter (DAC) hardware abstraction interface. class driver The basis class for all peripheral, device and system drivers in libembeddedhal. struct duty_cycle Structure containing cycle count for the high and low side of a signal duty cycle. namespace error  class stacktrace A structure to hold stack strace source location entries. The size of this class can be changed by changing the embed::config::stacktrace_depth_limit value in the libembeddedhal.tweak.hpp file for your project. This can be used to reduce the stack size of functions that have Boost.LEAF handlers that inspect a embed::error::stacktrace. struct universal An association error type for all libembeddedhal drivers that inherit from this class. It is used to disambiguate errors coming from a libembeddedhal embed::driver vs those coming from other libraries.   class frequency Represents the frequency of a signal. It consists of a single integer 64-bit number that presents the integer representation of a signal frequency. class full_scale A bit resolution erased representation of a precentage value using only integral arithmetic. class i2c Inter-integrated Circuit (I2C) or Two Wire Interface (TWI) communication protocol hardware abstract interface.  struct address_not_acknowledged Error type indicating that the i2c transaction resulted in a NACK, meaning “not acknowledge”. NACKs occur when an address has been placed on the i2c bus and no device connected to the bus returned an acknowledge signal. struct bus_error Error type indicating that the i2c lines were put into an invalid state during the transaction due to interference, misconfiguration of the i2c peripheral or the addressed device or something else.   struct i2c_settings Generic settings for a standard I2C device. class input_pin Digital input pin hardware abstraction. struct input_pin_settings Generic settings for input pins. class interrupt_pin Digital interrupt pin hardware abstraction. struct interrupt_pin_settings Generic settings for interrupt pins. struct invalid_option_t Used for defining static_asserts that should always fail, but only if the static_assert line is hit via if constexpr control block. Prefer to NOT use this directly but to use invalid_option instead. namespace literals struct no_settings An empty settings structure used to indicate that a driver or interface does not have generic settings. class output_pin Digital output pin hardware abstraction. struct output_pin_settings Generic settings for output pins. class pwm Pulse Width Modulation (PWM) channel hardware abstraction. class serial Serial communication protocol hardware abstract interface.  struct frame_error Error type indicating that a frame error occured during reception. This error is returned when calling bytes_available(). struct packets_lost Error indicating that packets were lost during reception. This occurs when the buffer is overrun and reaches the end of the circular buffer. This error is returned when calling bytes_available(). struct parity_error Error type indicating that a parity error occured during reception. This error is returned when calling bytes_available().   struct serial_settings Generic settings for a standard serial device. class spi Serial peripheral interface (SPI) communication protocol hardware abstract interface. struct spi_settings Generic settings for a standard SPI device. class static_callable General class which will be used to allow for signature to be used and then split by the below class. class static_callable\u003c owner_class, reference_designator, return_t(args_t… p_args)\u003e Specialization of static_callable with the return type and arguments split up. class static_memory_resource The static_memory_resource is the polymorphic memory resource allocator that allows libembeddedhal’s libraries to use a C++ standard container such as std::pmr::vector, std::pmr::string, std::pmr::unordered_map, and more without requiring dynamic memory allocation from the heap. It provides a simple way to create an allocator with built in storage, with its size indicated by a single template parameter. It also provides statistics regarding the amount of memory allocated such that developers can determine if they need to reduce or increase the size of the buffer. Memory statistics can also give programs the insight into how much memory space is available and make decisions based on that. In the event that the memory of the static allocator is exceeded, a std::bad_alloc excpetion is thrown. namespace this_thread  struct global_clocks structure containing internal clock variables and functions   class timer Timer hardware abstraction interface.  struct delay_too_large Error type indicating that the desired delay time is above what can be achieved by the timer. struct delay_too_small Error type indicating that the desired time delay is not achievable with this timer.       Updated on 2022-01-15 at 19:09:27 +0000\n","description":"","tags":null,"title":"Classes","uri":"/libembeddedhal/api/classes/"},{"content":"embed Namespace Reference\nNamespaces    Name     embed::config   embed::error   embed::literals   embed::this_thread    Classes     Name     class embed::adc Analog to Digital Converter (ADC) hardware abstraction interface.   struct embed::can_settings Generic settings for a can peripheral.   class embed::can Controller Area Network (CAN bus) hardware abstraction interface.   class embed::can_network Manage, store, and organize messages received on the can bus.   class embed::counter Counter hardware abstraction interface. Use this interface for devices and peripherals that have counting capabilities. Such devices can count up or down. Useful for keeping time. Expect counters to overflow when they reach the end of counting register’s limits.   class embed::dac Digital to Analog Converter (DAC) hardware abstraction interface.   struct embed::invalid_option_t Used for defining static_asserts that should always fail, but only if the static_assert line is hit via if constexpr control block. Prefer to NOT use this directly but to use invalid_option instead.   struct embed::no_settings An empty settings structure used to indicate that a driver or interface does not have generic settings.   class embed::driver The basis class for all peripheral, device and system drivers in libembeddedhal.   struct embed::duty_cycle Structure containing cycle count for the high and low side of a signal duty cycle.   class embed::frequency Represents the frequency of a signal. It consists of a single integer 64-bit number that presents the integer representation of a signal frequency.   class embed::bit_limits   struct embed::bit_depth A type based on bit width that contains a value.   class embed::full_scale A bit resolution erased representation of a precentage value using only integral arithmetic.   struct embed::input_pin_settings Generic settings for input pins.   struct embed::output_pin_settings Generic settings for output pins.   struct embed::interrupt_pin_settings Generic settings for interrupt pins.   class embed::input_pin Digital input pin hardware abstraction.   class embed::output_pin Digital output pin hardware abstraction.   class embed::interrupt_pin Digital interrupt pin hardware abstraction.   struct embed::i2c_settings Generic settings for a standard I2C device.   class embed::i2c Inter-integrated Circuit (I2C) or Two Wire Interface (TWI) communication protocol hardware abstract interface.   class embed::pwm Pulse Width Modulation (PWM) channel hardware abstraction.   struct embed::serial_settings Generic settings for a standard serial device.   class embed::serial Serial communication protocol hardware abstract interface.   struct embed::spi_settings Generic settings for a standard SPI device.   class embed::spi Serial peripheral interface (SPI) communication protocol hardware abstract interface.   class embed::static_callable General class which will be used to allow for signature to be used and then split by the below class.   class embed::static_callable\u003c owner_class, reference_designator, return_t(args_t… p_args)\u003e Specialization of static_callable with the return type and arguments split up.   class embed::static_memory_resource The static_memory_resource is the polymorphic memory resource allocator that allows libembeddedhal’s libraries to use a C++ standard container such as std::pmr::vector, std::pmr::string, std::pmr::unordered_map, and more without requiring dynamic memory allocation from the heap. It provides a simple way to create an allocator with built in storage, with its size indicated by a single template parameter. It also provides statistics regarding the amount of memory allocated such that developers can determine if they need to reduce or increase the size of the buffer. Memory statistics can also give programs the insight into how much memory space is available and make decisions based on that. In the event that the memory of the static allocator is exceeded, a std::bad_alloc excpetion is thrown.   class embed::timer Timer hardware abstraction interface.    Types     Name     enum class pin_resistor { none = 0, pull_down, pull_up}Set of possible pin mode resistor settings.    Functions     Name     constexpr auto value(enumeration auto p_enum_value)Helper function to convert an enum to its integral value.   template \u003csize_t bit_field_width\u003e consteval uint32_t generate_field_of_ones()Generate a mask of 1s at compiletime.   template \u003cstd::integral T,size_t source_width,std::integral U\u003e constexpr static T increase_bit_depth(U p_value)Take a value of arbitrary bit resolution and create a value with scaled up the bit resolution.   template \u003cstd::unsigned_integral T,std::integral U\u003e constexpr auto operator*(U p_value, full_scale\u003c T \u003e p_scale)Scale an integral value by a full_scalevalue.   template \u003cstd::unsigned_integral T,std::integral U\u003e constexpr auto operator*(full_scale\u003c T \u003e p_scale, U p_value)Same as operator*(U p_value, [full_scale]()\u003cT\u003e p_scale)   template \u003cstd::integral T\u003e constexpr T rounding_division(T p_numerator, T p_denominator)Perform integer division and round the value up if the next decimal place is greater than or equal to 0.5.   constexpr auto absolute_value(std::integral auto p_value)Generic absolute value function that works for integer types. This is preferred over the C API for rounding numbers such as abs(), labs() and llabs(). This function relieves the need in template code to check the type of the integer and select the correct function to call.    Attributes     Name     constexpr bool invalid_option Helper definition to simplify the usage of invalid_option_t.   concept enumeration concept for enumeration types   constexpr frequency default_clock_rate Default clock rate for serial communication protocols.    Types Documentation enum pin_resistor    Enumerator Value Description     none 0 No pull up. This will cause the pin to float. This may be desirable if the pin has an external resistor attached or if the signal is sensitive to external devices like resistors.   pull_down  Pull the pin down to devices GND. This will ensure that the voltage read by the pin when there is no signal on the pin is LOW (or false).   pull_up  See pull down explanation, but in this case the pin is pulled up to VCC, also called VDD on some systems.    Set of possible pin mode resistor settings.\nSee each enumeration to get more details about when and how these should be used.\nFunctions Documentation function value constexpr auto value( enumeration auto p_enum_value ) Helper function to convert an enum to its integral value.\nParameters:\n p_enum_value - the enumeration you want to convert into an integral value  Return: constexpr auto - return the integral value of the enum with the same type as the enumeration.\nfunction generate_field_of_ones template \u003csize_t bit_field_width\u003e static consteval uint32_t generate_field_of_ones() Generate a mask of 1s at compiletime.\nTemplate Parameters:\n bit_field_width - number of 1s in the mask  Return: consteval uint32_t - mask with 1s at the LSB\nfunction increase_bit_depth template \u003cstd::integral T, size_t source_width, std::integral U\u003e static constexpr static T increase_bit_depth( U p_value ) Take a value of arbitrary bit resolution and create a value with scaled up the bit resolution.\nParameters:\n p_value - the value to be scaled  Template Parameters:\n T - integral type to bring the resolution of U up to. source_width - the bit resolution of the input value U - integral type of the input value  Return: constexpr T - p_value but with resolution scaled up to type T\nThe purpose of bit scaling a value is to take a value of lower bit resolution, scale it up but keep the percentage relative to the bits resolution. This is useful for bit resolution erasure as well as image upscaling.\nFor example, lets take an 8-bit value of 127 (or 0x7F). This value is 50% of an 8-bit number. 50% of an 32-bit would be 2147483647 or 0x7FFFFFFF which is half of 2^32. A perfect upscaling would take 0x7F and generate 0x7FFFFFFF in this case. Doing so is quite costly and requires multiplication and division operations which are slower opetation.\nFast and efficient bit scaling is done via bit replication. For example, to scale an 8-bit value up to 32-bits would look like this:\n8-bit [ 0x7F ] |\\\\\\_____________________ | \\\\___________ \\ | \\____ \\ \\ | \\ \\ | | | | | V V V V 32-bit [ 0x7F ] [ 0x7F ] [ 0x7F ] [ 0x7F ] Expected 32-bit value is: 0x7FFFFFFF Actual value from scaling: 0x7F7F7F7F % difference is: (0x7FFFFFFF - 0x7F7F7F7F) / 0x7FFFFFFF = 0.39215684% A precent difference well below 1% makes this a viable solution for most applications.\nfunction operator* template \u003cstd::unsigned_integral T, std::integral U\u003e constexpr auto operator*( U p_value, full_scale\u003c T \u003e p_scale ) Scale an integral value by a full_scalevalue.\nParameters:\n p_value - value to be scaled p_scale - value scalar  Template Parameters:\n T - underlying type of the full scale value U - type of the integral value to be scaled  Return: auto - the scaled down result of p_value * p_scale.\nReturns a scaled down version of the input value. For example if the input is 100 and the scale value represents a percentage of 50%, then performing the following operation: 100 * full_scale_50_percent is equivalent to 100 * 0.5f.\nfunction operator* template \u003cstd::unsigned_integral T, std::integral U\u003e constexpr auto operator*( full_scale\u003c T \u003e p_scale, U p_value ) Same as operator*(U p_value, [full_scale]()\u003cT\u003e p_scale)\nParameters:\n p_scale - see other operator* p_value - see other operator*  Template Parameters:\n T - see other operator* U - see other operator*  Return: constexpr auto - see other operator*\nfunction rounding_division template \u003cstd::integral T\u003e constexpr T rounding_division( T p_numerator, T p_denominator ) Perform integer division and round the value up if the next decimal place is greater than or equal to 0.5.\nParameters:\n p_numerator - the value to be divided p_denominator - the value to divide the numerator against  Template Parameters:\n T - integral type of the two operands  Return: constexpr T - rounded quotent between numerator and denominator. Returns 0 if the denominator is greater than the numerator.\nfunction absolute_value constexpr auto absolute_value( std::integral auto p_value ) Generic absolute value function that works for integer types. This is preferred over the C API for rounding numbers such as abs(), labs() and llabs(). This function relieves the need in template code to check the type of the integer and select the correct function to call.\nParameters:\n p_value - integer value to be made positive  Return: constexpr auto - positive representation of the integer\nAttributes Documentation variable invalid_option constexpr bool invalid_option = invalid_option_t\u003coptions...\u003e::value; Helper definition to simplify the usage of invalid_option_t.\nTemplate Parameters:\n options ignored by the application but needed to create a non-trivial specialization of this class which allows its usage in static_assert.  variable enumeration concept enumeration = std::is_enum_v\u003cT\u003e; concept for enumeration types\nTemplate Parameters:\n T - enum type  variable default_clock_rate constexpr frequency default_clock_rate = frequency(100'000); Default clock rate for serial communication protocols.\n Updated on 2022-01-15 at 19:09:27 +0000\n","description":"","tags":null,"title":"embed","uri":"/libembeddedhal/api/namespaces/namespaceembed/"},{"content":"embed::adc Class Reference\nAnalog to Digital Converter (ADC) hardware abstraction interface. More…\n#include \u003cadc.hpp\u003e\nInherits from embed::driver\u003c\u003e\nAdditional inherited members Public Functions inherited from embed::driver\u003c\u003e\n    Name     boost::leaf::result\u003c void \u003e initialize()Initialize the driver, apply the setting as defined in the settings_t structure and enable it. Calling this function after it has already been initialized will return false. In order to run initialization again, reset() must be called. After initialization, the settings are committed and saved into another settings structure. This settings can be looked up and inspected by the application.   void reset()Reset the driver in order to run initialize again. This is helpful if the application needs to change the settings of a driver after it is first initialized, like baud rate for serial or pull resistor for a pin.   bool is_initialized() constDetermine if the driver has been initialized.   settings_t \u0026 settings()Get access to uncommitted driver settings.   const settings_t \u0026 initialized_settings() constGet access to the settings that were used in the latest initialization. These settings only get updated when a successful initialize() has occurred.    Protected Functions inherited from embed::driver\u003c\u003e\n    Name     virtual boost::leaf::result\u003c void \u003e driver_initialize() =0Implementation of driver initialize by the inherited driver.    Protected Attributes inherited from embed::driver\u003c\u003e\n    Name     settings_t m_settings Mutable settings.   settings_t m_initialized_settings Saved version of the settings at initialization.   bool m_initialized Determines if the driver has been initialized.    Detailed Description class embed::adc; Analog to Digital Converter (ADC) hardware abstraction interface.\nUse this interface for devices and peripherals that can convert analog voltage signals into a digital number.\n Updated on 2022-01-15 at 19:09:27 +0000\n","description":"","tags":null,"title":"embed::adc","uri":"/libembeddedhal/api/classes/classembed_1_1adc/"},{"content":"embed::bit_depth Struct Reference\nA type based on bit width that contains a value. More…\n#include \u003cfull_scale.hpp\u003e\nPublic Functions     Name     constexpr bit_depth(T p_value)construct bit_depth object    Public Attributes     Name     T value Value of the data at the bit width.    Detailed Description template \u003cstd::integral T, size_t bit_width\u003e struct embed::bit_depth; A type based on bit width that contains a value.\nTemplate Parameters:\n T - the underlying type of the value bit_width - the number of bits of the value  Public Functions Documentation function bit_depth inline constexpr bit_depth( T p_value ) construct bit_depth object\nParameters:\n p_value - a integral value within the size of the bit_width. If the object is outside the bounds of the bit width, it is clamped.  Public Attributes Documentation variable value T value = 0; Value of the data at the bit width.\n Updated on 2022-01-15 at 19:09:27 +0000\n","description":"","tags":null,"title":"embed::bit_depth","uri":"/libembeddedhal/api/classes/structembed_1_1bit__depth/"},{"content":"embed::bit_limits Class Reference\nMore…\n#include \u003cfull_scale.hpp\u003e\nPublic Functions     Name     constexpr int_t max()Get the maximum value available for an integer of bit_width size and that can be stored within int_t.   constexpr int_t min()Get the minimum value available for an integer of bit_width size and that can be stored within int_t.    Detailed Description template \u003cuint8_t bit_width, std::integral int_t\u003e class embed::bit_limits; Template Parameters:\n bit_width int_t  Public Functions Documentation function max static inline constexpr int_t max() Get the maximum value available for an integer of bit_width size and that can be stored within int_t.\nReturn: constexpr int_t maximum value\nThe final value of the function depends also on the sign of the int type.\nfunction min static inline constexpr int_t min() Get the minimum value available for an integer of bit_width size and that can be stored within int_t.\nReturn: constexpr int_t minimum value\nThe final value of the function depends also on the sign of the int type. Unsigned ints simply return zero.\n Updated on 2022-01-15 at 19:09:27 +0000\n","description":"","tags":null,"title":"embed::bit_limits","uri":"/libembeddedhal/api/classes/classembed_1_1bit__limits/"},{"content":"embed::can Class Reference\nController Area Network (CAN bus) hardware abstraction interface.\n#include \u003ccan.hpp\u003e\nInherits from embed::driver\u003c can_settings \u003e\nPublic Classes     Name     struct message_t Attributes of a can message.    Public Types     Name     using uint32_t id_t Can message ID type trait.    Public Functions     Name     virtual boost::leaf::result\u003c void \u003e send(const message_t \u0026 p_message) =0Send a can message over the can bus.   virtual boost::leaf::result\u003c bool \u003e has_data() =0Determine if the can bus has any queued up can messages.   virtual boost::leaf::result\u003c message_t \u003e receive() =0Receieve a message from the can bus if one is available.   virtual boost::leaf::result\u003c void \u003e attach_interrupt(std::function\u003c void(can \u0026p_can)\u003e p_receive_handler) =0Setup driver to execute callback when a can message is received.    Additional inherited members Public Functions inherited from embed::driver\u003c can_settings \u003e\n    Name     boost::leaf::result\u003c void \u003e initialize()Initialize the driver, apply the setting as defined in the settings_t structure and enable it. Calling this function after it has already been initialized will return false. In order to run initialization again, reset() must be called. After initialization, the settings are committed and saved into another settings structure. This settings can be looked up and inspected by the application.   void reset()Reset the driver in order to run initialize again. This is helpful if the application needs to change the settings of a driver after it is first initialized, like baud rate for serial or pull resistor for a pin.   bool is_initialized() constDetermine if the driver has been initialized.   settings_t \u0026 settings()Get access to uncommitted driver settings.   const settings_t \u0026 initialized_settings() constGet access to the settings that were used in the latest initialization. These settings only get updated when a successful initialize() has occurred.    Protected Functions inherited from embed::driver\u003c can_settings \u003e\n    Name     virtual boost::leaf::result\u003c void \u003e driver_initialize() =0Implementation of driver initialize by the inherited driver.    Protected Attributes inherited from embed::driver\u003c can_settings \u003e\n    Name     settings_t m_settings Mutable settings.   settings_t m_initialized_settings Saved version of the settings at initialization.   bool m_initialized Determines if the driver has been initialized.    Public Types Documentation using id_t using embed::can::id_t = uint32_t; Can message ID type trait.\nPublic Functions Documentation function send virtual boost::leaf::result\u003c void \u003e send( const message_t \u0026 p_message ) =0 Send a can message over the can bus.\nParameters:\n p_message - the message to be sent  Return: boost::leaf::result- any error that occured during this operation.\nfunction has_data virtual boost::leaf::result\u003c bool \u003e has_data() =0 Determine if the can bus has any queued up can messages.\nReturn: boost::leaf::result- true if a can message is available to read, false otherwise.\nfunction receive virtual boost::leaf::result\u003c message_t \u003e receive() =0 Receieve a message from the can bus if one is available.\nReturn: boost::leaf::result\u003cmessage_t\u003e - a can message from the bus\nBehavior is undefined if no data is available.\nfunction attach_interrupt virtual boost::leaf::result\u003c void \u003e attach_interrupt( std::function\u003c void(can \u0026p_can)\u003e p_receive_handler ) =0 Setup driver to execute callback when a can message is received.\nParameters:\n p_receive_handler - can message reception callback. Set to nullptr to disable receive interrupts.  Return: boost::leaf::result- any error that occured during this operation.\n Updated on 2022-01-15 at 19:09:27 +0000\n","description":"","tags":null,"title":"embed::can","uri":"/libembeddedhal/api/classes/classembed_1_1can/"},{"content":"embed::can::message_t Struct Reference\nAttributes of a can message.\n#include \u003ccan.hpp\u003e\nPublic Attributes     Name     id_t id ID of the message.   uint8_t length The number of elements in the payload.   std::array\u003c uint8_t, 8 \u003e payload The message data.   bool is_remote_request    Public Attributes Documentation variable id id_t id; ID of the message.\nvariable length uint8_t length = 0; The number of elements in the payload.\nvariable payload std::array\u003c uint8_t, 8 \u003e payload { 0 }; The message data.\nvariable is_remote_request bool is_remote_request = false; Whether or not the message is a remote request frame. If true, then length and payload are ignored.\n Updated on 2022-01-15 at 19:09:27 +0000\n","description":"","tags":null,"title":"embed::can::message_t","uri":"/libembeddedhal/api/classes/structembed_1_1can_1_1message__t/"},{"content":"embed::can_network Class Reference\nManage, store, and organize messages received on the can bus. More…\n#include \u003cnetwork.hpp\u003e\nInherits from embed::driver\u003c\u003e\nPublic Classes     Name     class node_t A can network node stores the can messages in a lock free way.    Public Functions     Name      can_network(can \u0026 p_can, std::pmr::memory_resource \u0026 p_memory_resource)Construct a new can network object.   virtual boost::leaf::result\u003c void \u003e driver_initialize() overrideImplementation of driver initialize by the inherited driver.   node_t * register_message_id(can::id_t p_id)Assocate a can id with a node in the can network.   void manually_call_receive_handler()Manually call the receive handler.   can \u0026 bus()get a reference to the can peripheral driver   const auto \u0026 get_internal_map()Get the Internal Map object.    Additional inherited members Public Functions inherited from embed::driver\u003c\u003e\n    Name     boost::leaf::result\u003c void \u003e initialize()Initialize the driver, apply the setting as defined in the settings_t structure and enable it. Calling this function after it has already been initialized will return false. In order to run initialization again, reset() must be called. After initialization, the settings are committed and saved into another settings structure. This settings can be looked up and inspected by the application.   void reset()Reset the driver in order to run initialize again. This is helpful if the application needs to change the settings of a driver after it is first initialized, like baud rate for serial or pull resistor for a pin.   bool is_initialized() constDetermine if the driver has been initialized.   settings_t \u0026 settings()Get access to uncommitted driver settings.   const settings_t \u0026 initialized_settings() constGet access to the settings that were used in the latest initialization. These settings only get updated when a successful initialize() has occurred.    Protected Attributes inherited from embed::driver\u003c\u003e\n    Name     settings_t m_settings Mutable settings.   settings_t m_initialized_settings Saved version of the settings at initialization.   bool m_initialized Determines if the driver has been initialized.    Detailed Description class embed::can_network; Manage, store, and organize messages received on the can bus.\nDrivers use this can bus peripheral manager rather than can directly. This is to ensure that the correct can messages are filtered to the correct driver.\nTo understand the importance of using this class over can direction consider protocols like UART and I2C. UART is asynchronous and communicates with a single device. Messages may come at an arbitrary time, but their origin is always known. Typically a single device driver holds control over a UART peripheral. I2C is a multi device us but the controller is always the initiator of the communication. Once an i2c controller successfully starts a conversation with another device on the bus, the response should always come from that device. CAN has this problem where messages can come in at any time from any device on the bus, making writting a driver that accepts the can interface directly impossible as there would be no way to coordinate which driver gets what data when the can interface has only a singular receive method.\nCan Network provides a means for routing messages based on ID to can device drivers.\nPublic Functions Documentation function can_network inline can_network( can \u0026 p_can, std::pmr::memory_resource \u0026 p_memory_resource ) Construct a new can network object.\nParameters:\n p_can - can peripheral to manage the network of p_memory_resource - memory resource used for storing can messages  function driver_initialize inline virtual boost::leaf::result\u003c void \u003e driver_initialize() override Implementation of driver initialize by the inherited driver.\nReturn:\n true driver initialized successfully false driver initialization failed  Reimplements: embed::driver::driver_initialize\nfunction register_message_id inline node_t * register_message_id( can::id_t p_id ) Assocate a can id with a node in the can network.\nParameters:\n p_id - Associated ID of messages to be stored.  Exceptions:\n std::bad_alloc if this static storage allocated for this object is not enough to hold  Return: node_t* - reference to the CANBUS network node_t which can be used at anytime to retreive the latest received message from the CANBUS that is associated with the set ID.\nTo store can message with an associated ID in the can_network, it must be declared using this method. For example if you expect to get the following IDs 0x140, 0x7AA, and 0x561 from the CAN bus, then this method must be called as such:\n{C++} node_t* motor_node = can_network.register_message_id(0x140); node_t* encoder_node = can_network.register_message_id(0x561); node_t* temperature_node = can_network.register_message_id(0x7AA); function manually_call_receive_handler inline void manually_call_receive_handler() Manually call the receive handler.\nThis is useful for unit testing and for CANBUS peripherals that do NOT have a receive message interrupt routine. In the later case, a software (potentially a thread) can perform the receive call manually to extract messages from the CAN peripheral FIFO. This method cannot guarantee that data is not lost if the FIFO fills up.\nfunction bus inline can \u0026 bus() get a reference to the can peripheral driver\nReturn: can\u0026 reference to the can peripheral driver\nCan be used to initialize, configure, and enable the peripheral as well as transmit messages.\nfunction get_internal_map inline const auto \u0026 get_internal_map() Get the Internal Map object.\nReturn: const auto\u0026 map of all of the messages in the network.\nMeant for testing purposes or when direct inspection of the map is useful in userspace. Should not be used in by libraries.\n Updated on 2022-01-15 at 19:09:27 +0000\n","description":"","tags":null,"title":"embed::can_network","uri":"/libembeddedhal/api/classes/classembed_1_1can__network/"},{"content":"embed::can_network::node_t Class Reference\nA can network node stores the can messages in a lock free way. More…\n#include \u003cnetwork.hpp\u003e\nPublic Functions     Name      node_t()Construct a new node t object.   node_t \u0026 operator=(const node_t \u0026 p_node)Node assignment operator.    node_t(const node_t \u0026 p_node)Construct a new node t object.   can::message_t secure_get()Get this node’s can message.    Detailed Description class embed::can_network::node_t; A can network node stores the can messages in a lock free way.\nUpdating the can message data is completely lock free. Retrieving data uses atomics to poll for when the update() function has completed. This asymmetry in locking is to reduce write time, which is usually done in an interrupt context, rather than than read time, which is performed by a driver in a thread or main thread.\nPublic Functions Documentation function node_t inline node_t() Construct a new node t object.\nfunction operator= inline node_t \u0026 operator=( const node_t \u0026 p_node ) Node assignment operator.\nParameters:\n p_node the node copy  Return: node_t\u0026 reference to this object\nfunction node_t inline node_t( const node_t \u0026 p_node ) Construct a new node t object.\nParameters:\n p_node the object to copy  function secure_get inline can::message_t secure_get() Get this node’s can message.\nReturn: can::message_t\n Updated on 2022-01-15 at 19:09:27 +0000\n","description":"","tags":null,"title":"embed::can_network::node_t","uri":"/libembeddedhal/api/classes/classembed_1_1can__network_1_1node__t/"},{"content":"embed::can_settings Struct Reference\nGeneric settings for a can peripheral.\n#include \u003ccan.hpp\u003e\nPublic Attributes     Name     frequency clock_rate Bus clock rate.    Public Attributes Documentation variable clock_rate frequency clock_rate = default_clock_rate; Bus clock rate.\n Updated on 2022-01-15 at 19:09:27 +0000\n","description":"","tags":null,"title":"embed::can_settings","uri":"/libembeddedhal/api/classes/structembed_1_1can__settings/"},{"content":"embed::config Namespace Reference\nNamespaces    Name     embed::config::defaults    Functions     Name     constexpr bool is_platform(std::string_view p_platform)Determines if the current application was built for a specific platform. For example:   constexpr bool is_a_test()Determines if the application is a test.    Functions Documentation function is_platform constexpr bool is_platform( std::string_view p_platform ) Determines if the current application was built for a specific platform. For example:\nParameters:\n p_platform - platform string pattern to check against  Return:\n true - matches the platform string false - does not matches the platform string  embed::config::is_platform(“lpc4078”);\nWill return true if the PLATFORM macro defined at compile time was equal to lpc4078. If the developer wants to be less specific, let say, to just determine if the platform is in the lpc40xx family then the following example will work.\nembed::config::is_platform(“lpc40”);\nfunction is_a_test constexpr bool is_a_test() Determines if the application is a test.\nReturn:\n true - this application is a test false - this application is not a test   Updated on 2022-01-15 at 19:09:27 +0000\n","description":"","tags":null,"title":"embed::config","uri":"/libembeddedhal/api/namespaces/namespaceembed_1_1config/"},{"content":"embed::config::defaults Namespace Reference\nAttributes     Name     constexpr std::string_view platform   constexpr bool get_stacktrace_on_error   constexpr size_t stacktrace_depth_limit   constexpr bool get_source_position_on_error    Attributes Documentation variable platform constexpr std::string_view platform = \"test\"; variable get_stacktrace_on_error constexpr bool get_stacktrace_on_error = true; variable stacktrace_depth_limit constexpr size_t stacktrace_depth_limit = 32; variable get_source_position_on_error constexpr bool get_source_position_on_error = false;  Updated on 2022-01-15 at 19:09:27 +0000\n","description":"","tags":null,"title":"embed::config::defaults","uri":"/libembeddedhal/api/namespaces/namespaceembed_1_1config_1_1defaults/"},{"content":"embed::counter Class Reference\nCounter hardware abstraction interface. Use this interface for devices and peripherals that have counting capabilities. Such devices can count up or down. Useful for keeping time. Expect counters to overflow when they reach the end of counting register’s limits.\n#include \u003ccounter.hpp\u003e\nInherits from embed::driver\u003c\u003e\nPublic Types     Name     enum class controls { start, stop, reset}Set of controls for a counter.    Public Functions     Name     virtual boost::leaf::result\u003c bool \u003e is_running() =0Determine if the counter is currently running.   virtual boost::leaf::result\u003c void \u003e control(controls p_control) =0Control the state of the counter.   virtual boost::leaf::result\u003c void \u003e period(std::chrono::nanoseconds p_period) =0Period for each count of the timer. For example a period of 1ms and a count of 500 would mean that 500ms has elapse since the counter has been started.   virtual boost::leaf::result\u003c std::chrono::nanoseconds \u003e period() =0Get the current period for the counter.   virtual boost::leaf::result\u003c uint64_t \u003e count() =0Get the count of the counter.    Additional inherited members Public Functions inherited from embed::driver\u003c\u003e\n    Name     boost::leaf::result\u003c void \u003e initialize()Initialize the driver, apply the setting as defined in the settings_t structure and enable it. Calling this function after it has already been initialized will return false. In order to run initialization again, reset() must be called. After initialization, the settings are committed and saved into another settings structure. This settings can be looked up and inspected by the application.   void reset()Reset the driver in order to run initialize again. This is helpful if the application needs to change the settings of a driver after it is first initialized, like baud rate for serial or pull resistor for a pin.   bool is_initialized() constDetermine if the driver has been initialized.   settings_t \u0026 settings()Get access to uncommitted driver settings.   const settings_t \u0026 initialized_settings() constGet access to the settings that were used in the latest initialization. These settings only get updated when a successful initialize() has occurred.    Protected Functions inherited from embed::driver\u003c\u003e\n    Name     virtual boost::leaf::result\u003c void \u003e driver_initialize() =0Implementation of driver initialize by the inherited driver.    Protected Attributes inherited from embed::driver\u003c\u003e\n    Name     settings_t m_settings Mutable settings.   settings_t m_initialized_settings Saved version of the settings at initialization.   bool m_initialized Determines if the driver has been initialized.    Public Types Documentation enum controls    Enumerator Value Description     start  Control value to start the counter.   stop  Control value to stop a counter.   reset  Control value to reset a counter. The counter shall remain in a running or stopped state after this call. So an ongoing counter will continue to count but will have its counter reset to zero if this control is used. If a counter is stopped, then it shall be reset to zero, and stay stopped.    Set of controls for a counter.\nPublic Functions Documentation function is_running virtual boost::leaf::result\u003c bool \u003e is_running() =0 Determine if the counter is currently running.\nReturn: boost::leaf::result- true if the counter is currently running.\nfunction control virtual boost::leaf::result\u003c void \u003e control( controls p_control ) =0 Control the state of the counter.\nParameters:\n p_control - new state for the counter  Return: boost::leaf::result- any error that occured during this operation.\nfunction period virtual boost::leaf::result\u003c void \u003e period( std::chrono::nanoseconds p_period ) =0 Period for each count of the timer. For example a period of 1ms and a count of 500 would mean that 500ms has elapse since the counter has been started.\nParameters:\n p_period - the amount of time in nanoseconds each count should be  Return: boost::leaf::result- any error that occured during this operation.\nfunction period virtual boost::leaf::result\u003c std::chrono::nanoseconds \u003e period() =0 Get the current period for the counter.\nReturn: boost::leaf::resultstd::chrono::nanoseconds - the period of time for each count.\nfunction count virtual boost::leaf::result\u003c uint64_t \u003e count() =0 Get the count of the counter.\nReturn: boost::leaf::result\u003cuint64_t\u003e - the current count\n Updated on 2022-01-15 at 19:09:27 +0000\n","description":"","tags":null,"title":"embed::counter","uri":"/libembeddedhal/api/classes/classembed_1_1counter/"},{"content":"embed::dac Class Reference\nDigital to Analog Converter (DAC) hardware abstraction interface. More…\n#include \u003cdac.hpp\u003e\nInherits from embed::driver\u003c\u003e\nPublic Functions     Name     virtual boost::leaf::result\u003c void \u003e write(full_scale\u003c uint32_t \u003e p_value) =0Generate a voltage between a defined LOW and HIGH voltage.    Additional inherited members Public Functions inherited from embed::driver\u003c\u003e\n    Name     boost::leaf::result\u003c void \u003e initialize()Initialize the driver, apply the setting as defined in the settings_t structure and enable it. Calling this function after it has already been initialized will return false. In order to run initialization again, reset() must be called. After initialization, the settings are committed and saved into another settings structure. This settings can be looked up and inspected by the application.   void reset()Reset the driver in order to run initialize again. This is helpful if the application needs to change the settings of a driver after it is first initialized, like baud rate for serial or pull resistor for a pin.   bool is_initialized() constDetermine if the driver has been initialized.   settings_t \u0026 settings()Get access to uncommitted driver settings.   const settings_t \u0026 initialized_settings() constGet access to the settings that were used in the latest initialization. These settings only get updated when a successful initialize() has occurred.    Protected Functions inherited from embed::driver\u003c\u003e\n    Name     virtual boost::leaf::result\u003c void \u003e driver_initialize() =0Implementation of driver initialize by the inherited driver.    Protected Attributes inherited from embed::driver\u003c\u003e\n    Name     settings_t m_settings Mutable settings.   settings_t m_initialized_settings Saved version of the settings at initialization.   bool m_initialized Determines if the driver has been initialized.    Detailed Description class embed::dac; Digital to Analog Converter (DAC) hardware abstraction interface.\nUse this interface for devices and peripherals that can create arbitrary analog voltages between a defined LOW and HIGH voltage.\nPublic Functions Documentation function write virtual boost::leaf::result\u003c void \u003e write( full_scale\u003c uint32_t \u003e p_value ) =0 Generate a voltage between a defined LOW and HIGH voltage.\nParameters:\n p_value - precentage scale from LOW to HIGH  Return: boost::leaf::result- any error that occured during this operation.\nThe LOW and HIGH voltage are generally configured by a reference voltage (usually denoted V_ref) connected to the device. Generally though, the low voltage is 0V and the high voltage reference is VCC.\n Updated on 2022-01-15 at 19:09:27 +0000\n","description":"","tags":null,"title":"embed::dac","uri":"/libembeddedhal/api/classes/classembed_1_1dac/"},{"content":"embed::driver Class Reference\nThe basis class for all peripheral, device and system drivers in libembeddedhal. More…\n#include \u003cdriver.hpp\u003e\nInherited by embed::adc, embed::can_network, embed::counter, embed::dac, embed::pwm, embed::timer\nPublic Functions     Name     boost::leaf::result\u003c void \u003e initialize()Initialize the driver, apply the setting as defined in the settings_t structure and enable it. Calling this function after it has already been initialized will return false. In order to run initialization again, reset() must be called. After initialization, the settings are committed and saved into another settings structure. This settings can be looked up and inspected by the application.   void reset()Reset the driver in order to run initialize again. This is helpful if the application needs to change the settings of a driver after it is first initialized, like baud rate for serial or pull resistor for a pin.   bool is_initialized() constDetermine if the driver has been initialized.   settings_t \u0026 settings()Get access to uncommitted driver settings.   const settings_t \u0026 initialized_settings() constGet access to the settings that were used in the latest initialization. These settings only get updated when a successful initialize() has occurred.    Protected Functions     Name     virtual boost::leaf::result\u003c void \u003e driver_initialize() =0Implementation of driver initialize by the inherited driver.    Protected Attributes     Name     settings_t m_settings Mutable settings.   settings_t m_initialized_settings Saved version of the settings at initialization.   bool m_initialized Determines if the driver has been initialized.    Detailed Description template \u003cclass settings_t =no_settings\u003e class embed::driver; The basis class for all peripheral, device and system drivers in libembeddedhal.\nTemplate Parameters:\n - settings_t generic settings for the driver. For example, generic settings for a uart driver would have baud rate, stop bits and parity. This is expected of all UART devices and as such is part of the systems API.  Public Functions Documentation function initialize inline boost::leaf::result\u003c void \u003e initialize() Initialize the driver, apply the setting as defined in the settings_t structure and enable it. Calling this function after it has already been initialized will return false. In order to run initialization again, reset() must be called. After initialization, the settings are committed and saved into another settings structure. This settings can be looked up and inspected by the application.\nReturn: boost::leaf::result- returns an error if initialization of the driver failed.\nfunction reset inline void reset() Reset the driver in order to run initialize again. This is helpful if the application needs to change the settings of a driver after it is first initialized, like baud rate for serial or pull resistor for a pin.\nfunction is_initialized inline bool is_initialized() const Determine if the driver has been initialized.\nReturn:\n true the driver is initialized false the driver has not been initialized or has been reset  function settings inline settings_t \u0026 settings() Get access to uncommitted driver settings.\nReturn: settings_t\u0026 reference to the uncommitted driver settings. When initialize runs successful, the uncommitted settings will be saved to the initialize_settings().\nfunction initialized_settings inline const settings_t \u0026 initialized_settings() const Get access to the settings that were used in the latest initialization. These settings only get updated when a successful initialize() has occurred.\nReturn: const settings_t\u0026 the current settings of the driver if it is initialized. If the driver is not initialized, then the contents of this structure should be ignored as they may not represent the current of the driver.\nProtected Functions Documentation function driver_initialize virtual boost::leaf::result\u003c void \u003e driver_initialize() =0 Implementation of driver initialize by the inherited driver.\nReturn:\n true driver initialized successfully false driver initialization failed  Reimplemented by: embed::can_network::driver_initialize\nProtected Attributes Documentation variable m_settings settings_t m_settings {}; Mutable settings.\nvariable m_initialized_settings settings_t m_initialized_settings {}; Saved version of the settings at initialization.\nvariable m_initialized bool m_initialized = false; Determines if the driver has been initialized.\n Updated on 2022-01-15 at 19:09:27 +0000\n","description":"","tags":null,"title":"embed::driver","uri":"/libembeddedhal/api/classes/classembed_1_1driver/"},{"content":"embed::duty_cycle Struct Reference\nStructure containing cycle count for the high and low side of a signal duty cycle.\n#include \u003cfrequency.hpp\u003e\nPublic Functions     Name     constexpr auto operator==(const duty_cycle \u0026 p_cycle) const== operator    Public Attributes     Name     std::int64_t high Number of cycles the signal will stay in the HIGH voltage state.   std::int64_t low Number of cycles the signal will stay in the LOW voltage state.    Public Functions Documentation function operator== inline constexpr auto operator==( const duty_cycle \u0026 p_cycle ) const == operator\nParameters:\n p_cycle - other duty scale to compare to  Return: constexpr auto - true if the duty cycles have the exact same values.\nPublic Attributes Documentation variable high std::int64_t high = 0; Number of cycles the signal will stay in the HIGH voltage state.\nvariable low std::int64_t low = 0; Number of cycles the signal will stay in the LOW voltage state.\n Updated on 2022-01-15 at 19:09:27 +0000\n","description":"","tags":null,"title":"embed::duty_cycle","uri":"/libembeddedhal/api/classes/structembed_1_1duty__cycle/"},{"content":"embed::error Namespace Reference\nClasses     Name     struct embed::error::universal An association error type for all libembeddedhal drivers that inherit from this class. It is used to disambiguate errors coming from a libembeddedhal embed::driver vs those coming from other libraries.   class embed::error::stacktrace A structure to hold stack strace source location entries. The size of this class can be changed by changing the embed::config::stacktrace_depth_limit value in the libembeddedhal.tweak.hpp file for your project. This can be used to reduce the stack size of functions that have Boost.LEAF handlers that inspect a embed::error::stacktrace.    Functions     Name     auto setup(const char * p_function_name =std::source_location::current().function_name(), const char * p_file_name =std::source_location::current().file_name(), int p_line_number =std::source_location::current().line())Every function within libembeddedhal and implementing its interfaces that returns a boost::leaf::resultand can return an error must have the following line at the start of its function definition:   template \u003ctypename T \u003e constexpr auto get_return_value(boost::leaf::result\u003c T \u003e \u0026 p_result)Get the return value out of a resulttype. This function is used by the EMBED_CHECK macro and shouldn’t be used in general outside of that macro. If this function is called it MUST contain a value. This helper function for the EMBED_CHECK macro uses constexpr if in order to determine if the return type is void and in such situations returns an int 0 in its place. This way the EMBED_CHECK macro can stay small.    Functions Documentation function setup inline auto setup( const char * p_function_name =std::source_location::current().function_name(), const char * p_file_name =std::source_location::current().file_name(), int p_line_number =std::source_location::current().line() ) Every function within libembeddedhal and implementing its interfaces that returns a boost::leaf::resultand can return an error must have the following line at the start of its function definition:\nParameters:\n p_function_name - the name of the calling function p_file_name - the name of the file in which this function was called p_line_number - the line number in which this function was called  Return: auto - error handler for when an error is emitted on the calling functions frame.\nauto on_error = embed::error::setup(); If an error occurs, this function ensures the following:\n That embed::error::universal is associated with the error which is necessary to allow handlers to capture any libembeddedhal specific error but ignore the actual error itself. This is similar to a catch(std::exception const\u0026) where you simply want to capture any and all exceptions deriving from std::exception but still allow other exceptions to pass through. That a stacktrace is captured for the path where an error occurred Since this function setups handler for when errors occur, it does not make sense to call this function for functions that return boost::leaf::resultbut can never return an error. Thus this function should not be called on such functions.  function get_return_value template \u003ctypename T \u003e constexpr auto get_return_value( boost::leaf::result\u003c T \u003e \u0026 p_result ) Get the return value out of a resulttype. This function is used by the EMBED_CHECK macro and shouldn’t be used in general outside of that macro. If this function is called it MUST contain a value. This helper function for the EMBED_CHECK macro uses constexpr if in order to determine if the return type is void and in such situations returns an int 0 in its place. This way the EMBED_CHECK macro can stay small.\nParameters:\n p_result - the result with a value to be extracted.  Template Parameters:\n T - the return type of the function.  Return: constexpr auto\u0026\u0026 - value within the result. If the type is void, this function return int of value 0.\n Updated on 2022-01-15 at 19:09:27 +0000\n","description":"","tags":null,"title":"embed::error","uri":"/libembeddedhal/api/namespaces/namespaceembed_1_1error/"},{"content":"embed::error::stacktrace Class Reference\nA structure to hold stack strace source location entries. The size of this class can be changed by changing the embed::config::stacktrace_depth_limit value in the libembeddedhal.tweak.hpp file for your project. This can be used to reduce the stack size of functions that have Boost.LEAF handlers that inspect a embed::error::stacktrace.\n#include \u003cerror.hpp\u003e\nPublic Functions     Name     auto get() constGet the stack trace list items.   void append(boost::leaf::e_source_location p_source_location)Add a source location to the stack trace list.    Public Functions Documentation function get inline auto get() const Get the stack trace list items.\nReturn: auto - return a const span with length equal to the number of entries in the stacktrace list.\nfunction append inline void append( boost::leaf::e_source_location p_source_location ) Add a source location to the stack trace list.\nParameters:\n p_source_location - source location to be added to the list   Updated on 2022-01-15 at 19:09:27 +0000\n","description":"","tags":null,"title":"embed::error::stacktrace","uri":"/libembeddedhal/api/classes/classembed_1_1error_1_1stacktrace/"},{"content":"embed::error::universal Struct Reference\nAn association error type for all libembeddedhal drivers that inherit from this class. It is used to disambiguate errors coming from a libembeddedhal embed::driver vs those coming from other libraries.\n#include \u003cerror.hpp\u003e\n Updated on 2022-01-15 at 19:09:27 +0000\n","description":"","tags":null,"title":"embed::error::universal","uri":"/libembeddedhal/api/classes/structembed_1_1error_1_1universal/"},{"content":"embed::frequency Class Reference\nRepresents the frequency of a signal. It consists of a single integer 64-bit number that presents the integer representation of a signal frequency.\n#include \u003cfrequency.hpp\u003e\nPublic Types     Name     using std::int64_t int_t Integer type used throughout the class.    Public Functions     Name     template \u003cstd::integral T\u003e constexpr duty_cycle calculate_duty_cycle(int_t p_cycles, full_scale\u003c T \u003e p_precent)Generate a duty_cycle object based on the full_scalevalue and the input count value. The count value is split based on the ratio within full_scale   constexpr frequency(int_t p_value)construct the frequency object   constexpr auto cycles_per_second() constGet the frequency as an integer.   constexpr int_t divider(frequency p_target) constCalculate the frequency divider required to generate the output frequency provided.   template \u003ctypename Rep ,typename Period \u003e constexpr int_t cycles_per(std::chrono::duration\u003c Rep, Period \u003e p_duration) constCalculate the number of cycles of this frequency within the time duration. This function is meant for timers to determine how many count cycles are needed to reach a paricular time duration at this frequency.   template std::chrono::duration\u003c Rep, Period \u003e duration_from_cycles(int_t p_cycles)Calculate the time duration based on the frequency and a number of cycles.   template \u003cstd::integral T,typename Rep ,typename Period \u003e constexpr duty_cycle calculate_duty_cycle(std::chrono::duration\u003c Rep, Period \u003e p_duration, full_scale\u003c T \u003e p_precent) constCalculate a duty cycle based on a time duration, the full_scaleand this driving frequency. Typically used for PWM or clock lines with controllable duty cycles for serial communication.   template \u003cstd::integral T\u003e constexpr duty_cycle calculate_duty_cycle(frequency p_target, full_scale\u003c T \u003e p_precent) constCalculate a duty cycle based on a target, the full_scaleand this driving frequency. Typically used for PWM or clock lines with controllable duty cycles for serial communication.   constexpr auto operator\u003c=\u003e(const frequency \u0026 ) const =defaultDefault operators for \u003c, \u003c=, \u003e, \u003e= and ==.    Friends     Name     constexpr friend frequency operator+(frequency p_lhs, frequency p_rhs) sum two frequencies together   constexpr friend frequency operator-(frequency p_lhs, frequency p_rhs) subtract two frequencies from each other   constexpr friend frequency operator*(frequency p_lhs, Integer p_rhs) Scale up a frequency by an integer factor.   constexpr friend frequency operator*(Integer p_rhs, frequency p_lhs) Scale up a frequency by an integer factor.   constexpr friend frequency operator/(frequency p_lhs, Integer p_rhs) Scale down a frequency by an integer factor.   constexpr friend int_t operator/(frequency p_input, frequency p_target) Scale down a frequency by an integer factor.   constexpr friend int_t operator*(frequency p_input, std::chrono::duration\u003c Rep, Period \u003e p_duration) multiplying a frequency by a time period returns the number of cycles of the input frequency contained within the time duration.   constexpr friend int_t operator*(std::chrono::duration\u003c Rep, Period \u003e p_duration, frequency p_input) multiplying a frequency by a time period returns the number of cycles of the input frequency contained within the time duration.    Public Types Documentation using int_t using embed::frequency::int_t = std::int64_t; Integer type used throughout the class.\nPublic Functions Documentation function calculate_duty_cycle template \u003cstd::integral T\u003e static inline constexpr duty_cycle calculate_duty_cycle( int_t p_cycles, full_scale\u003c T \u003e p_precent ) Generate a duty_cycle object based on the full_scalevalue and the input count value. The count value is split based on the ratio within full_scaleParameters:\n p_cycles - the number of cycles to be split into a duty cycle p_precent - the target duty cycle percentage  Template Parameters:\n T - the integral type of full_scale  Return: constexpr duty_cycle - the duty cycle cycle counts\nfunction frequency inline explicit constexpr frequency( int_t p_value ) construct the frequency object\nParameters:\n p_value - frequency of the object  function cycles_per_second inline constexpr auto cycles_per_second() const Get the frequency as an integer.\nReturn: constexpr auto - frequency value as an integer\nfunction divider inline constexpr int_t divider( frequency p_target ) const Calculate the frequency divider required to generate the output frequency provided.\nParameters:\n p_target - the target output frequency  Return: constexpr int_t - the divider, when applied to this frequency, will achieve the p_target frequency. A value of is an error and 0 indicates that the output frequency is greater than this frequency and there does not exist an integer divider that can produce the output frequency.\nfunction cycles_per template \u003ctypename Rep , typename Period \u003e inline constexpr int_t cycles_per( std::chrono::duration\u003c Rep, Period \u003e p_duration ) const Calculate the number of cycles of this frequency within the time duration. This function is meant for timers to determine how many count cycles are needed to reach a paricular time duration at this frequency.\nParameters:\n p_duration - the target time duration to get a cycle count from  Template Parameters:\n Rep - type of the duration Period - ratio of the time duration relative to 1 second  Return: constexpr int_t - the number of cycles of this frequency within the duration.\nfunction duration_from_cycles template \u003ctypename Rep =std::chrono::nanoseconds::rep, typename Period =std::chrono::nanoseconds::period\u003e inline std::chrono::duration\u003c Rep, Period \u003e duration_from_cycles( int_t p_cycles ) Calculate the time duration based on the frequency and a number of cycles.\nParameters:\n p_cycles - number of cycles within the time duration  Template Parameters:\n Rep - type of the duration Period - ratio of the time duration relative to 1 second  Return: std::chrono::duration\u003cRep, Period\u003e - time duration based on this frequency and the number of cycles.\nfunction calculate_duty_cycle template \u003cstd::integral T, typename Rep , typename Period \u003e inline constexpr duty_cycle calculate_duty_cycle( std::chrono::duration\u003c Rep, Period \u003e p_duration, full_scale\u003c T \u003e p_precent ) const Calculate a duty cycle based on a time duration, the full_scaleand this driving frequency. Typically used for PWM or clock lines with controllable duty cycles for serial communication.\nParameters:\n p_duration - target time duration to reach p_precent - ratio of the duty cycle high time  Template Parameters:\n T - containing type of the full_scale Rep - containing type of the duration Period - ratio of the time duration relative to 1 second  Return: constexpr duty_cycle\nfunction calculate_duty_cycle template \u003cstd::integral T\u003e inline constexpr duty_cycle calculate_duty_cycle( frequency p_target, full_scale\u003c T \u003e p_precent ) const Calculate a duty cycle based on a target, the full_scaleand this driving frequency. Typically used for PWM or clock lines with controllable duty cycles for serial communication.\nParameters:\n p_target - target frequency to reach p_precent - ratio of the duty cycle high time  Template Parameters:\n T - containing type of the full_scale  Return: constexpr duty_cycle\nfunction operator\u003c=\u003e constexpr auto operator\u003c=\u003e( const frequency \u0026 ) const =default Default operators for \u003c, \u003c=, \u003e, \u003e= and ==.\nReturn: auto - result of the comparison\nFriends friend operator+ friend constexpr friend frequency operator+( frequency p_lhs, frequency p_rhs ); sum two frequencies together\nParameters:\n p_lhs - left hand frequency p_rhs - right hand frequency  Return: constexpr frequency - sum of the two frequencies\nfriend operator- friend constexpr friend frequency operator-( frequency p_lhs, frequency p_rhs ); subtract two frequencies from each other\nParameters:\n p_lhs - left hand frequency p_rhs - right hand frequency  Return: constexpr frequency - difference of two frequencies\nfriend operator* friend constexpr friend frequency operator*( frequency p_lhs, Integer p_rhs ); Scale up a frequency by an integer factor.\nParameters:\n p_lhs - the frequency to be scaled p_rhs - the integer value to scale the frequency by  Template Parameters:\n Integer - type of the integer  Return: constexpr frequency\nfriend operator* friend constexpr friend frequency operator*( Integer p_rhs, frequency p_lhs ); Scale up a frequency by an integer factor.\nParameters:\n p_lhs - the integer value to scale the frequency by p_rhs - the frequency to be scaled  Template Parameters:\n Integer - type of the integer  Return: constexpr frequency\nfriend operator/ friend constexpr friend frequency operator/( frequency p_lhs, Integer p_rhs ); Scale down a frequency by an integer factor.\nParameters:\n p_lhs - the frequency to be scaled p_rhs - the integer value to scale the frequency by  Template Parameters:\n Integer - type of the integer  Return: constexpr frequency\nfriend operator/ friend constexpr friend int_t operator/( frequency p_input, frequency p_target ); Scale down a frequency by an integer factor.\nParameters:\n p_input - the input frequency to be divided down to the target frequency with an integer divider p_target - the target frequency to reach via an integer divider  Return: constexpr int_t - frequency divider value representing the number of cycles in the input that constitute one cycle in the target frequency.\nfriend operator* friend constexpr friend int_t operator*( frequency p_input, std::chrono::duration\u003c Rep, Period \u003e p_duration ); multiplying a frequency by a time period returns the number of cycles of the input frequency contained within the time duration.\nParameters:\n p_input - the input frequency p_duration - the target time duration to get a cycle count from  Template Parameters:\n Rep - type of the duration Period - ratio of the time duration relative to 1 second  Return: constexpr int_t - the number of cycles of this frequency within the duration.\nfriend operator* friend constexpr friend int_t operator*( std::chrono::duration\u003c Rep, Period \u003e p_duration, frequency p_input ); multiplying a frequency by a time period returns the number of cycles of the input frequency contained within the time duration.\nParameters:\n p_input - the input frequency p_duration - the target time duration to get a cycle count from  Template Parameters:\n Rep - type of the duration Period - ratio of the time duration relative to 1 second  Return: constexpr int_t - the number of cycles of this frequency within the duration.\n Updated on 2022-01-15 at 19:09:27 +0000\n","description":"","tags":null,"title":"embed::frequency","uri":"/libembeddedhal/api/classes/classembed_1_1frequency/"},{"content":"embed::full_scale Class Reference\nA bit resolution erased representation of a precentage value using only integral arithmetic. More…\n#include \u003cfull_scale.hpp\u003e\nPublic Functions     Name     constexpr full_scale()construct a full scale value with initial value zero.   template \u003ctypename U ,size_t bit_width\u003e constexpr full_scale\u003c T \u003e \u0026 operator=(bit_depth\u003c U, bit_width \u003e p_value)Construct a full_scale based on the bit_depth value.   template \u003ctypename U ,size_t bit_width\u003e constexpr full_scale(bit_depth\u003c U, bit_width \u003e p_value)Construct a full_scale based on the bit_depth value.   constexpr full_scale(std::floating_point auto p_ratio)Construct a full_scale based on a floating point precentage value.   constexpr T value()Get internal integral value.    Public Attributes     Name     constexpr size_t bit_width Calculate the number.    Detailed Description template \u003ctypename T \u003e class embed::full_scale; A bit resolution erased representation of a precentage value using only integral arithmetic.\nTemplate Parameters:\n T - the integral type to represent the percentage value (typically uint32_t or int32_t)  Public Functions Documentation function full_scale inline constexpr full_scale() construct a full scale value with initial value zero.\nfunction operator= template \u003ctypename U , size_t bit_width\u003e inline constexpr full_scale\u003c T \u003e \u0026 operator=( bit_depth\u003c U, bit_width \u003e p_value ) Construct a full_scale based on the bit_depth value.\nParameters:\n p_value - the value at a specific bit resolution to scale up to a full scale value  Template Parameters:\n U - type of the bit depth object bit_width - the bit width of the object  Return: constexpr full_scale\u0026 - reference to this object\nfunction full_scale template \u003ctypename U , size_t bit_width\u003e inline constexpr full_scale( bit_depth\u003c U, bit_width \u003e p_value ) Construct a full_scale based on the bit_depth value.\nParameters:\n p_value - the bit depth object  Template Parameters:\n U - type of the bit depth object bit_width - the bit width of the object  function full_scale inline constexpr full_scale( std::floating_point auto p_ratio ) Construct a full_scale based on a floating point precentage value.\nParameters:\n p_ratio - floating point ratio value. For signed numbers this is clamped between 0.0 and 1.0. For signed numbers it is clamped between -1.0 to 1.0.  function value inline constexpr T value() Get internal integral value.\nReturn: T - full scale value\nPublic Attributes Documentation variable bit_width static constexpr size_t bit_width = sizeof(T) * CHAR_BIT; Calculate the number.\n Updated on 2022-01-15 at 19:09:27 +0000\n","description":"","tags":null,"title":"embed::full_scale","uri":"/libembeddedhal/api/classes/classembed_1_1full__scale/"},{"content":"embed::i2c Class Reference\nInter-integrated Circuit (I2C) or Two Wire Interface (TWI) communication protocol hardware abstract interface.\n#include \u003ci2c.hpp\u003e\nInherits from embed::driver\u003c i2c_settings \u003e\nPublic Classes     Name     struct address_not_acknowledged Error type indicating that the i2c transaction resulted in a NACK, meaning “not acknowledge”. NACKs occur when an address has been placed on the i2c bus and no device connected to the bus returned an acknowledge signal.   struct bus_error Error type indicating that the i2c lines were put into an invalid state during the transaction due to interference, misconfiguration of the i2c peripheral or the addressed device or something else.    Public Functions     Name     virtual boost::leaf::result\u003c void \u003e transaction(std::byte p_address, std::span\u003c const std::byte \u003e p_data_out, std::span\u003c std::byte \u003e p_data_in) =0perform an i2c transaction with another device on the bus. The type of transaction depends on values of input parameters. This function will block until the entire transfer is finished.    Additional inherited members Public Functions inherited from embed::driver\u003c i2c_settings \u003e\n    Name     boost::leaf::result\u003c void \u003e initialize()Initialize the driver, apply the setting as defined in the settings_t structure and enable it. Calling this function after it has already been initialized will return false. In order to run initialization again, reset() must be called. After initialization, the settings are committed and saved into another settings structure. This settings can be looked up and inspected by the application.   void reset()Reset the driver in order to run initialize again. This is helpful if the application needs to change the settings of a driver after it is first initialized, like baud rate for serial or pull resistor for a pin.   bool is_initialized() constDetermine if the driver has been initialized.   settings_t \u0026 settings()Get access to uncommitted driver settings.   const settings_t \u0026 initialized_settings() constGet access to the settings that were used in the latest initialization. These settings only get updated when a successful initialize() has occurred.    Protected Functions inherited from embed::driver\u003c i2c_settings \u003e\n    Name     virtual boost::leaf::result\u003c void \u003e driver_initialize() =0Implementation of driver initialize by the inherited driver.    Protected Attributes inherited from embed::driver\u003c i2c_settings \u003e\n    Name     settings_t m_settings Mutable settings.   settings_t m_initialized_settings Saved version of the settings at initialization.   bool m_initialized Determines if the driver has been initialized.    Public Functions Documentation function transaction virtual boost::leaf::result\u003c void \u003e transaction( std::byte p_address, std::span\u003c const std::byte \u003e p_data_out, std::span\u003c std::byte \u003e p_data_in ) =0 perform an i2c transaction with another device on the bus. The type of transaction depends on values of input parameters. This function will block until the entire transfer is finished.\nParameters:\n p_address 7-bit address of the device you want to communicate with. To perform a transaction with a 10-bit address, this parameter must be the address upper byte of the 10-bit address OR’d with 0b1111'0000 (the 10-bit address indicator). The lower byte of the address must be contained in the first byte of the p_data_out span. p_data_out data to be written to the addressed device. Set to nullptr with length zero in order to skip writting. p_data_in buffer to store read data from the addressed device. Set to nullptr with length 0 in order to skip reading.  Return: boost::leaf::result- any error that occurred during this operation.\nPerforming Write, Read and Write-Then-Read transactions depends on which span for data_out and data_in are set to null.\n For write transactions, pass p_data_in as an empty span std::span\u003cstd::byte\u003e{} and pass a buffer to p_data_out. For read transactions, pass p_data_out as an empty span std::span\u003cconst std::byte\u003e{} and pass a buffer to p_data_in. For write-then-read transactions, pass a buffer for both p_data_in p_data_out. In the event of arbitration loss, this function will wait for the bus to become free and try again. Arbitration loss means that during the address phase of a transaction 1 or more i2c bus controllers attempted to perform an transaction and one of the i2c bus controllers, that isn’t this one won out.   Updated on 2022-01-15 at 19:09:27 +0000\n","description":"","tags":null,"title":"embed::i2c","uri":"/libembeddedhal/api/classes/classembed_1_1i2c/"},{"content":"embed::i2c::address_not_acknowledged Struct Reference\nError type indicating that the i2c transaction resulted in a NACK, meaning “not acknowledge”. NACKs occur when an address has been placed on the i2c bus and no device connected to the bus returned an acknowledge signal. More…\n#include \u003ci2c.hpp\u003e\nDetailed Description struct embed::i2c::address_not_acknowledged; Error type indicating that the i2c transaction resulted in a NACK, meaning “not acknowledge”. NACKs occur when an address has been placed on the i2c bus and no device connected to the bus returned an acknowledge signal.\nHow to handle these errors:\n In cases where the program is scanning for available addresses, this error is expected behaviour. This is less of an error to handle but an expected return status. If a driver has a set of possible addresses that it can use, and for that driver it makes sense to attempt to search for the valid address, then a handler can keep performing transactions until a valid address is found and then store that address. In the case where the address is consistently NACK’ed but the driver expects a specific address, this is typically not handleable and indicates that the application or driver is incorrect in the device address. In the case where NACK’s are spurious, then this may indicate that the i2c line is faulty or the device is misbehaving. This is not fixable in the application. But in some cases, if a software solution is required, the driver or application can simply retry again until a valid response is returned, but results may vary and are very specific to the devices and context of the situation.   Updated on 2022-01-15 at 19:09:27 +0000\n","description":"","tags":null,"title":"embed::i2c::address_not_acknowledged","uri":"/libembeddedhal/api/classes/structembed_1_1i2c_1_1address__not__acknowledged/"},{"content":"embed::i2c::bus_error Struct Reference\nError type indicating that the i2c lines were put into an invalid state during the transaction due to interference, misconfiguration of the i2c peripheral or the addressed device or something else. More…\n#include \u003ci2c.hpp\u003e\nDetailed Description struct embed::i2c::bus_error; Error type indicating that the i2c lines were put into an invalid state during the transaction due to interference, misconfiguration of the i2c peripheral or the addressed device or something else.\nHow to handle these errors:\n In the event of this type of error, state the addressed device undefined. In the case of data reception, the data coming from the addressed device should be considered invalid. Any deeper handling will require deep context regarding the addressed device the transaction taking place.   Updated on 2022-01-15 at 19:09:27 +0000\n","description":"","tags":null,"title":"embed::i2c::bus_error","uri":"/libembeddedhal/api/classes/structembed_1_1i2c_1_1bus__error/"},{"content":"embed::i2c_settings Struct Reference\nGeneric settings for a standard I2C device.\n#include \u003ci2c.hpp\u003e\nPublic Attributes     Name     frequency clock_rate The serial clock rate in hertz.    Public Attributes Documentation variable clock_rate frequency clock_rate = default_clock_rate; The serial clock rate in hertz.\n Updated on 2022-01-15 at 19:09:27 +0000\n","description":"","tags":null,"title":"embed::i2c_settings","uri":"/libembeddedhal/api/classes/structembed_1_1i2c__settings/"},{"content":"embed::input_pin Class Reference\nDigital input pin hardware abstraction. More…\n#include \u003cgpio.hpp\u003e\nInherits from embed::driver\u003c input_pin_settings \u003e\nPublic Functions     Name     virtual boost::leaf::result\u003c bool \u003e level() const =0Read the state of the input pin.    Additional inherited members Public Functions inherited from embed::driver\u003c input_pin_settings \u003e\n    Name     boost::leaf::result\u003c void \u003e initialize()Initialize the driver, apply the setting as defined in the settings_t structure and enable it. Calling this function after it has already been initialized will return false. In order to run initialization again, reset() must be called. After initialization, the settings are committed and saved into another settings structure. This settings can be looked up and inspected by the application.   void reset()Reset the driver in order to run initialize again. This is helpful if the application needs to change the settings of a driver after it is first initialized, like baud rate for serial or pull resistor for a pin.   bool is_initialized() constDetermine if the driver has been initialized.   settings_t \u0026 settings()Get access to uncommitted driver settings.   const settings_t \u0026 initialized_settings() constGet access to the settings that were used in the latest initialization. These settings only get updated when a successful initialize() has occurred.    Protected Functions inherited from embed::driver\u003c input_pin_settings \u003e\n    Name     virtual boost::leaf::result\u003c void \u003e driver_initialize() =0Implementation of driver initialize by the inherited driver.    Protected Attributes inherited from embed::driver\u003c input_pin_settings \u003e\n    Name     settings_t m_settings Mutable settings.   settings_t m_initialized_settings Saved version of the settings at initialization.   bool m_initialized Determines if the driver has been initialized.    Detailed Description class embed::input_pin; Digital input pin hardware abstraction.\nUse this to read a pin and determine if the voltage on it is HIGH or LOW.\nPublic Functions Documentation function level virtual boost::leaf::result\u003c bool \u003e level() const =0 Read the state of the input pin.\nReturn: boost::leaf::result- true indicates HIGH voltage and false indicates LOW voltage\n Updated on 2022-01-15 at 19:09:27 +0000\n","description":"","tags":null,"title":"embed::input_pin","uri":"/libembeddedhal/api/classes/classembed_1_1input__pin/"},{"content":"embed::input_pin_settings Struct Reference\nGeneric settings for input pins.\n#include \u003cgpio.hpp\u003e\nPublic Attributes     Name     pin_resistor resistor pull resistor for an input pin    Public Attributes Documentation variable resistor pin_resistor resistor = pin_resistor::pull_up; pull resistor for an input pin\n Updated on 2022-01-15 at 19:09:27 +0000\n","description":"","tags":null,"title":"embed::input_pin_settings","uri":"/libembeddedhal/api/classes/structembed_1_1input__pin__settings/"},{"content":"embed::interrupt_pin Class Reference\nDigital interrupt pin hardware abstraction. More…\n#include \u003cgpio.hpp\u003e\nInherits from embed::driver\u003c interrupt_pin_settings \u003e\nPublic Types     Name     enum class trigger_edge { falling = 0, rising = 1, both = 2}The condition in which an interrupt is triggered.    Public Functions     Name     virtual boost::leaf::result\u003c bool \u003e level() const =0Return the voltage level of the pin.   virtual boost::leaf::result\u003c void \u003e attach_interrupt(std::function\u003c void(void)\u003e p_callback, trigger_edge p_trigger) =0Enable interrupts for this pin. Pass in the callback to be executed when the trigger condition is met. This function can be called multiple times if the callback or trigger conditions need to be changed. detach_interrupts() does not need to be called before re-running this function.   virtual boost::leaf::result\u003c void \u003e detach_interrupt() =0Disable interrupts for this pin.    Additional inherited members Public Functions inherited from embed::driver\u003c interrupt_pin_settings \u003e\n    Name     boost::leaf::result\u003c void \u003e initialize()Initialize the driver, apply the setting as defined in the settings_t structure and enable it. Calling this function after it has already been initialized will return false. In order to run initialization again, reset() must be called. After initialization, the settings are committed and saved into another settings structure. This settings can be looked up and inspected by the application.   void reset()Reset the driver in order to run initialize again. This is helpful if the application needs to change the settings of a driver after it is first initialized, like baud rate for serial or pull resistor for a pin.   bool is_initialized() constDetermine if the driver has been initialized.   settings_t \u0026 settings()Get access to uncommitted driver settings.   const settings_t \u0026 initialized_settings() constGet access to the settings that were used in the latest initialization. These settings only get updated when a successful initialize() has occurred.    Protected Functions inherited from embed::driver\u003c interrupt_pin_settings \u003e\n    Name     virtual boost::leaf::result\u003c void \u003e driver_initialize() =0Implementation of driver initialize by the inherited driver.    Protected Attributes inherited from embed::driver\u003c interrupt_pin_settings \u003e\n    Name     settings_t m_settings Mutable settings.   settings_t m_initialized_settings Saved version of the settings at initialization.   bool m_initialized Determines if the driver has been initialized.    Detailed Description class embed::interrupt_pin; Digital interrupt pin hardware abstraction.\nUse this to trigger an interrupt service routine (ISR) when a pin detects a falling edge (when the pin’s voltage transitions from HIGH to LOW), a rising edge (when the pin’s voltage transitions from LOW to HIGH), or any transition of state on the pin.\nPublic Types Documentation enum trigger_edge    Enumerator Value Description     falling 0 Trigger and interrupt when a pin transitions from HIGH voltage to LOW voltage.   rising 1 Trigger and interrupt when a pin transitions from LOW voltage to HIGH voltage.   both 2 Trigger and interrupt when a pin transitions it state.    The condition in which an interrupt is triggered.\nPublic Functions Documentation function level virtual boost::leaf::result\u003c bool \u003e level() const =0 Return the voltage level of the pin.\nReturn: boost::leaf::result- any error that occured during this operation.\nfunction attach_interrupt virtual boost::leaf::result\u003c void \u003e attach_interrupt( std::function\u003c void(void)\u003e p_callback, trigger_edge p_trigger ) =0 Enable interrupts for this pin. Pass in the callback to be executed when the trigger condition is met. This function can be called multiple times if the callback or trigger conditions need to be changed. detach_interrupts() does not need to be called before re-running this function.\nParameters:\n p_callback function to execute when the trigger condition is met p_trigger the trigger condition that will signal the system to run the callback.  Return: boost::leaf::result- any error that occured during this operation.\nfunction detach_interrupt virtual boost::leaf::result\u003c void \u003e detach_interrupt() =0 Disable interrupts for this pin.\nReturn: boost::leaf::result- any error that occured during this operation.\n Updated on 2022-01-15 at 19:09:27 +0000\n","description":"","tags":null,"title":"embed::interrupt_pin","uri":"/libembeddedhal/api/classes/classembed_1_1interrupt__pin/"},{"content":"embed::interrupt_pin_settings Struct Reference\nGeneric settings for interrupt pins.\n#include \u003cgpio.hpp\u003e\nPublic Attributes     Name     pin_resistor resistor pull resistor for an interrupt pin. Generally advised to NOT use pin_resistor::none and if it is used and external pull resistor should be placed on the pin to prevent random interrupt from firing.    Public Attributes Documentation variable resistor pin_resistor resistor = pin_resistor::pull_up; pull resistor for an interrupt pin. Generally advised to NOT use pin_resistor::none and if it is used and external pull resistor should be placed on the pin to prevent random interrupt from firing.\n Updated on 2022-01-15 at 19:09:27 +0000\n","description":"","tags":null,"title":"embed::interrupt_pin_settings","uri":"/libembeddedhal/api/classes/structembed_1_1interrupt__pin__settings/"},{"content":"embed::invalid_option_t Struct Reference\nUsed for defining static_asserts that should always fail, but only if the static_assert line is hit via if constexpr control block. Prefer to NOT use this directly but to use invalid_option instead. More…\n#include \u003cdriver.hpp\u003e\nInherits from std::false_type\nDetailed Description template \u003cauto... options\u003e struct embed::invalid_option_t; Used for defining static_asserts that should always fail, but only if the static_assert line is hit via if constexpr control block. Prefer to NOT use this directly but to use invalid_option instead.\nTemplate Parameters:\n options ignored by the application but needed to create a non-trivial specialization of this class which allows its usage in static_assert.   Updated on 2022-01-15 at 19:09:27 +0000\n","description":"","tags":null,"title":"embed::invalid_option_t","uri":"/libembeddedhal/api/classes/structembed_1_1invalid__option__t/"},{"content":"embed::literals Namespace Reference\nFunctions     Name     constexpr frequency operator\"\"_Hz(unsigned long long p_value)user defined literals for making frequencies: 1337_Hz   constexpr frequency operator\"\"_kHz(unsigned long long p_value)user defined literals for making frequencies in the kilohertz range: 20_kHz   constexpr frequency operator\"\"_MHz(unsigned long long p_value)user defined literals for making frequencies in the megahertz range: 14_MHz    Functions Documentation function operator\"\"_Hz constexpr frequency operator\"\"_Hz( unsigned long long p_value ) user defined literals for making frequencies: 1337_Hz\nParameters:\n p_value  Return: constexpr frequency\nfunction operator\"\"_kHz constexpr frequency operator\"\"_kHz( unsigned long long p_value ) user defined literals for making frequencies in the kilohertz range: 20_kHz\nParameters:\n p_value  Return: constexpr frequency\nfunction operator\"\"_MHz constexpr frequency operator\"\"_MHz( unsigned long long p_value ) user defined literals for making frequencies in the megahertz range: 14_MHz\nParameters:\n p_value  Return: constexpr frequency\n Updated on 2022-01-15 at 19:09:27 +0000\n","description":"","tags":null,"title":"embed::literals","uri":"/libembeddedhal/api/namespaces/namespaceembed_1_1literals/"},{"content":"embed::no_settings Struct Reference\nAn empty settings structure used to indicate that a driver or interface does not have generic settings.\n#include \u003cdriver.hpp\u003e\n Updated on 2022-01-15 at 19:09:27 +0000\n","description":"","tags":null,"title":"embed::no_settings","uri":"/libembeddedhal/api/classes/structembed_1_1no__settings/"},{"content":"embed::output_pin Class Reference\nDigital output pin hardware abstraction. More…\n#include \u003cgpio.hpp\u003e\nInherits from embed::driver\u003c output_pin_settings \u003e\nPublic Functions     Name     virtual boost::leaf::result\u003c void \u003e level(bool p_high) =0Set the state of the pin.   virtual boost::leaf::result\u003c bool \u003e level() const =0Read the state of the input pin. Implementations must read the pin state from hardware and will not simply cache the results from running level(bool).    Additional inherited members Public Functions inherited from embed::driver\u003c output_pin_settings \u003e\n    Name     boost::leaf::result\u003c void \u003e initialize()Initialize the driver, apply the setting as defined in the settings_t structure and enable it. Calling this function after it has already been initialized will return false. In order to run initialization again, reset() must be called. After initialization, the settings are committed and saved into another settings structure. This settings can be looked up and inspected by the application.   void reset()Reset the driver in order to run initialize again. This is helpful if the application needs to change the settings of a driver after it is first initialized, like baud rate for serial or pull resistor for a pin.   bool is_initialized() constDetermine if the driver has been initialized.   settings_t \u0026 settings()Get access to uncommitted driver settings.   const settings_t \u0026 initialized_settings() constGet access to the settings that were used in the latest initialization. These settings only get updated when a successful initialize() has occurred.    Protected Functions inherited from embed::driver\u003c output_pin_settings \u003e\n    Name     virtual boost::leaf::result\u003c void \u003e driver_initialize() =0Implementation of driver initialize by the inherited driver.    Protected Attributes inherited from embed::driver\u003c output_pin_settings \u003e\n    Name     settings_t m_settings Mutable settings.   settings_t m_initialized_settings Saved version of the settings at initialization.   bool m_initialized Determines if the driver has been initialized.    Detailed Description class embed::output_pin; Digital output pin hardware abstraction.\nUse this to drive a pin HIGH or LOW in order to send a control signal or turn off or on an LED.\nPublic Functions Documentation function level virtual boost::leaf::result\u003c void \u003e level( bool p_high ) =0 Set the state of the pin.\nParameters:\n p_high - if true then the pin state is set to HIGH voltage. If false, the pin state is set to LOW voltage.  Return: boost::leaf::result- any error that occured during this operation.\nfunction level virtual boost::leaf::result\u003c bool \u003e level() const =0 Read the state of the input pin. Implementations must read the pin state from hardware and will not simply cache the results from running level(bool).\nReturn: boost::leaf::result- true indicates HIGH voltage and false indicates LOW voltage\n Updated on 2022-01-15 at 19:09:27 +0000\n","description":"","tags":null,"title":"embed::output_pin","uri":"/libembeddedhal/api/classes/classembed_1_1output__pin/"},{"content":"embed::output_pin_settings Struct Reference\nGeneric settings for output pins.\n#include \u003cgpio.hpp\u003e\nPublic Attributes     Name     bool starting_level Set the starting level of the output pin on initialization. HIGH voltage defined as true and LOW voltage defined as false.   bool open_drain Starting level of the output pin. HIGH voltage defined as true and LOW voltage defined as false.   pin_resistor resistor Pull resistor for the pin. This generally only helpful when open drain is enabled.    Public Attributes Documentation variable starting_level bool starting_level = true; Set the starting level of the output pin on initialization. HIGH voltage defined as true and LOW voltage defined as false.\nvariable open_drain bool open_drain = false; Starting level of the output pin. HIGH voltage defined as true and LOW voltage defined as false.\nvariable resistor pin_resistor resistor = pin_resistor::pull_up; Pull resistor for the pin. This generally only helpful when open drain is enabled.\n Updated on 2022-01-15 at 19:09:27 +0000\n","description":"","tags":null,"title":"embed::output_pin_settings","uri":"/libembeddedhal/api/classes/structembed_1_1output__pin__settings/"},{"content":"embed::pwm Class Reference\nPulse Width Modulation (PWM) channel hardware abstraction.\n#include \u003cpwm.hpp\u003e\nInherits from embed::driver\u003c\u003e\nAdditional inherited members Public Functions inherited from embed::driver\u003c\u003e\n    Name     boost::leaf::result\u003c void \u003e initialize()Initialize the driver, apply the setting as defined in the settings_t structure and enable it. Calling this function after it has already been initialized will return false. In order to run initialization again, reset() must be called. After initialization, the settings are committed and saved into another settings structure. This settings can be looked up and inspected by the application.   void reset()Reset the driver in order to run initialize again. This is helpful if the application needs to change the settings of a driver after it is first initialized, like baud rate for serial or pull resistor for a pin.   bool is_initialized() constDetermine if the driver has been initialized.   settings_t \u0026 settings()Get access to uncommitted driver settings.   const settings_t \u0026 initialized_settings() constGet access to the settings that were used in the latest initialization. These settings only get updated when a successful initialize() has occurred.    Protected Functions inherited from embed::driver\u003c\u003e\n    Name     virtual boost::leaf::result\u003c void \u003e driver_initialize() =0Implementation of driver initialize by the inherited driver.    Protected Attributes inherited from embed::driver\u003c\u003e\n    Name     settings_t m_settings Mutable settings.   settings_t m_initialized_settings Saved version of the settings at initialization.   bool m_initialized Determines if the driver has been initialized.     Updated on 2022-01-15 at 19:09:27 +0000\n","description":"","tags":null,"title":"embed::pwm","uri":"/libembeddedhal/api/classes/classembed_1_1pwm/"},{"content":"embed::serial Class Reference\nSerial communication protocol hardware abstract interface. More…\n#include \u003cserial.hpp\u003e\nInherits from embed::driver\u003c serial_settings \u003e\nPublic Classes     Name     struct frame_error Error type indicating that a frame error occured during reception. This error is returned when calling bytes_available().   struct packets_lost Error indicating that packets were lost during reception. This occurs when the buffer is overrun and reaches the end of the circular buffer. This error is returned when calling bytes_available().   struct parity_error Error type indicating that a parity error occured during reception. This error is returned when calling bytes_available().    Public Functions     Name     virtual boost::leaf::result\u003c void \u003e write(std::span\u003c const std::byte \u003e p_data) =0Write data on the transmitter line of the port. This function will block until the entire transfer is finished.   virtual boost::leaf::result\u003c size_t \u003e bytes_available() =0The number of bytes that have been buffered. For frames less than 8-bits, each byte holds a frame. For frames above 8-bits the number of bytes returned indicates the number of bytes a buffer needs to be to return all of the data held in the buffer.   virtual boost::leaf::result\u003c std::span\u003c const std::byte \u003e \u003e read(std::span\u003c std::byte \u003e p_data) =0Read the bytes received over the ports receiver line and stored in the serial implementations buffer. The number of bytes read will subtract the number of bytes available until it reaches zero.   virtual boost::leaf::result\u003c void \u003e flush() =0Set bytes_available() to zero and clear any received data stored in hardware registers. This operation must be faster than simply running read() until bytes_available() is empty.    Additional inherited members Public Functions inherited from embed::driver\u003c serial_settings \u003e\n    Name     boost::leaf::result\u003c void \u003e initialize()Initialize the driver, apply the setting as defined in the settings_t structure and enable it. Calling this function after it has already been initialized will return false. In order to run initialization again, reset() must be called. After initialization, the settings are committed and saved into another settings structure. This settings can be looked up and inspected by the application.   void reset()Reset the driver in order to run initialize again. This is helpful if the application needs to change the settings of a driver after it is first initialized, like baud rate for serial or pull resistor for a pin.   bool is_initialized() constDetermine if the driver has been initialized.   settings_t \u0026 settings()Get access to uncommitted driver settings.   const settings_t \u0026 initialized_settings() constGet access to the settings that were used in the latest initialization. These settings only get updated when a successful initialize() has occurred.    Protected Functions inherited from embed::driver\u003c serial_settings \u003e\n    Name     virtual boost::leaf::result\u003c void \u003e driver_initialize() =0Implementation of driver initialize by the inherited driver.    Protected Attributes inherited from embed::driver\u003c serial_settings \u003e\n    Name     settings_t m_settings Mutable settings.   settings_t m_initialized_settings Saved version of the settings at initialization.   bool m_initialized Determines if the driver has been initialized.    Detailed Description class embed::serial; Serial communication protocol hardware abstract interface.\nUse this interface for hardware that implements a serial protocol like UART, RS232, RS485 and many others that use a similar communication protocol but may use different voltage schemes.\nDue to the asynchronous nature of serial communication protocols, all implementations of serial devices MUST buffer received bytes using DMA or interrupts. A thread should not be used as this generally greatly increases the ROM and RAM cost of using library.\nAll implementations MUST allow the user to supply their own buffer of arbitrary size, such that the amount of buffered data can be tailored to the needs of the application.\nPublic Functions Documentation function write virtual boost::leaf::result\u003c void \u003e write( std::span\u003c const std::byte \u003e p_data ) =0 Write data on the transmitter line of the port. This function will block until the entire transfer is finished.\nParameters:\n p_data - data to be transmitted over the serial port transmitter line  Return: boost::leaf::result- any error that occured during this operation.\nData frames are not compact when frame size is less than 8 bits. Meaning that, if you want to send three 5-bit frames, then you will need to use a span of at least 3 bytes to hold each value.\nWhen writing data with frame size greater than 8 is in little endian order. Meaning that the first byte in the sequence is the lower byte and the next is the greater byte. If you wanted to send a 9-bit frame with value 0x14A, the first byte must be 0x4A and the next 0x01.\nserial ports will report transmit_error will an error occurs. Any other reported error will bubble up come from\nfunction bytes_available virtual boost::leaf::result\u003c size_t \u003e bytes_available() =0 The number of bytes that have been buffered. For frames less than 8-bits, each byte holds a frame. For frames above 8-bits the number of bytes returned indicates the number of bytes a buffer needs to be to return all of the data held in the buffer.\nReturn: boost::leaf::result\u003csize_t\u003e - number of buffered by the serial driver and are available to be read by the read() function.\nfunction read virtual boost::leaf::result\u003c std::span\u003c const std::byte \u003e \u003e read( std::span\u003c std::byte \u003e p_data ) =0 Read the bytes received over the ports receiver line and stored in the serial implementations buffer. The number of bytes read will subtract the number of bytes available until it reaches zero.\nParameters:\n p_data - Buffer to read bytes back from. If the length of this buffer is greater than the value returned by bytes_available() then buffer is filled up to the length returned by bytes_available(). The rest of the buffer is left untouched.  Return: boost::leaf::result\u003cstd::span\u003e - provides a means to get the length of bytes read into the buffer p_data. The address will ALWAYS be the same as p_data and the length will be equal to the number of bytes read from the buffer.\nfunction flush virtual boost::leaf::result\u003c void \u003e flush() =0 Set bytes_available() to zero and clear any received data stored in hardware registers. This operation must be faster than simply running read() until bytes_available() is empty.\nReturn: boost::leaf::result- any error that occured during this operation.\n Updated on 2022-01-15 at 19:09:27 +0000\n","description":"","tags":null,"title":"embed::serial","uri":"/libembeddedhal/api/classes/classembed_1_1serial/"},{"content":"embed::serial::frame_error Struct Reference\nError type indicating that a frame error occured during reception. This error is returned when calling bytes_available(). More…\n#include \u003cserial.hpp\u003e\nPublic Attributes     Name     size_t bytes_available The number of bytes the serial port has buffered up.    Detailed Description struct embed::serial::frame_error; Error type indicating that a frame error occured during reception. This error is returned when calling bytes_available().\nHow to handle these errors:\n In general, the exact nature of a specific frame error is not knowable. The number of bytes that are effected could be 1 or more, thus the only real way to handle this is to flush recieve buffer and attempt reception again. Note that the read function should still work to read out which ever bytes were received and this can be used/logged in order for developers to get insight into where the error occured and how to fix it.  Public Attributes Documentation variable bytes_available size_t bytes_available; The number of bytes the serial port has buffered up.\n Updated on 2022-01-15 at 19:09:27 +0000\n","description":"","tags":null,"title":"embed::serial::frame_error","uri":"/libembeddedhal/api/classes/structembed_1_1serial_1_1frame__error/"},{"content":"embed::serial::packets_lost Struct Reference\nError indicating that packets were lost during reception. This occurs when the buffer is overrun and reaches the end of the circular buffer. This error is returned when calling bytes_available(). More…\n#include \u003cserial.hpp\u003e\nPublic Attributes     Name     std::optional\u003c size_t \u003e packets_dropped   size_t bytes_available The number of bytes the serial port has buffered up.    Detailed Description struct embed::serial::packets_lost; Error indicating that packets were lost during reception. This occurs when the buffer is overrun and reaches the end of the circular buffer. This error is returned when calling bytes_available().\nHow to handle these errors:\n This sort of error is very context heavy. If the packet lengths are short and numerous and with a consistent format, then the application may be able to pull out all but the last few packets of data from the buffer and treat the ones at the end as lost packets. In most other cases where data lost was crucial, then the whole buffer may need to be flushed and the data recieved again. A way to fix this is to enlarge the recieve buffer. This can be done with dynamic memory allocation, but generally, its better to simply increase the buffer size by updating the application rather than growing with need.  Public Attributes Documentation variable packets_dropped std::optional\u003c size_t \u003e packets_dropped; The number of packets dropped. This value is optional because some drivers cannot provide a number for the number of packets dropped.\nvariable bytes_available size_t bytes_available; The number of bytes the serial port has buffered up.\n Updated on 2022-01-15 at 19:09:27 +0000\n","description":"","tags":null,"title":"embed::serial::packets_lost","uri":"/libembeddedhal/api/classes/structembed_1_1serial_1_1packets__lost/"},{"content":"embed::serial::parity_error Struct Reference\nError type indicating that a parity error occured during reception. This error is returned when calling bytes_available(). More…\n#include \u003cserial.hpp\u003e\nPublic Attributes     Name     size_t bytes_available The number of bytes the serial port has buffered up.    Detailed Description struct embed::serial::parity_error; Error type indicating that a parity error occured during reception. This error is returned when calling bytes_available().\nHow to handle these errors:\n The nature of this error is almost exactly the same as frame_error. See frame_error’s description on how to handle this.  Public Attributes Documentation variable bytes_available size_t bytes_available; The number of bytes the serial port has buffered up.\n Updated on 2022-01-15 at 19:09:27 +0000\n","description":"","tags":null,"title":"embed::serial::parity_error","uri":"/libembeddedhal/api/classes/structembed_1_1serial_1_1parity__error/"},{"content":"embed::serial_settings Struct Reference\nGeneric settings for a standard serial device.\n#include \u003cserial.hpp\u003e\nPublic Types     Name     enum class uint8_t stop_bits { one = 0, two}Set of available stop bits options.   enum class uint8_t parity { none = 0, odd, even, forced1, forced0}Set of parity bit options.    Public Attributes     Name     uint32_t baud_rate The operating speed of the baud rate (in units of bits per second)   parity parity Parity bit type for each frame.   stop_bits stop Number of stop bits for each frame.   uint8_t frame_size Number of bits in each frame. Typically between 5 to 9.    Public Types Documentation enum stop_bits    Enumerator Value Description     one 0    two      Set of available stop bits options.\nenum parity    Enumerator Value Description     none 0 Disable parity bit as part of the frame.   odd  Enable parity and set 1 (HIGH) when the number of bits is odd.   even  Enable parity and set 1 (HIGH) when the number of bits is even.   forced1  Enable parity bit and always return 1 (HIGH) for ever frame.   forced0  Enable parity bit and always return 0 (LOW) for ever frame.    Set of parity bit options.\nPublic Attributes Documentation variable baud_rate uint32_t baud_rate = 115200; The operating speed of the baud rate (in units of bits per second)\nvariable parity parity parity = parity::none; Parity bit type for each frame.\nvariable stop stop_bits stop = stop_bits::one; Number of stop bits for each frame.\nvariable frame_size uint8_t frame_size = 8; Number of bits in each frame. Typically between 5 to 9.\n Updated on 2022-01-15 at 19:09:27 +0000\n","description":"","tags":null,"title":"embed::serial_settings","uri":"/libembeddedhal/api/classes/structembed_1_1serial__settings/"},{"content":"embed::spi Class Reference\nSerial peripheral interface (SPI) communication protocol hardware abstract interface.\n#include \u003cspi.hpp\u003e\nInherits from embed::driver\u003c spi_settings \u003e\nPublic Functions     Name     virtual boost::leaf::result\u003c void \u003e transfer(std::span\u003c const std::byte \u003e p_data_out, std::span\u003c std::byte \u003e p_data_in, std::byte p_write_value =std::byte{ 0xFF }) =0Send and receieve data between a selected device on the spi bus. This function will block until the entire transfer is finished.    Additional inherited members Public Functions inherited from embed::driver\u003c spi_settings \u003e\n    Name     boost::leaf::result\u003c void \u003e initialize()Initialize the driver, apply the setting as defined in the settings_t structure and enable it. Calling this function after it has already been initialized will return false. In order to run initialization again, reset() must be called. After initialization, the settings are committed and saved into another settings structure. This settings can be looked up and inspected by the application.   void reset()Reset the driver in order to run initialize again. This is helpful if the application needs to change the settings of a driver after it is first initialized, like baud rate for serial or pull resistor for a pin.   bool is_initialized() constDetermine if the driver has been initialized.   settings_t \u0026 settings()Get access to uncommitted driver settings.   const settings_t \u0026 initialized_settings() constGet access to the settings that were used in the latest initialization. These settings only get updated when a successful initialize() has occurred.    Protected Functions inherited from embed::driver\u003c spi_settings \u003e\n    Name     virtual boost::leaf::result\u003c void \u003e driver_initialize() =0Implementation of driver initialize by the inherited driver.    Protected Attributes inherited from embed::driver\u003c spi_settings \u003e\n    Name     settings_t m_settings Mutable settings.   settings_t m_initialized_settings Saved version of the settings at initialization.   bool m_initialized Determines if the driver has been initialized.    Public Functions Documentation function transfer virtual boost::leaf::result\u003c void \u003e transfer( std::span\u003c const std::byte \u003e p_data_out, std::span\u003c std::byte \u003e p_data_in, std::byte p_write_value =std::byte{ 0xFF } ) =0 Send and receieve data between a selected device on the spi bus. This function will block until the entire transfer is finished.\nParameters:\n p_data_out - buffer to write data to the bus. If this is set to null/empty then writing is ignored and the p_write_value will be written to the bus. If the length is less than p_data_in, then p_write_value will be written to the bus after this buffer has been sent. p_data_in - buffer to read the data off of the bus. If this is null/empty, then the transfer will be write only and the incoming data will be ignored. If the length of this buffer is less than p_data_out, once this buffer has been filled, the rest of the received bytes on the bus will be dropped. p_write_value - filler data to be placed on the bus when the p_data_out buffer has been exhausted.  Return: boost::leaf::result- any error that occured during this operation.\n Updated on 2022-01-15 at 19:09:27 +0000\n","description":"","tags":null,"title":"embed::spi","uri":"/libembeddedhal/api/classes/classembed_1_1spi/"},{"content":"embed::spi_settings Struct Reference\nGeneric settings for a standard SPI device.\n#include \u003cspi.hpp\u003e\nPublic Attributes     Name     frequency clock_rate Serial clock frequency.   bool clock_idles_high The polarity of the pins when the signal is idle.   bool data_valid_on_trailing_edge The phase of the clock signal when communicating.    Public Attributes Documentation variable clock_rate frequency clock_rate = default_clock_rate; Serial clock frequency.\nvariable clock_idles_high bool clock_idles_high = false; The polarity of the pins when the signal is idle.\nvariable data_valid_on_trailing_edge bool data_valid_on_trailing_edge = false; The phase of the clock signal when communicating.\n Updated on 2022-01-15 at 19:09:27 +0000\n","description":"","tags":null,"title":"embed::spi_settings","uri":"/libembeddedhal/api/classes/structembed_1_1spi__settings/"},{"content":"embed::static_callable Class Reference\nGeneral class which will be used to allow for signature to be used and then split by the below class. More…\nDetailed Description template \u003cclass owner_class , int reference_designator, typename signature \u003e class embed::static_callable; General class which will be used to allow for signature to be used and then split by the below class.\nTemplate Parameters:\n owner_class class that this static callable belongs to reference_designator this template argument is used to generate unique static objects for each needed callback signature function signature to be split up in the static_callable specialization   Updated on 2022-01-15 at 19:09:27 +0000\n","description":"","tags":null,"title":"embed::static_callable","uri":"/libembeddedhal/api/classes/classembed_1_1static__callable/"},{"content":"embed::static_callable\u003c owner_class, reference_designator, return_t(args_t… p_args)\u003e Class Reference\nSpecialization of static_callable with the return type and arguments split up. More…\n#include \u003cstatic_callable.hpp\u003e\nPublic Functions     Name      static_callable(std::function\u003c return_t(args_t… p_args)\u003e p_callback)Construct a new static callable object.   auto * get_handler()Get the static function’s address.    Detailed Description template \u003cclass owner_class , int reference_designator, typename return_t , typename... args_t\u003e class embed::static_callable\u003c owner_class, reference_designator, return_t(args_t... p_args)\u003e; Specialization of static_callable with the return type and arguments split up.\nTemplate Parameters:\n owner_class see static_callable reference_designator see static_callable return_t function’s return type args_t function’s set of arguments  Public Functions Documentation function static_callable inline static_callable( std::function\u003c return_t(args_t... p_args)\u003e p_callback ) Construct a new static callable object.\nParameters:\n p_callback - when the static callback function is called, it will call this callback  function get_handler inline auto * get_handler() Get the static function’s address.\nReturn: auto* - static function’s address\n Updated on 2022-01-15 at 19:09:27 +0000\n","description":"","tags":null,"title":"embed::static_callable\u003c owner_class, reference_designator, return_t(args_t... p_args)\u003e","uri":"/libembeddedhal/api/classes/classembed_1_1static__callable_3_01owner__class_00_01reference__designator_00_01return__t_07args__t_8_8_8_01p__args_08_4/"},{"content":"embed::static_memory_resource Class Reference\nThe static_memory_resource is the polymorphic memory resource allocator that allows libembeddedhal’s libraries to use a C++ standard container such as std::pmr::vector, std::pmr::string, std::pmr::unordered_map, and more without requiring dynamic memory allocation from the heap. It provides a simple way to create an allocator with built in storage, with its size indicated by a single template parameter. It also provides statistics regarding the amount of memory allocated such that developers can determine if they need to reduce or increase the size of the buffer. Memory statistics can also give programs the insight into how much memory space is available and make decisions based on that. In the event that the memory of the static allocator is exceeded, a std::bad_alloc excpetion is thrown. More…\n#include \u003cstatic_memory_resource.hpp\u003e\nInherits from std::pmr::memory_resource\nPublic Functions     Name      static_memory_resource()   constexpr std::size_t capacity() const   std::size_t memory_used() const   int memory_available() const    Protected Functions     Name     void * do_allocate(std::size_t p_bytes, std::size_t p_alignment) overrideImplemenation of the do_allocate() method for std::pmr::memory_resource.   void do_deallocate(void * p_address, std::size_t p_bytes, std::size_t p_alignment) overrideImplemenation of the do_deallocate() method for std::pmr::memory_resource.   bool do_is_equal(const std::pmr::memory_resource \u0026 p_other) const overrideImplemenation of the do_is_equal() method for std::pmr::memory_resource.    Detailed Description template \u003csize_t BufferSize\u003e class embed::static_memory_resource; The static_memory_resource is the polymorphic memory resource allocator that allows libembeddedhal’s libraries to use a C++ standard container such as std::pmr::vector, std::pmr::string, std::pmr::unordered_map, and more without requiring dynamic memory allocation from the heap. It provides a simple way to create an allocator with built in storage, with its size indicated by a single template parameter. It also provides statistics regarding the amount of memory allocated such that developers can determine if they need to reduce or increase the size of the buffer. Memory statistics can also give programs the insight into how much memory space is available and make decisions based on that. In the event that the memory of the static allocator is exceeded, a std::bad_alloc excpetion is thrown.\nTemplate Parameters:\n BufferSize - number of bytes to statically allocate for the memory resource.  USAGE:\n// Make a memory resource with 1kB buffer static_memory_resource\u003c1024\u003e memory_resource; std::pmr::unordered_map\u003cint, const char*\u003e id_name_map(\u0026memory_resource);\nPublic Functions Documentation function static_memory_resource inline static_memory_resource() function capacity inline constexpr std::size_t capacity() const Return: constexpr std::size_t - the total number of bytes that this allocator can allocate before throwing a std::bad_alloc exception.\nfunction memory_used inline std::size_t memory_used() const Return: std::size_t - number of bytes that have already been allocated.\nfunction memory_available inline int memory_available() const Return: int - Bytes that have yet to be allocated from this allocator.\nProtected Functions Documentation function do_allocate inline void * do_allocate( std::size_t p_bytes, std::size_t p_alignment ) override Implemenation of the do_allocate() method for std::pmr::memory_resource.\nParameters:\n p_bytes - number of bytes to allocate p_alignment - alignment limit for the allocation  Return: void* - address of the newly allocated buffer\nfunction do_deallocate inline void do_deallocate( void * p_address, std::size_t p_bytes, std::size_t p_alignment ) override Implemenation of the do_deallocate() method for std::pmr::memory_resource.\nParameters:\n p_address - address of space to be deallocated p_bytes - number of bytes to allocate p_alignment - alignment limit for the allocation  function do_is_equal inline bool do_is_equal( const std::pmr::memory_resource \u0026 p_other ) const override Implemenation of the do_is_equal() method for std::pmr::memory_resource.\nParameters:\n p_other - another memory resource to  Return:\n true - are equal false - are not equal   Updated on 2022-01-15 at 19:09:27 +0000\n","description":"","tags":null,"title":"embed::static_memory_resource","uri":"/libembeddedhal/api/classes/classembed_1_1static__memory__resource/"},{"content":"embed::this_thread Namespace Reference\nClasses     Name     struct embed::this_thread::global_clocks structure containing internal clock variables and functions    Types     Name     using std::chrono::nanoseconds time_increment smallest increment of time for clocks   using std::function\u003c void(time_increment p_sleep_time)\u003e sleep_function definition of a sleep function   using std::function\u003c time_increment(void)\u003e uptime_function definition of an uptime function    Functions     Name     auto sleep_for(time_increment p_delay)Delay execution of the program by a predefined time.   auto uptime()Get the current system uptime.   void set_global_sleep(sleep_function p_sleep_function)Set the global sleep object.   void set_global_uptime(uptime_function p_uptime_function)Set the global uptime object.    Types Documentation using time_increment using embed::this_thread::time_increment = typedef std::chrono::nanoseconds; smallest increment of time for clocks\nusing sleep_function using embed::this_thread::sleep_function = typedef std::function\u003cvoid(time_increment p_sleep_time)\u003e; definition of a sleep function\nusing uptime_function using embed::this_thread::uptime_function = typedef std::function\u003ctime_increment(void)\u003e; definition of an uptime function\nFunctions Documentation function sleep_for static auto sleep_for( time_increment p_delay ) Delay execution of the program by a predefined time.\nParameters:\n p_delay - the amount of time to delay execution by  function uptime static auto uptime() Get the current system uptime.\nReturn: auto - the global uptime\nfunction set_global_sleep static void set_global_sleep( sleep_function p_sleep_function ) Set the global sleep object.\nParameters:\n p_sleep_function - the function to handle sleeping  function set_global_uptime static void set_global_uptime( uptime_function p_uptime_function ) Set the global uptime object.\nParameters:\n p_uptime_function - the function to return the current system uptime   Updated on 2022-01-15 at 19:09:27 +0000\n","description":"","tags":null,"title":"embed::this_thread","uri":"/libembeddedhal/api/namespaces/namespaceembed_1_1this__thread/"},{"content":"embed::this_thread::global_clocks Struct Reference\nstructure containing internal clock variables and functions\n#include \u003ctime.hpp\u003e\nPublic Functions     Name     time_increment incremental_uptime()Default uptime timer that simply counts each time it is called. This should almost never be used.   void loop_sleep(time_increment p_loop_count)Default sleep function that simply counts until it reaches a designated number.    Public Attributes     Name     sleep_function m_global_sleep Store the global sleep function.   uptime_function m_global_uptime Store the global uptime function.    Public Functions Documentation function incremental_uptime static inline time_increment incremental_uptime() Default uptime timer that simply counts each time it is called. This should almost never be used.\nReturn: time_increment - fake uptime\nfunction loop_sleep static inline void loop_sleep( time_increment p_loop_count ) Default sleep function that simply counts until it reaches a designated number.\nParameters:\n p_loop_count - number of iterations to loop for to mimick sleeping  Public Attributes Documentation variable m_global_sleep static sleep_function m_global_sleep = loop_sleep; Store the global sleep function.\nvariable m_global_uptime static uptime_function m_global_uptime = incremental_uptime; Store the global uptime function.\n Updated on 2022-01-15 at 19:09:27 +0000\n","description":"","tags":null,"title":"embed::this_thread::global_clocks","uri":"/libembeddedhal/api/classes/structembed_1_1this__thread_1_1global__clocks/"},{"content":"embed::timer Class Reference\nTimer hardware abstraction interface. More…\n#include \u003ctimer.hpp\u003e\nInherits from embed::driver\u003c\u003e\nPublic Classes     Name     struct delay_too_large Error type indicating that the desired delay time is above what can be achieved by the timer.   struct delay_too_small Error type indicating that the desired time delay is not achievable with this timer.    Public Functions     Name     virtual boost::leaf::result\u003c bool \u003e is_running() =0Determine if the timer is currently running.   virtual boost::leaf::result\u003c void \u003e clear() =0Stops a scheduled event from happening.   virtual boost::leaf::result\u003c void \u003e schedule(std::function\u003c void(void)\u003e p_callback, std::chrono::nanoseconds p_delay) =0Schedule an callback to be called at a designated time/interval.    Additional inherited members Public Functions inherited from embed::driver\u003c\u003e\n    Name     boost::leaf::result\u003c void \u003e initialize()Initialize the driver, apply the setting as defined in the settings_t structure and enable it. Calling this function after it has already been initialized will return false. In order to run initialization again, reset() must be called. After initialization, the settings are committed and saved into another settings structure. This settings can be looked up and inspected by the application.   void reset()Reset the driver in order to run initialize again. This is helpful if the application needs to change the settings of a driver after it is first initialized, like baud rate for serial or pull resistor for a pin.   bool is_initialized() constDetermine if the driver has been initialized.   settings_t \u0026 settings()Get access to uncommitted driver settings.   const settings_t \u0026 initialized_settings() constGet access to the settings that were used in the latest initialization. These settings only get updated when a successful initialize() has occurred.    Protected Functions inherited from embed::driver\u003c\u003e\n    Name     virtual boost::leaf::result\u003c void \u003e driver_initialize() =0Implementation of driver initialize by the inherited driver.    Protected Attributes inherited from embed::driver\u003c\u003e\n    Name     settings_t m_settings Mutable settings.   settings_t m_initialized_settings Saved version of the settings at initialization.   bool m_initialized Determines if the driver has been initialized.    Detailed Description class embed::timer; Timer hardware abstraction interface.\nUse this interface for devices and peripherals that have timer like capabilities, such that, when a timer’s time has expired, an event/interrupt/signal is generated.\nPublic Functions Documentation function is_running virtual boost::leaf::result\u003c bool \u003e is_running() =0 Determine if the timer is currently running.\nReturn:\n boost::leaf::result- true if timer is currently running boost::leaf::result- driver specific error, if any.  function clear virtual boost::leaf::result\u003c void \u003e clear() =0 Stops a scheduled event from happening.\nReturn: boost::leaf::result- driver specific error, if any.\nDoes nothing if the timer is not currently running.\nNote that there must be sufficient time between the this call finishing and the scheduled event’s termination. If this call is too close to when the schedule event expires, this function may not complete before the hardware calls the callback.\nfunction schedule virtual boost::leaf::result\u003c void \u003e schedule( std::function\u003c void(void)\u003e p_callback, std::chrono::nanoseconds p_delay ) =0 Schedule an callback to be called at a designated time/interval.\nParameters:\n p_callback - callback function to be called when the timer expires p_delay - the amount of time before the timer expires  Return: boost::leaf::result- returns [delay_too_small](classes/structembed_1_1timer_1_1delay__too__small/) or [delay_too_large](classes/structembed_1_1timer_1_1delay__too__large/) if p_interval cannot be reached.\nIf this is called and the timer has already scheduled an event (in other words, is_running() returns true), then the previous scheduled event will be cleared and the new scheduled event will be started.\n Updated on 2022-01-15 at 19:09:27 +0000\n","description":"","tags":null,"title":"embed::timer","uri":"/libembeddedhal/api/classes/classembed_1_1timer/"},{"content":"embed::timer::delay_too_large Struct Reference\nError type indicating that the desired delay time is above what can be achieved by the timer. More…\n#include \u003ctimer.hpp\u003e\nPublic Attributes     Name     std::chrono::nanoseconds invalid The invalid delay given to the schedule function.   std::chrono::nanoseconds maximum The maximum possible delay allowed.    Detailed Description struct embed::timer::delay_too_large; Error type indicating that the desired delay time is above what can be achieved by the timer.\nUsually occurs when the driving frequency, prescalar values and the size of the timer registers are too small for the delay for a particular timer.\nHow to handle these errors:\n Usually this is a bug in the program. One way to resolve this in the application is to drive down the input frequency to the timer in order to make each count longer.  Public Attributes Documentation variable invalid std::chrono::nanoseconds invalid; The invalid delay given to the schedule function.\nvariable maximum std::chrono::nanoseconds maximum; The maximum possible delay allowed.\n Updated on 2022-01-15 at 19:09:27 +0000\n","description":"","tags":null,"title":"embed::timer::delay_too_large","uri":"/libembeddedhal/api/classes/structembed_1_1timer_1_1delay__too__large/"},{"content":"embed::timer::delay_too_small Struct Reference\nError type indicating that the desired time delay is not achievable with this timer. More…\n#include \u003ctimer.hpp\u003e\nPublic Attributes     Name     std::chrono::nanoseconds invalid The invalid delay given to the schedule function.   std::chrono::nanoseconds minimum The minimum possible delay allowed.    Detailed Description struct embed::timer::delay_too_small; Error type indicating that the desired time delay is not achievable with this timer.\nUsually this occurs if the time delay is too small relative to the driving frequency of the timer and along with any prescalars before the counting register.\nHow to handle these errors:\n In cases where the program is scanning for the fastest delay, this is to be expected. The error will report the minimum possible delay which can then be assigned. Same for the maximum possible delay. In most other cases, this is usually a bug in the code and cannot be handled in code and should be treated as such. Drivers using a timer, if they need an exact nunber will not be usable with this timer if it throws this error, which will either require another timer that can perform this work be used or increasing the clock rate fed into the timer in order to increase its frequency range.  Public Attributes Documentation variable invalid std::chrono::nanoseconds invalid; The invalid delay given to the schedule function.\nvariable minimum std::chrono::nanoseconds minimum; The minimum possible delay allowed.\n Updated on 2022-01-15 at 19:09:27 +0000\n","description":"","tags":null,"title":"embed::timer::delay_too_small","uri":"/libembeddedhal/api/classes/structembed_1_1timer_1_1delay__too__small/"},{"content":" Updated on 2022-01-15 at 19:09:27 +0000\n","description":"","tags":null,"title":"Modules","uri":"/libembeddedhal/api/modules/"},{"content":" namespace embed  namespace config  namespace defaults   namespace error namespace literals namespace this_thread     Updated on 2022-01-15 at 19:09:27 +0000\n","description":"","tags":null,"title":"Namespaces","uri":"/libembeddedhal/api/namespaces/"},{"content":" Updated on 2022-01-15 at 19:09:27 +0000\n","description":"","tags":null,"title":"Pages","uri":"/libembeddedhal/api/pages/"},{"content":"","description":"","tags":null,"title":"Tags","uri":"/libembeddedhal/tags/"},{"content":"Welcome! TBD\n","description":"","tags":null,"title":"Welcome","uri":"/libembeddedhal/"}]