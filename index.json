[{"content":"TBD\n","description":"","tags":null,"title":"Getting Started","uri":"/libembeddedhal/installation/getting_started/"},{"content":"Quick Start TBD\n","description":"","tags":null,"title":"Installation","uri":"/libembeddedhal/installation/"},{"content":"TBD\n","description":"","tags":null,"title":"Flashing","uri":"/libembeddedhal/installation/flashing/"},{"content":"Guides TBD\n","description":"","tags":null,"title":"Guides","uri":"/libembeddedhal/guides/"},{"content":"API The following chapter contains detailed API documentation for every class and function in the code base. These descriptions include, but are not limited to, descriptions of the available classes, their method, what parameters those methods take, and a description of those parameters and how to use them. These sort of descriptions are also available for functions, type definitions, structures and inline defined variables within header files.\nClasses The classes section contains every single documented class in the project. This area can be quite large and hard to navigate unless you know exactly what you are looking for. If you are not sure exactly what you are looking for but know what catagory of library you are looking for, use the modules section.\nModules Modules chapter categorizes drivers in like groups which makes navigation easier.\n","description":"","tags":null,"title":"API","uri":"/libembeddedhal/api/"},{"content":"TBD\n","description":"","tags":null,"title":"Debugging","uri":"/libembeddedhal/installation/jtag/"},{"content":"TBD\n","description":"","tags":null,"title":"Exploring the Ecosystem","uri":"/libembeddedhal/installation/exploring_the_ecosystem/"},{"content":"TBD\n","description":"","tags":null,"title":"Creating a Device Driver","uri":"/libembeddedhal/expanding/creating_device/"},{"content":"TBD\n","description":"","tags":null,"title":"Creating a Project","uri":"/libembeddedhal/guides/new_project/"},{"content":"Design Documentation This section goes into detail on the design choices of each aspect of each part of the libembeddedhal library. This section will go into why things are the way they are. If you are looking to just know how to use aspects of libembeddedhal please see the “guides” and “api” chapters.\nThis section is meant to explain to users of libembeddedhal why certain design choices were made, what the alternatives options were, what are the pros and cons of a system and why the pros outweigh the cons. If you disagree with these design choices, feel free to add an issue to the official repo.\n","description":"","tags":null,"title":"Design","uri":"/libembeddedhal/design/"},{"content":"TBD\n","description":"","tags":null,"title":"Driver Interface Design","uri":"/libembeddedhal/design/driver_design/"},{"content":"Expanding the Ecosystem TBD\n","description":"","tags":null,"title":"Expanding the Ecosystem","uri":"/libembeddedhal/expanding/"},{"content":"Contributing to libembeddedhal Code of conduct Please read the CODE_OF_CONDUCT.md file before contributing.\nStyle Guide  ","description":"","tags":null,"title":"Contributing","uri":"/libembeddedhal/contribution/"},{"content":"TBD\n","description":"","tags":null,"title":"Creating a Platform","uri":"/libembeddedhal/expanding/creating_platform/"},{"content":"TBD\n","description":"","tags":null,"title":"Error Handling Design","uri":"/libembeddedhal/design/error_handling_design/"},{"content":"TBD\n","description":"","tags":null,"title":"How to Use Drivers","uri":"/libembeddedhal/guides/driver_usage/"},{"content":"TBD\n","description":"","tags":null,"title":"Creating a Utility Library","uri":"/libembeddedhal/expanding/creating_utilities/"},{"content":"TBD\n","description":"","tags":null,"title":"Driver Wrappers Design","uri":"/libembeddedhal/design/driver_wrappers/"},{"content":"TBD\n","description":"","tags":null,"title":"Error Handling","uri":"/libembeddedhal/guides/error_handling/"},{"content":"TBD\n","description":"","tags":null,"title":"Multiplatform Applications","uri":"/libembeddedhal/guides/multiplatform_apps/"},{"content":"TBD\n","description":"","tags":null,"title":"Unit Testing","uri":"/libembeddedhal/guides/unit_testing/"},{"content":"TBD\n","description":"","tags":null,"title":"Handwritten Driver Mocks","uri":"/libembeddedhal/design/handmade_mocks/"},{"content":"Runtime Cost  https://blog.segger.com/wp-content/uploads/2019/11/Bench_Comparison.pdf https://blog.segger.com/floating-point-face-off-part-2-comparing-performance/  Space Cost Each was tested with the following operators (+, -, *, /, \u003c, \u003e, ==, \u003c=, \u003e=):\n32-bit integer conversion only:  Floats: 1392 bytes Doubles: 1968 bytes  64-bit integer conversion only:  Floats: 3088 bytes Doubles: 2128 bytes  Both 32-bit \u0026 64-bit conversion:  Doubles + Floats: 3072 bytes Doubles + Floats: 3592 bytes  Problems with Floats  Infinties \u0026 NaN Lose of precision Conversion to integer types Floating-point environment  https://en.cppreference.com/w/cpp/numeric/fenv Requires TLS which is disabled for stock arm-none-eabi-gcc    ","description":"","tags":null,"title":"Using Floats","uri":"/libembeddedhal/guides/using_floats/"},{"content":"","description":"","tags":null,"title":"Categories","uri":"/libembeddedhal/categories/"},{"content":" namespace embed  class accelerometer Accelerometer hardware abstraction interface.  struct sample Representation of a sample of accelerometer data.  struct axis_t     class adc Analog to Digital Converter (ADC) hardware abstraction interface. struct bit_limits Similar to std::numeric_limitsexcept that this object can give properties of integral types of arbitrary bit widths. class can Controller Area Network (CAN bus) hardware abstraction interface.  struct message_t Structure of a CAN message. struct settings Generic settings for a can peripheral.   class can_network Manage, store, and organize messages received on the can bus.  class node_t A can network node stores the can messages in a lock free way.   namespace config  namespace defaults   class counter Counter hardware abstraction interface. Use this interface for devices and peripherals that have counting capabilities. Such devices can count up or down. Useful for keeping time. Expect counters to overflow when they reach the end of counting register’s limits.  struct uptime_t Representation of a counter’s uptime.   class dac Digital to Analog Converter (DAC) hardware abstraction interface. struct duty_cycle Structure containing cycle count for the high and low side of a signal duty cycle. namespace error  struct invalid_option_t Used for defining static_asserts that should always fail, but only if the static_assert line is hit via if constexpr control block. Prefer to NOT use this directly but to use invalid_option instead. struct invalid_settings Error type indicating that the settings for serial uart could not be set. class stacktrace A structure to hold stack strace source location entries. The size of this class can be changed by changing the embed::config::stacktrace_depth_limit value in the libembeddedhal.tweak.hpp file for your project. This can be used to reduce the stack size of functions that have Boost.LEAF handlers that inspect a embed::error::stacktrace. struct timeout An error indicating a timeout event. struct universal An association error type for all libembeddedhal drivers that inherit from this class. It is used to disambiguate errors coming from a libembeddedhal embed::driver vs those coming from other libraries.   class frequency Represents the frequency of a signal. It consists of a single integer 64-bit number that presents the integer representation of a signal frequency. class i2c Inter-integrated Circuit (I2C) or Two Wire Interface (TWI) communication protocol hardware abstract interface.  struct settings Generic settings for a standard I2C device.   class input_pin Digital input pin hardware abstraction.  struct settings Generic settings for input pins.   class interrupt_pin Digital interrupt pin hardware abstraction.  struct settings Generic settings for interrupt pins.   namespace literals struct microkelvin struct micrometre_per_second_sq struct millikelvin struct millimetre_per_second_sq namespace mock  struct dac Mock dac implementation for use in unit tests and simulations with a spy function for write() struct motor Mock motor implementation for use in unit tests and simulations with a spy function for power() struct pwm Mock pwm implementation for use in unit tests and simulations with spy functions for configure() and duty_cycle(). struct timer Mock timer implementation for use in unit tests and simulations with spy functions for schedule(), clear(), and is_running() struct write_only_spi Mock spi implementation for use in unit tests and simulations with a spy functions for configure() and a record for the transfer() out data. The record ignores the in buffer and just stores the data being sent so it can be inspected later.   class motor Hardware abstraction for open loop continuous rotary and linear actuators. struct nanokelvin struct nanometre_per_second_sq class output_pin Digital output pin hardware abstraction.  struct settings Generic settings for output pins.   class overflow_counter Extend a counter’s count from an arbitrary bit width to 64-bits by detecting overflows in the count. Each detected overflow is added to an overflow counter which is combined with the current count in order create a count up to 64-bits in length. class percent A integer representation of a percentage. class pwm Pulse Width Modulation (PWM) channel hardware abstraction.  struct settings   class serial Serial communication protocol hardware abstract interface.  struct frame_error Error type indicating that a frame error occurred during reception. This error is returned when calling bytes_available(). struct packets_lost Error indicating that packets were lost during reception. This occurs when the buffer is overrun and reaches the end of the circular buffer. This error is returned when calling bytes_available(). struct parity_error Error type indicating that a parity error occurred during reception. This error is returned when calling bytes_available(). struct settings Generic settings for a standard serial device.   class spi Serial peripheral interface (SPI) communication protocol hardware abstract interface.  struct settings Generic settings for a standard SPI device.   class spy_handler Helper utility for making mocks for class functions that return boost::leaf::result. class static_callable General class which will be used to allow for signature to be used and then split by the below class. class static_callable\u003c owner_class, reference_designator, return_t(args_t… p_args)\u003e Specialization of static_callable with the return type and arguments split up. class static_memory_resource The static_memory_resource is the polymorphic memory resource allocator that allows libembeddedhal’s libraries to use a C++ standard container such as std::pmr::vector, std::pmr::string, std::pmr::unordered_map, and more without requiring dynamic memory allocation from the heap. It provides a simple way to create an allocator with built in storage, with its size indicated by a single template parameter. It also provides statistics regarding the amount of memory allocated such that developers can determine if they need to reduce or increase the size of the buffer. Memory statistics can also give programs the insight into how much memory space is available and make decisions based on that. In the event that the memory of the static allocator is exceeded, a std::bad_alloc excpetion is thrown. namespace stub  class adc A stub implementation of embed::adc to be used as a placeholder for drivers that require an optional adc. Calling read() will return the percent variable that is configured in the constructor. This implementaion should only be used when a driver has stated in its documentation that the adc is optional and can be stubbed out. class dac A stub implementation of embed::dac to be used as a placeholder for drivers that require an optional dac. This implementation should only be used when a driver has stated in its documentation that the dac is optional and can be stubbed out. class serial class spi A stub implementation of embed::spi to be used as a placeholder for drivers that require an optional spi interface. This implementation should only be used when a driver has stated in its documentation that the spi interface is optional and can be stubbed out. class timer A stub implementation of embed::timer to be used as a placeholder for drivers that require an optional timer. Calling clear() will make is_running() return false, calling schedule() will make is_running() return true.   class temperature_sensor Hardware abstraction interface for temperature sensing devices. namespace this_thread  struct global_clocks structure containing internal clock variables and functions   class timer Timer hardware abstraction interface.  struct out_of_bounds Error type indicating that the desired time delay is not achievable with this timer.   class uptime_counter uptime counter takes a hardware counter and calculates the uptime in nanoseconds.   namespace units   Updated on 2022-05-15 at 12:08:46 +0000\n","description":"","tags":null,"title":"Classes","uri":"/libembeddedhal/api/classes/"},{"content":"embed Namespace Reference\nNamespaces    Name     embed::config   embed::error   embed::literals   embed::mock   embed::stub   embed::this_thread    Classes     Name     class embed::accelerometer Accelerometer hardware abstraction interface.   class embed::adc Analog to Digital Converter (ADC) hardware abstraction interface.   struct embed::bit_limits Similar to std::numeric_limitsexcept that this object can give properties of integral types of arbitrary bit widths.   class embed::can Controller Area Network (CAN bus) hardware abstraction interface.   class embed::can_network Manage, store, and organize messages received on the can bus.   class embed::counter Counter hardware abstraction interface. Use this interface for devices and peripherals that have counting capabilities. Such devices can count up or down. Useful for keeping time. Expect counters to overflow when they reach the end of counting register’s limits.   class embed::dac Digital to Analog Converter (DAC) hardware abstraction interface.   struct embed::duty_cycle Structure containing cycle count for the high and low side of a signal duty cycle.   class embed::frequency Represents the frequency of a signal. It consists of a single integer 64-bit number that presents the integer representation of a signal frequency.   class embed::i2c Inter-integrated Circuit (I2C) or Two Wire Interface (TWI) communication protocol hardware abstract interface.   class embed::input_pin Digital input pin hardware abstraction.   class embed::interrupt_pin Digital interrupt pin hardware abstraction.   struct embed::microkelvin   struct embed::micrometre_per_second_sq   struct embed::millikelvin   struct embed::millimetre_per_second_sq   class embed::motor Hardware abstraction for open loop continuous rotary and linear actuators.   struct embed::nanokelvin   struct embed::nanometre_per_second_sq   class embed::output_pin Digital output pin hardware abstraction.   class embed::overflow_counter Extend a counter’s count from an arbitrary bit width to 64-bits by detecting overflows in the count. Each detected overflow is added to an overflow counter which is combined with the current count in order create a count up to 64-bits in length.   class embed::percent A integer representation of a percentage.   class embed::pwm Pulse Width Modulation (PWM) channel hardware abstraction.   class embed::serial Serial communication protocol hardware abstract interface.   class embed::spi Serial peripheral interface (SPI) communication protocol hardware abstract interface.   class embed::spy_handler Helper utility for making mocks for class functions that return boost::leaf::result.   class embed::static_callable General class which will be used to allow for signature to be used and then split by the below class.   class embed::static_callable\u003c owner_class, reference_designator, return_t(args_t… p_args)\u003e Specialization of static_callable with the return type and arguments split up.   class embed::static_memory_resource The static_memory_resource is the polymorphic memory resource allocator that allows libembeddedhal’s libraries to use a C++ standard container such as std::pmr::vector, std::pmr::string, std::pmr::unordered_map, and more without requiring dynamic memory allocation from the heap. It provides a simple way to create an allocator with built in storage, with its size indicated by a single template parameter. It also provides statistics regarding the amount of memory allocated such that developers can determine if they need to reduce or increase the size of the buffer. Memory statistics can also give programs the insight into how much memory space is available and make decisions based on that. In the event that the memory of the static allocator is exceeded, a std::bad_alloc excpetion is thrown.   class embed::temperature_sensor Hardware abstraction interface for temperature sensing devices.   class embed::timer Timer hardware abstraction interface.   class embed::uptime_counter uptime counter takes a hardware counter and calculates the uptime in nanoseconds.    Types     Name     enum class pin_resistor { none = 0, pull_down, pull_up}Set of possible pin mode resistor settings.   template \u003cunits::Representation Rep =std::int64_t\u003e using units::isq::si::acceleration\u003c embed::nanometre_per_second_sq, Rep \u003e nm_per_s2   template \u003cunits::Representation Rep =std::int64_t\u003e using units::isq::si::acceleration\u003c embed::micrometre_per_second_sq, Rep \u003e um_per_s2   template \u003cunits::Representation Rep =std::int64_t\u003e using units::isq::si::acceleration\u003c embed::millimetre_per_second_sq, Rep \u003e mm_per_s2   using nm_per_s2\u003c std::int64_t \u003e acceleration Universal unit for acceleration.   template \u003cunits::Representation Rep =std::int64_t\u003e using units::isq::si::thermodynamic_temperature\u003c nanokelvin, Rep \u003e nK   template \u003cunits::Representation Rep =std::int64_t\u003e using units::isq::si::thermodynamic_temperature\u003c microkelvin, Rep \u003e uK   template \u003cunits::Representation Rep =std::int64_t\u003e using units::isq::si::thermodynamic_temperature\u003c millikelvin, Rep \u003e mK   using nK\u003c std::int64_t \u003e temperature Universal unit for temperature.    Functions     Name     template \u003csize_t BitWidth,std::integral T\u003e consteval T generate_field_of_ones()Generate a mask of 1s at compiletime.   constexpr bool is_platform(std::string_view p_platform)Determines if the current application was built for a specific platform. For example:   constexpr bool is_a_test()Determines if the application is a test.   boost::leaf::result\u003c void \u003e wait_for(counter \u0026 p_counter, std::chrono::nanoseconds p_wait_duration)pause execution for this duration of time using a hardware counter object.   void set_as_global_sleep(counter \u0026 p_counter)Use this counter as the global sleep function.   void set_as_global_uptime(uptime_counter \u0026 p_counter)Use this counter as the global sleep function.   constexpr auto value(enumeration auto p_enum_value)Helper function to convert an enum to its integral value.   boost::leaf::result\u003c void \u003e write(i2c \u0026 p_i2c, std::byte p_address, std::span\u003c const std::byte \u003e p_data_out)write data to a target device on the i2c bus   boost::leaf::result\u003c void \u003e read(i2c \u0026 p_i2c, std::byte p_address, std::span\u003c std::byte \u003e p_data_in)read bytes from target device on i2c bus   template \u003csize_t BytesToRead\u003e boost::leaf::result\u003c std::array\u003c std::byte, BytesToRead \u003e \u003e read(i2c \u0026 p_i2c, std::byte p_address)return array of read bytes from target device on i2c bus   boost::leaf::result\u003c void \u003e write_then_read(i2c \u0026 p_i2c, std::byte p_address, std::span\u003c const std::byte \u003e p_data_out, std::span\u003c std::byte \u003e p_data_in)write and then read bytes from target device on i2c bus   template \u003csize_t BytesToRead\u003e boost::leaf::result\u003c std::array\u003c std::byte, BytesToRead \u003e \u003e write_then_read(i2c \u0026 p_i2c, std::byte p_address, std::span\u003c const std::byte \u003e p_data_out)write and then return an array of read bytes from target device on i2c bus   template \u003ctypename T \u003e boost::leaf::result\u003c T \u003e multiply_with_overflow_detection(T p_lhs, T p_rhs)Perform multiply operation and return an error code std::errc::result_out_of_range if the two values when multiplied would overflow the containing value.   template \u003ctypename T \u003e constexpr T absolute_value(T p_value)Generic absolute value function that works for integer types. This is preferred over the C API for rounding numbers such as abs(), labs() and llabs(). This function relieves the need in template code to check the type of the integer and select the correct function to call.   template \u003ctypename T \u003e constexpr T rounding_division(T p_numerator, T p_denominator)Perform integer division and round the value up if the next decimal place is greater than or equal to 0.5.   template \u003cstd::integral T,size_t SourceWidth,std::integral U\u003e constexpr T upscale_integer(U p_value)Upscale an integer value of arbitrary bit resolution to a new fixed with integer value.   boost::leaf::result\u003c void \u003e wait(serial \u0026 p_serial, size_t p_length, std::optional\u003c std::chrono::nanoseconds \u003e p_timeout =std::nullopt)   boost::leaf::result\u003c void \u003e write(serial \u0026 p_serial, std::span\u003c const std::byte \u003e p_data_out)   boost::leaf::result\u003c std::span\u003c const std::byte \u003e \u003e read(serial \u0026 p_serial, std::span\u003c std::byte \u003e p_data_in, std::optional\u003c std::chrono::nanoseconds \u003e p_timeout =std::nullopt)   template \u003csize_t BytesToRead\u003e boost::leaf::result\u003c std::array\u003c std::byte, BytesToRead \u003e \u003e read(serial \u0026 p_serial, std::optional\u003c std::chrono::nanoseconds \u003e p_timeout =std::nullopt)   boost::leaf::result\u003c void \u003e write_then_read(serial \u0026 p_serial, std::span\u003c const std::byte \u003e p_data_out, std::span\u003c std::byte \u003e p_data_in, std::optional\u003c std::chrono::nanoseconds \u003e p_timeout =std::nullopt)   template \u003csize_t BytesToRead\u003e boost::leaf::result\u003c std::array\u003c std::byte, BytesToRead \u003e \u003e write_then_read(serial \u0026 p_serial, std::span\u003c const std::byte \u003e p_data_out, std::optional\u003c std::chrono::nanoseconds \u003e p_timeout =std::nullopt)   boost::leaf::result\u003c void \u003e write(spi \u0026 p_spi, std::span\u003c const std::byte \u003e p_data_out)Write data to the SPI bus and ignore data sent from peripherals on the bus.   boost::leaf::result\u003c void \u003e read(spi \u0026 p_spi, std::span\u003c std::byte \u003e p_data_in, std::byte p_filler =spi::default_filler)Read data from the SPI bus.   template \u003csize_t BytesToRead\u003e boost::leaf::result\u003c std::array\u003c std::byte, BytesToRead \u003e \u003e read(spi \u0026 p_spi, std::byte p_filler =spi::default_filler)Read data from the SPI bus and return a std::array of bytes.   boost::leaf::result\u003c void \u003e write_then_read(spi \u0026 p_spi, std::span\u003c const std::byte \u003e p_data_out, std::span\u003c std::byte \u003e p_data_in, std::byte p_filler =spi::default_filler)Write data to the SPI bus and ignore data sent from peripherals on the bus then read data from the SPI and fill the write line with filler bytes.   template \u003csize_t BytesToRead\u003e boost::leaf::result\u003c std::array\u003c std::byte, BytesToRead \u003e \u003e write_then_read(spi \u0026 p_spi, std::span\u003c const std::byte \u003e p_data_out, std::byte p_filler =spi::default_filler)Write data to the SPI bus and ignore data sent from peripherals on the bus then read data from the SPI, fill the write line with filler bytes and return an array of bytes.   template \u003csize_t N\u003e constexpr std::array\u003c char, N+1 \u003e to_array(std::string_view p_view)Convert a string_view into a std::array of N number of characters.    Attributes     Name     constexpr frequency default_clock_rate Default clock rate for serial communication protocols.    Types Documentation enum pin_resistor    Enumerator Value Description     none 0 No pull up. This will cause the pin to float. This may be desirable if the pin has an external resistor attached or if the signal is sensitive to external devices like resistors.   pull_down  Pull the pin down to devices GND. This will ensure that the voltage read by the pin when there is no signal on the pin is LOW (or false).   pull_up  See pull down explanation, but in this case the pin is pulled up to VCC, also called VDD on some systems.    Set of possible pin mode resistor settings.\nSee each enumeration to get more details about when and how these should be used.\nusing nm_per_s2 template \u003cunits::Representation Rep =std::int64_t\u003e using embed::nm_per_s2 = typedef units::isq::si::acceleration\u003cembed::nanometre_per_second_sq, Rep\u003e; using um_per_s2 template \u003cunits::Representation Rep =std::int64_t\u003e using embed::um_per_s2 = typedef units::isq::si::acceleration\u003cembed::micrometre_per_second_sq, Rep\u003e; using mm_per_s2 template \u003cunits::Representation Rep =std::int64_t\u003e using embed::mm_per_s2 = typedef units::isq::si::acceleration\u003cembed::millimetre_per_second_sq, Rep\u003e; using acceleration using embed::acceleration = typedef nm_per_s2\u003cstd::int64_t\u003e; Universal unit for acceleration.\nusing nK template \u003cunits::Representation Rep =std::int64_t\u003e using embed::nK = typedef units::isq::si::thermodynamic_temperature\u003cnanokelvin, Rep\u003e; using uK template \u003cunits::Representation Rep =std::int64_t\u003e using embed::uK = typedef units::isq::si::thermodynamic_temperature\u003cmicrokelvin, Rep\u003e; using mK template \u003cunits::Representation Rep =std::int64_t\u003e using embed::mK = typedef units::isq::si::thermodynamic_temperature\u003cmillikelvin, Rep\u003e; using temperature using embed::temperature = typedef nK\u003cstd::int64_t\u003e; Universal unit for temperature.\nFunctions Documentation function generate_field_of_ones template \u003csize_t BitWidth, std::integral T\u003e consteval T generate_field_of_ones() Generate a mask of 1s at compiletime.\nTemplate Parameters:\n BitWidth - number of 1s in the mask T - the type  Return: consteval uint32_t - mask with 1s at the LSB\nfunction is_platform constexpr bool is_platform(  std::string_view p_platform ) Determines if the current application was built for a specific platform. For example:\nParameters:\n p_platform - platform string pattern to check against  Return:\n true - matches the platform string false - does not matches the platform string  embed::is_platform(“lpc4078”);\nWill return true if the PLATFORM macro defined at compile time was equal to lpc4078. If the developer wants to be less specific, let say, to just determine if the platform is in the lpc40xx family then the following example will work.\nembed::is_platform(“lpc40”);\nfunction is_a_test constexpr bool is_a_test() Determines if the application is a test.\nReturn:\n true - this application is a test false - this application is not a test  function wait_for inline boost::leaf::result\u003c void \u003e wait_for(  counter \u0026 p_counter,  std::chrono::nanoseconds p_wait_duration ) pause execution for this duration of time using a hardware counter object.\nParameters:\n p_counter - hardware counter driver p_wait_duration - the amount of time to pause execution for  function set_as_global_sleep inline void set_as_global_sleep(  counter \u0026 p_counter ) Use this counter as the global sleep function.\nParameters:\n p_counter - hardware counter driver  The counter must be infailable meaning that frequency() and uptime() must never return an error, otherwise the program will abort.\nfunction set_as_global_uptime inline void set_as_global_uptime(  uptime_counter \u0026 p_counter ) Use this counter as the global sleep function.\nParameters:\n p_counter - hardware counter driver  The counter must be infailable meaning that frequency() and uptime() must never return an error, otherwise the program will abort.\nfunction value constexpr auto value(  enumeration auto p_enum_value ) Helper function to convert an enum to its integral value.\nParameters:\n p_enum_value - the enumeration you want to convert into an integral value  Return: constexpr auto - return the integral value of the enum with the same type as the enumeration.\nfunction write inline boost::leaf::result\u003c void \u003e write(  i2c \u0026 p_i2c,  std::byte p_address,  std::span\u003c const std::byte \u003e p_data_out ) write data to a target device on the i2c bus\nParameters:\n p_i2c - i2c driver p_address - target address p_data_out - buffer of bytes to write to the target device  Return: boost::leaf::result- any errors associated with the read call\nShorthand for writing i2c.transfer(…) for write only operations\nfunction read inline boost::leaf::result\u003c void \u003e read(  i2c \u0026 p_i2c,  std::byte p_address,  std::span\u003c std::byte \u003e p_data_in ) read bytes from target device on i2c bus\nParameters:\n p_i2c - i2c driver p_address - target address p_data_in - buffer to read bytes into from target device  Return: boost::leaf::result- any errors associated with the read call\nShorthand for writing i2c.transfer(…) for read only operations\nfunction read template \u003csize_t BytesToRead\u003e boost::leaf::result\u003c std::array\u003c std::byte, BytesToRead \u003e \u003e read(  i2c \u0026 p_i2c,  std::byte p_address ) return array of read bytes from target device on i2c bus\nParameters:\n p_i2c - i2c driver p_address - target address  Template Parameters:\n BytesToRead - number of bytes to read  Return: boost::leaf::result\u003cstd::array\u003cstd::byte, BytesToRead» - array of bytes from target device or an error.\nEliminates the need to create a buffer and pass it into the read function.\nfunction write_then_read inline boost::leaf::result\u003c void \u003e write_then_read(  i2c \u0026 p_i2c,  std::byte p_address,  std::span\u003c const std::byte \u003e p_data_out,  std::span\u003c std::byte \u003e p_data_in ) write and then read bytes from target device on i2c bus\nParameters:\n p_i2c - i2c driver p_address - target address p_data_out - buffer of bytes to write to the target device p_data_in - buffer to read bytes into from target device  Return: boost::leaf::result- any errors associated with the read call\nThis API simply calls transaction. This API is here for consistency across the other other communication protocols such as SPI and serial.\nfunction write_then_read template \u003csize_t BytesToRead\u003e boost::leaf::result\u003c std::array\u003c std::byte, BytesToRead \u003e \u003e write_then_read(  i2c \u0026 p_i2c,  std::byte p_address,  std::span\u003c const std::byte \u003e p_data_out ) write and then return an array of read bytes from target device on i2c bus\nParameters:\n p_i2c - i2c driver p_address - target address p_data_out - buffer of bytes to write to the target device  Template Parameters:\n BytesToRead - number of bytes to read after write  Return: boost::leaf::result\u003cstd::array\u003cstd::byte, BytesToRead»\nEliminates the need to create a buffer and pass it into the read function.\nfunction multiply_with_overflow_detection template \u003ctypename T \u003e boost::leaf::result\u003c T \u003e multiply_with_overflow_detection(  T p_lhs,  T p_rhs ) Perform multiply operation and return an error code std::errc::result_out_of_range if the two values when multiplied would overflow the containing value.\nParameters:\n p_lhs - left hand side integer p_rhs - right hand side integer  Template Parameters:\n T - integer arithmetic type  Return: boost::leaf::result- either the resultant or an error std::errc::result_out_of_range\nfunction absolute_value template \u003ctypename T \u003e constexpr T absolute_value(  T p_value ) Generic absolute value function that works for integer types. This is preferred over the C API for rounding numbers such as abs(), labs() and llabs(). This function relieves the need in template code to check the type of the integer and select the correct function to call.\nParameters:\n p_value - integer value to be made positive  Return: constexpr auto - positive representation of the integer\nfunction rounding_division template \u003ctypename T \u003e constexpr T rounding_division(  T p_numerator,  T p_denominator ) Perform integer division and round the value up if the next decimal place is greater than or equal to 0.5.\nParameters:\n p_numerator - the value to be divided p_denominator - the value to divide the numerator against  Template Parameters:\n T - integral type of the two operands  Return: constexpr T - rounded quotent between numerator and denominator. Returns 0 if the denominator is greater than the numerator.\nfunction upscale_integer template \u003cstd::integral T, size_t SourceWidth, std::integral U\u003e constexpr T upscale_integer(  U p_value ) Upscale an integer value of arbitrary bit resolution to a new fixed with integer value.\nParameters:\n p_value - the value to be scaled  Template Parameters:\n T - integral type to bring the resolution of U up to. SourceWidth - the bit resolution of the input value U - integral type of the input value  Return: constexpr T - p_value but with resolution scaled up to type T\nThe purpose of bit scaling a value is to take a value of lower bit resolution, scale it up but keep the percentage relative to the bits resolution. This is useful for bit resolution erasure as well as image upscaling.\nFor example, lets take an 8-bit value of 127 (or 0x7F). This value is 50% of an 8-bit number. 50% of an 32-bit would be 2147483647 or 0x7FFFFFFF which is half of 2^32. A perfect upscaling would take 0x7F and generate 0x7FFFFFFF in this case. Doing so is quite costly and requires multiplication and division operations which are slower opetation.\nFast and efficient bit scaling is done via bit replication. For example, to scale an 8-bit value up to 32-bits would look like this:\n8-bit [ 0x7F ]  |\\\\\\_____________________  | \\\\___________ \\  | \\____ \\ \\  | \\ \\ |  | | | |  V V V V 32-bit [ 0x7F ] [ 0x7F ] [ 0x7F ] [ 0x7F ] Expected 32-bit value is: 0x7FFFFFFF Actual value from scaling: 0x7F7F7F7F % difference is: (0x7FFFFFFF - 0x7F7F7F7F) / 0x7FFFFFFF = 0.39215684% A percent difference well below 1% makes this a viable solution for most applications.\nfunction wait inline boost::leaf::result\u003c void \u003e wait(  serial \u0026 p_serial,  size_t p_length,  std::optional\u003c std::chrono::nanoseconds \u003e p_timeout =std::nullopt ) function write inline boost::leaf::result\u003c void \u003e write(  serial \u0026 p_serial,  std::span\u003c const std::byte \u003e p_data_out ) function read inline boost::leaf::result\u003c std::span\u003c const std::byte \u003e \u003e read(  serial \u0026 p_serial,  std::span\u003c std::byte \u003e p_data_in,  std::optional\u003c std::chrono::nanoseconds \u003e p_timeout =std::nullopt ) function read template \u003csize_t BytesToRead\u003e boost::leaf::result\u003c std::array\u003c std::byte, BytesToRead \u003e \u003e read(  serial \u0026 p_serial,  std::optional\u003c std::chrono::nanoseconds \u003e p_timeout =std::nullopt ) function write_then_read inline boost::leaf::result\u003c void \u003e write_then_read(  serial \u0026 p_serial,  std::span\u003c const std::byte \u003e p_data_out,  std::span\u003c std::byte \u003e p_data_in,  std::optional\u003c std::chrono::nanoseconds \u003e p_timeout =std::nullopt ) function write_then_read template \u003csize_t BytesToRead\u003e boost::leaf::result\u003c std::array\u003c std::byte, BytesToRead \u003e \u003e write_then_read(  serial \u0026 p_serial,  std::span\u003c const std::byte \u003e p_data_out,  std::optional\u003c std::chrono::nanoseconds \u003e p_timeout =std::nullopt ) function write inline boost::leaf::result\u003c void \u003e write(  spi \u0026 p_spi,  std::span\u003c const std::byte \u003e p_data_out ) Write data to the SPI bus and ignore data sent from peripherals on the bus.\nParameters:\n p_spi - spi driver p_data_out - data to be written to the SPI bus  Return: boost::leaf::result- any errors associated with this call\nfunction read inline boost::leaf::result\u003c void \u003e read(  spi \u0026 p_spi,  std::span\u003c std::byte \u003e p_data_in,  std::byte p_filler =spi::default_filler ) Read data from the SPI bus.\nParameters:\n p_spi - spi driver p_data_in - buffer to receive bytes back from the SPI bus p_filler - filler data placed on the bus in place of actual write data.  Return: boost::leaf::result- any errors associated with this call\nFiller bytes will be placed on the write line.\nfunction read template \u003csize_t BytesToRead\u003e boost::leaf::result\u003c std::array\u003c std::byte, BytesToRead \u003e \u003e read(  spi \u0026 p_spi,  std::byte p_filler =spi::default_filler ) Read data from the SPI bus and return a std::array of bytes.\nParameters:\n p_spi - spi driver p_filler - filler data placed on the bus in place of actual write data.  Template Parameters:\n BytesToRead - Number of bytes to read  Return: boost::leaf::result\u003cstd::array\u003cstd::byte, BytesToRead» - any errors associated with this call\nFiller bytes will be placed on the write line.\nfunction write_then_read inline boost::leaf::result\u003c void \u003e write_then_read(  spi \u0026 p_spi,  std::span\u003c const std::byte \u003e p_data_out,  std::span\u003c std::byte \u003e p_data_in,  std::byte p_filler =spi::default_filler ) Write data to the SPI bus and ignore data sent from peripherals on the bus then read data from the SPI and fill the write line with filler bytes.\nParameters:\n p_spi - spi driver p_data_out - bytes to write to the bus p_data_in - buffer to receive bytes back from the SPI bus p_filler - filler data placed on the bus when the read operation begins.  Return: boost::leaf::resultThis utility function that fits the use case of many SPI devices where a transaction is not full duplex. In many spi devices, full duplex means that as data is being written to the SPI bus, the peripheral device is sending data back on the read line. In most cases, the protocol is to write data to the bus, and ignore the read line because the peripheral is not writing anything meaningful to that line, then reading from SPI bus and writing nothing meaningful to the write line as the peripheral is ignoring that line.\nfunction write_then_read template \u003csize_t BytesToRead\u003e boost::leaf::result\u003c std::array\u003c std::byte, BytesToRead \u003e \u003e write_then_read(  spi \u0026 p_spi,  std::span\u003c const std::byte \u003e p_data_out,  std::byte p_filler =spi::default_filler ) Write data to the SPI bus and ignore data sent from peripherals on the bus then read data from the SPI, fill the write line with filler bytes and return an array of bytes.\nParameters:\n p_spi - spi driver p_data_out - bytes to write to the bus p_filler - filler data placed on the bus when the read operation begins.  Template Parameters:\n BytesToRead - Number of bytes to read from the bus  Return: boost::leaf::result\u003cstd::array\u003cstd::byte, BytesToRead»\nfunction to_array template \u003csize_t N\u003e constexpr std::array\u003c char, N+1 \u003e to_array(  std::string_view p_view ) Convert a string_view into a std::array of N number of characters.\nParameters:\n p_view - string to be placed into a char array  Template Parameters:\n N - Size of the array  Return: constexpr std::array\u003cchar, N + 1\u003e - the char array object\nWill always ensure that the array is null terminated\nAttributes Documentation variable default_clock_rate constexpr frequency default_clock_rate = frequency(100'000); Default clock rate for serial communication protocols.\n Updated on 2022-05-15 at 12:08:46 +0000\n","description":"","tags":null,"title":"embed","uri":"/libembeddedhal/api/namespaces/namespaceembed/"},{"content":"embed::accelerometer Class Reference\nAccelerometer hardware abstraction interface. More…\n#include \u003caccelerometer.hpp\u003e\nPublic Classes     Name     struct sample Representation of a sample of accelerometer data.    Public Functions     Name     boost::leaf::result\u003c sample \u003e read()Read the current acceleration from the accelerometer.    Detailed Description class embed::accelerometer; Accelerometer hardware abstraction interface.\nThis interface represents devices and peripherals that have the capability to measure acceleration.\nPublic Functions Documentation function read inline boost::leaf::result\u003c sample \u003e read() Read the current acceleration from the accelerometer.\nReturn: boost::leaf::result- a sample of data or an error\n Updated on 2022-05-15 at 12:08:46 +0000\n","description":"","tags":null,"title":"embed::accelerometer","uri":"/libembeddedhal/api/classes/classembed_1_1accelerometer/"},{"content":"embed::accelerometer::sample Struct Reference\nRepresentation of a sample of accelerometer data. More…\n#include \u003caccelerometer.hpp\u003e\nPublic Classes     Name     struct axis_t    Public Functions     Name     constexpr auto operator\u003c=\u003e(const sample \u0026 ) const =defaultDefault operators for \u003c, \u003c=, \u003e, \u003e= and ==.    Public Attributes     Name     embed::acceleration full_scale   axis_t axis Acceleration in the XYZ axis.    Detailed Description struct embed::accelerometer::sample; Representation of a sample of accelerometer data.\nembed::percent was choosen for representing the x, y, and z data of an accelerometer because conversion from N-bit register to percent is fast compared to the math required to convert it to embed::nanometre_per_second_sq. This means that multiple samples can be gathered quickly to be converted to data at a later time.\nPublic Functions Documentation function operator\u003c=\u003e constexpr auto operator\u003c=\u003e(  const sample \u0026 ) const =default Default operators for \u003c, \u003c=, \u003e, \u003e= and ==.\nReturn: auto - result of the comparison\nPublic Attributes Documentation variable full_scale embed::acceleration full_scale; Represents the maximum amplitude of acceleration for this sample of data. In many cases this is 1g, 2g, 4g, 8g and many other values, where “g” represents the acceleration due to gravity on Earth at sea level. For example, if full_scale is 2g and the X-axis returns 50%, then the acceleration read on X is 1g of acceleration.\nfull_scale is made available for each sample in the event that the driver changes the full_scale between samples. This is uncommon and many applications will simply save the full scale once and drop saving it for subsequent calls.\nvariable axis axis_t axis; Acceleration in the XYZ axis.\n Updated on 2022-05-15 at 12:08:46 +0000\n","description":"","tags":null,"title":"embed::accelerometer::sample","uri":"/libembeddedhal/api/classes/structembed_1_1accelerometer_1_1sample/"},{"content":"embed::accelerometer::sample::axis_t Struct Reference\nMore…\n#include \u003caccelerometer.hpp\u003e\nPublic Functions     Name     constexpr auto operator\u003c=\u003e(const axis_t \u0026 ) const =defaultDefault operators for \u003c, \u003c=, \u003e, \u003e= and ==.    Public Attributes     Name     percent x Percentage of acceleration in the X-axis relative to the full-scale.   percent y Percentage of acceleration in the Y-axis relative to the full-scale.   percent z Percentage of acceleration in the Z-axis relative to the full-scale.    Detailed Description struct embed::accelerometer::sample::axis_t; Represents the percentage of acceleration in the X, Y \u0026 Z axis relative to the full-scale\nPublic Functions Documentation function operator\u003c=\u003e constexpr auto operator\u003c=\u003e(  const axis_t \u0026 ) const =default Default operators for \u003c, \u003c=, \u003e, \u003e= and ==.\nReturn: auto - result of the comparison\nPublic Attributes Documentation variable x percent x; Percentage of acceleration in the X-axis relative to the full-scale.\nvariable y percent y; Percentage of acceleration in the Y-axis relative to the full-scale.\nvariable z percent z; Percentage of acceleration in the Z-axis relative to the full-scale.\n Updated on 2022-05-15 at 12:08:46 +0000\n","description":"","tags":null,"title":"embed::accelerometer::sample::axis_t","uri":"/libembeddedhal/api/classes/structembed_1_1accelerometer_1_1sample_1_1axis__t/"},{"content":"embed::adc Class Reference\nAnalog to Digital Converter (ADC) hardware abstraction interface. More…\n#include \u003cadc.hpp\u003e\nInherited by embed::stub::adc\nPublic Functions     Name     boost::leaf::result\u003c percent \u003e read()Read a sample from the analog to digital converter.    Detailed Description class embed::adc; Analog to Digital Converter (ADC) hardware abstraction interface.\nUse this interface for devices and peripherals that can convert analog voltage signals into a digital number.\nPublic Functions Documentation function read inline boost::leaf::result\u003c percent \u003e read() Read a sample from the analog to digital converter.\nReturn: boost::leaf::result- Return the value of the ADC as a full_scale value. Typical implemenation for a 12-bit adc would look like: return embed::bit_depth\u003cuint32_t, 12\u003e(adc_value);.\nThis function makes no assumptions about how the conversation is made via the ADC. Conversions could be performed at each call of this function. Conversions can be ongoing by hardware and this function returns the latest sample or the first sample from a queue. The conversation can also occur over a communication protocol like SPI or I2C which could effect the time it takes for this function to return. It is the responsibility of the application developer to understand how a particular ADC will effect their application.\n Updated on 2022-05-15 at 12:08:46 +0000\n","description":"","tags":null,"title":"embed::adc","uri":"/libembeddedhal/api/classes/classembed_1_1adc/"},{"content":"embed::bit_limits Struct Reference\nSimilar to std::numeric_limitsexcept that this object can give properties of integral types of arbitrary bit widths. More…\n#include \u003cbit_limits.hpp\u003e\nPublic Functions     Name     constexpr int_t max()Get the maximum value available for an integer of BitWidth size and that can be stored within int_t.   constexpr int_t min()Get the minimum value available for an integer of BitWidth size and that can be stored within int_t.    Detailed Description template \u003csize_t BitWidth, std::integral int_t\u003e struct embed::bit_limits; Similar to std::numeric_limitsexcept that this object can give properties of integral types of arbitrary bit widths.\nTemplate Parameters:\n BitWidth - bit width of the value int_t - the containing type. Will generate a compile error if the containing type’s bit width is smaller than the BitWidth value.  Public Functions Documentation function max static inline constexpr int_t max() Get the maximum value available for an integer of BitWidth size and that can be stored within int_t.\nReturn: constexpr int_t maximum value\nThe final value of the function depends also on the sign of the int type.\nfunction min static inline constexpr int_t min() Get the minimum value available for an integer of BitWidth size and that can be stored within int_t.\nReturn: constexpr int_t minimum value\nThe final value of the function depends also on the sign of the int type. Unsigned ints simply return zero.\n Updated on 2022-05-15 at 12:08:46 +0000\n","description":"","tags":null,"title":"embed::bit_limits","uri":"/libembeddedhal/api/classes/structembed_1_1bit__limits/"},{"content":"embed::can Class Reference\nController Area Network (CAN bus) hardware abstraction interface.\n#include \u003ccan.hpp\u003e\nPublic Classes     Name     struct message_t Structure of a CAN message.   struct settings Generic settings for a can peripheral.    Public Types     Name     using uint32_t id_t Can message ID type trait.    Public Functions     Name     boost::leaf::result\u003c void \u003e configure(const settings \u0026 p_settings)Configure can to match the settings supplied.   boost::leaf::result\u003c void \u003e send(const message_t \u0026 p_message)Send a can message over the can bus.   boost::leaf::result\u003c void \u003e attach_interrupt(std::function\u003c void(const message_t \u0026p_message)\u003e p_receive_handler)Setup driver to execute callback when a can message is received.    Public Types Documentation using id_t using embed::can::id_t = uint32_t; Can message ID type trait.\nPublic Functions Documentation function configure inline boost::leaf::result\u003c void \u003e configure(  const settings \u0026 p_settings ) Configure can to match the settings supplied.\nParameters:\n p_settings - settings to apply to can driver  Return: boost::leaf::result- any error that occurred during this operation. Will return embed::error::invalid_settings if the settings could not be achieved.\nfunction send inline boost::leaf::result\u003c void \u003e send(  const message_t \u0026 p_message ) Send a can message over the can bus.\nParameters:\n p_message - the message to be sent  Return: boost::leaf::result- any error that occurred during this operation.\nfunction attach_interrupt inline boost::leaf::result\u003c void \u003e attach_interrupt(  std::function\u003c void(const message_t \u0026p_message)\u003e p_receive_handler ) Setup driver to execute callback when a can message is received.\nParameters:\n p_receive_handler - this handler will be called when the can device receives a message. Set to nullptr to disable receive interrupts.  Return: boost::leaf::result- any error that occurred during this operation.\nAll received can messages are dropped before this function is called.\n Updated on 2022-05-15 at 12:08:46 +0000\n","description":"","tags":null,"title":"embed::can","uri":"/libembeddedhal/api/classes/classembed_1_1can/"},{"content":"embed::can_network Class Reference\nManage, store, and organize messages received on the can bus. More…\n#include \u003cnetwork.hpp\u003e\nPublic Classes     Name     class node_t A can network node stores the can messages in a lock free way.    Public Functions     Name      can_network(can \u0026 p_can, std::pmr::memory_resource \u0026 p_memory_resource)Construct a new can network object.   boost::leaf::result\u003c node_t * \u003e register_message_id(can::id_t p_id)Assocate a can id with a node in the can network.   can \u0026 bus()get a reference to the can peripheral driver   const auto \u0026 get_internal_map()Get the Internal Map object.    Detailed Description class embed::can_network; Manage, store, and organize messages received on the can bus.\nDrivers use this can bus peripheral manager rather than can directly. This is to ensure that the correct can messages are filtered to the correct driver.\nTo understand the importance of using this class over can direction consider protocols like UART and I2C. UART is asynchronous and communicates with a single device. Messages may come at an arbitrary time, but their origin is always known. Typically a single device driver holds control over a UART peripheral. I2C is a multi device us but the controller is always the initiator of the communication. Once an i2c controller successfully starts a conversation with another device on the bus, the response should always come from that device. CAN has this problem where messages can come in at any time from any device on the bus, making writting a driver that accepts the can interface directly impossible as there would be no way to coordinate which driver gets what data when the can interface has only a singular receive method.\nCan Network provides a means for routing messages based on ID to can device drivers.\nPublic Functions Documentation function can_network inline can_network(  can \u0026 p_can,  std::pmr::memory_resource \u0026 p_memory_resource ) Construct a new can network object.\nParameters:\n p_can - can peripheral to manage the network of p_memory_resource - memory resource used for storing can messages  function register_message_id inline boost::leaf::result\u003c node_t * \u003e register_message_id(  can::id_t p_id ) Assocate a can id with a node in the can network.\nParameters:\n p_id - Associated ID of messages to be stored.  Exceptions:\n std::bad_alloc if this static storage allocated for this object is not enough to hold  Return: node_t* - reference to the CANBUS network node_t which can be used at anytime to retreive the latest received message from the CANBUS that is associated with the set ID.\nTo store can message with an associated ID in the can_network, it must be declared using this method. For example if you expect to get the following IDs 0x140, 0x7AA, and 0x561 from the CAN bus, then this method must be called as such:\n {C++} node_t* motor_node = can_network.register_message_id(0x140); node_t* encoder_node = can_network.register_message_id(0x561); node_t* temperature_node = can_network.register_message_id(0x7AA); function bus inline can \u0026 bus() get a reference to the can peripheral driver\nReturn: can\u0026 reference to the can peripheral driver\nCan be used to initialize, configure, and enable the peripheral as well as transmit messages.\nfunction get_internal_map inline const auto \u0026 get_internal_map() Get the Internal Map object.\nReturn: const auto\u0026 map of all of the messages in the network.\nMeant for testing purposes or when direct inspection of the map is useful in userspace. Should not be used in by libraries.\n Updated on 2022-05-15 at 12:08:46 +0000\n","description":"","tags":null,"title":"embed::can_network","uri":"/libembeddedhal/api/classes/classembed_1_1can__network/"},{"content":"embed::can_network::node_t Class Reference\nA can network node stores the can messages in a lock free way. More…\n#include \u003cnetwork.hpp\u003e\nPublic Functions     Name      node_t()Construct a new node t object.   node_t \u0026 operator=(const node_t \u0026 p_node)Node assignment operator.    node_t(const node_t \u0026 p_node)Construct a new node t object.   can::message_t secure_get()Get this node’s can message.    Detailed Description class embed::can_network::node_t; A can network node stores the can messages in a lock free way.\nUpdating the can message data is completely lock free. Retrieving data uses atomics to poll for when the update() function has completed. This asymmetry in locking is to reduce write time, which is usually done in an interrupt context, rather than than read time, which is performed by a driver in a thread or main thread.\nPublic Functions Documentation function node_t inline node_t() Construct a new node t object.\nfunction operator= inline node_t \u0026 operator=(  const node_t \u0026 p_node ) Node assignment operator.\nParameters:\n p_node the node copy  Return: node_t\u0026 reference to this object\nfunction node_t inline node_t(  const node_t \u0026 p_node ) Construct a new node t object.\nParameters:\n p_node the object to copy  function secure_get inline can::message_t secure_get() Get this node’s can message.\nReturn: can::message_t\n Updated on 2022-05-15 at 12:08:46 +0000\n","description":"","tags":null,"title":"embed::can_network::node_t","uri":"/libembeddedhal/api/classes/classembed_1_1can__network_1_1node__t/"},{"content":"embed::can::message_t Struct Reference\nStructure of a CAN message.\n#include \u003ccan.hpp\u003e\nPublic Attributes     Name     id_t id ID of the message.   uint8_t length The number of elements in the payload.   std::array\u003c std::byte, 8 \u003e payload The message data.   bool is_remote_request    Public Attributes Documentation variable id id_t id; ID of the message.\nvariable length uint8_t length = 0; The number of elements in the payload.\nvariable payload std::array\u003c std::byte, 8 \u003e payload { std::byte{ 0 } }; The message data.\nvariable is_remote_request bool is_remote_request = false; Whether or not the message is a remote request frame. If true, then length and payload are ignored.\n Updated on 2022-05-15 at 12:08:46 +0000\n","description":"","tags":null,"title":"embed::can::message_t","uri":"/libembeddedhal/api/classes/structembed_1_1can_1_1message__t/"},{"content":"embed::can::settings Struct Reference\nGeneric settings for a can peripheral.\n#include \u003ccan.hpp\u003e\nPublic Attributes     Name     frequency clock_rate Bus clock rate.    Public Attributes Documentation variable clock_rate frequency clock_rate = default_clock_rate; Bus clock rate.\n Updated on 2022-05-15 at 12:08:46 +0000\n","description":"","tags":null,"title":"embed::can::settings","uri":"/libembeddedhal/api/classes/structembed_1_1can_1_1settings/"},{"content":"embed::config Namespace Reference\nNamespaces    Name     embed::config::defaults     Updated on 2022-05-15 at 12:08:46 +0000\n","description":"","tags":null,"title":"embed::config","uri":"/libembeddedhal/api/namespaces/namespaceembed_1_1config/"},{"content":"embed::config::defaults Namespace Reference\nAttributes     Name     constexpr std::string_view platform   constexpr bool get_stacktrace_on_error   constexpr size_t stacktrace_depth_limit   constexpr bool get_source_position_on_error    Attributes Documentation variable platform constexpr std::string_view platform = \"test\"; variable get_stacktrace_on_error constexpr bool get_stacktrace_on_error = true; variable stacktrace_depth_limit constexpr size_t stacktrace_depth_limit = 32; variable get_source_position_on_error constexpr bool get_source_position_on_error = false;  Updated on 2022-05-15 at 12:08:46 +0000\n","description":"","tags":null,"title":"embed::config::defaults","uri":"/libembeddedhal/api/namespaces/namespaceembed_1_1config_1_1defaults/"},{"content":"embed::counter Class Reference\nCounter hardware abstraction interface. Use this interface for devices and peripherals that have counting capabilities. Such devices can count up or down. Useful for keeping time. Expect counters to overflow when they reach the end of counting register’s limits.\n#include \u003ccounter.hpp\u003e\nPublic Classes     Name     struct uptime_t Representation of a counter’s uptime.    Public Functions     Name     boost::leaf::result\u003c uptime_t \u003e uptime()Get the uptime of the counter since it has started.    Public Functions Documentation function uptime inline boost::leaf::result\u003c uptime_t \u003e uptime() Get the uptime of the counter since it has started.\nReturn: uptime_t - the current uptime since the counter has started.\nThe count for a counterr will always count up. Hardware counters must support 32-bit counts.\n Updated on 2022-05-15 at 12:08:46 +0000\n","description":"","tags":null,"title":"embed::counter","uri":"/libembeddedhal/api/classes/classembed_1_1counter/"},{"content":"embed::counter::uptime_t Struct Reference\nRepresentation of a counter’s uptime.\n#include \u003ccounter.hpp\u003e\nPublic Attributes     Name     embed::frequency frequency Current operating frequency of the counter.   std::uint32_t count The current count of the counter.    Public Attributes Documentation variable frequency embed::frequency frequency; Current operating frequency of the counter.\nvariable count std::uint32_t count; The current count of the counter.\n Updated on 2022-05-15 at 12:08:46 +0000\n","description":"","tags":null,"title":"embed::counter::uptime_t","uri":"/libembeddedhal/api/classes/structembed_1_1counter_1_1uptime__t/"},{"content":"embed::dac Class Reference\nDigital to Analog Converter (DAC) hardware abstraction interface. More…\n#include \u003cdac.hpp\u003e\nInherited by embed::mock::dac, embed::stub::dac\nPublic Functions     Name     boost::leaf::result\u003c void \u003e write(percent p_value)Generate a voltage between a defined LOW and HIGH voltage.    Detailed Description class embed::dac; Digital to Analog Converter (DAC) hardware abstraction interface.\nUse this interface for devices and peripherals that can create arbitrary analog voltages between a defined LOW and HIGH voltage.\nPublic Functions Documentation function write inline boost::leaf::result\u003c void \u003e write(  percent p_value ) Generate a voltage between a defined LOW and HIGH voltage.\nParameters:\n p_value - percentage scale from LOW to HIGH voltage  Return: boost::leaf::result- any error that occurred during this operation.\nThe LOW and HIGH voltage are generally configured by a reference voltage (usually denoted V_ref) connected to the device. Generally though, the low voltage is 0V and the high voltage reference is VCC.\n Updated on 2022-05-15 at 12:08:46 +0000\n","description":"","tags":null,"title":"embed::dac","uri":"/libembeddedhal/api/classes/classembed_1_1dac/"},{"content":"embed::duty_cycle Struct Reference\nStructure containing cycle count for the high and low side of a signal duty cycle.\n#include \u003cfrequency.hpp\u003e\nPublic Functions     Name     constexpr auto operator==(const duty_cycle \u0026 p_cycle) const== operator   constexpr operator percent() constConversion from duty cycle to percentage.    Public Attributes     Name     std::uint32_t high Number of cycles the signal will stay in the HIGH voltage state.   std::uint32_t low Number of cycles the signal will stay in the LOW voltage state.    Public Functions Documentation function operator== inline constexpr auto operator==(  const duty_cycle \u0026 p_cycle ) const == operator\nParameters:\n p_cycle - other duty scale to compare to  Return: constexpr auto - true if the duty cycles have the exact same values.\nfunction operator percent inline explicit constexpr operator percent() const Conversion from duty cycle to percentage.\nReturn: constexpr percentage - Percentage of high cycles to the total cycle count.\nPublic Attributes Documentation variable high std::uint32_t high = 0; Number of cycles the signal will stay in the HIGH voltage state.\nvariable low std::uint32_t low = 0; Number of cycles the signal will stay in the LOW voltage state.\n Updated on 2022-05-15 at 12:08:46 +0000\n","description":"","tags":null,"title":"embed::duty_cycle","uri":"/libembeddedhal/api/classes/structembed_1_1duty__cycle/"},{"content":"embed::error Namespace Reference\nClasses     Name     struct embed::error::invalid_option_t Used for defining static_asserts that should always fail, but only if the static_assert line is hit via if constexpr control block. Prefer to NOT use this directly but to use invalid_option instead.   struct embed::error::invalid_settings Error type indicating that the settings for serial uart could not be set.   class embed::error::stacktrace A structure to hold stack strace source location entries. The size of this class can be changed by changing the embed::config::stacktrace_depth_limit value in the libembeddedhal.tweak.hpp file for your project. This can be used to reduce the stack size of functions that have Boost.LEAF handlers that inspect a embed::error::stacktrace.   struct embed::error::timeout An error indicating a timeout event.   struct embed::error::universal An association error type for all libembeddedhal drivers that inherit from this class. It is used to disambiguate errors coming from a libembeddedhal embed::driver vs those coming from other libraries.    Functions     Name     auto setup(const char * p_function_name =std::source_location::current().function_name(), const char * p_file_name =std::source_location::current().file_name(), int p_line_number =std::source_location::current().line())Every function within libembeddedhal and implementing its interfaces that returns a boost::leaf::resultand can return an error must have the following line at the start of its function definition:    Attributes     Name     constexpr bool invalid_option Helper definition to simplify the usage of invalid_option_t.    Functions Documentation function setup inline auto setup(  const char * p_function_name =std::source_location::current().function_name(),  const char * p_file_name =std::source_location::current().file_name(),  int p_line_number =std::source_location::current().line() ) Every function within libembeddedhal and implementing its interfaces that returns a boost::leaf::resultand can return an error must have the following line at the start of its function definition:\nParameters:\n p_function_name - the name of the calling function p_file_name - the name of the file in which this function was called p_line_number - the line number in which this function was called  Return: auto - error handler for when an error is emitted on the calling functions frame.\nauto on_error = embed::error::setup(); If an error occurs, this function ensures the following:\n That embed::error::universal is associated with the error which is necessary to allow handlers to capture any libembeddedhal specific error but ignore the actual error itself. This is similar to a catch(std::exception const\u0026) where you simply want to capture any and all exceptions deriving from std::exception but still allow other exceptions to pass through. That a stacktrace is captured for the path where an error occurred Since this function setups handler for when errors occur, it does not make sense to call this function for functions that return boost::leaf::resultbut can never return an error. Thus this function should not be called on such functions.  Attributes Documentation variable invalid_option constexpr bool invalid_option = invalid_option_t\u003coptions...\u003e::value; Helper definition to simplify the usage of invalid_option_t.\nTemplate Parameters:\n options ignored by the application but needed to create a non-trivial specialization of this class which allows its usage in static_assert.   Updated on 2022-05-15 at 12:08:46 +0000\n","description":"","tags":null,"title":"embed::error","uri":"/libembeddedhal/api/namespaces/namespaceembed_1_1error/"},{"content":"embed::error::invalid_option_t Struct Reference\nUsed for defining static_asserts that should always fail, but only if the static_assert line is hit via if constexpr control block. Prefer to NOT use this directly but to use invalid_option instead. More…\n#include \u003cerror.hpp\u003e\nInherits from std::false_type\nDetailed Description template \u003cauto... options\u003e struct embed::error::invalid_option_t; Used for defining static_asserts that should always fail, but only if the static_assert line is hit via if constexpr control block. Prefer to NOT use this directly but to use invalid_option instead.\nTemplate Parameters:\n options ignored by the application but needed to create a non-trivial specialization of this class which allows its usage in static_assert.   Updated on 2022-05-15 at 12:08:46 +0000\n","description":"","tags":null,"title":"embed::error::invalid_option_t","uri":"/libembeddedhal/api/classes/structembed_1_1error_1_1invalid__option__t/"},{"content":"embed::error::invalid_settings Struct Reference\nError type indicating that the settings for serial uart could not be set. More…\n#include \u003cerror.hpp\u003e\nDetailed Description struct embed::error::invalid_settings; Error type indicating that the settings for serial uart could not be set.\nHow to handle these errors:\n The nature of this error signifies an bug in the code. The documentation of the peripheral and the API of the driver should be consulted in order to determine what are possible settings for this serial port.   Updated on 2022-05-15 at 12:08:46 +0000\n","description":"","tags":null,"title":"embed::error::invalid_settings","uri":"/libembeddedhal/api/classes/structembed_1_1error_1_1invalid__settings/"},{"content":"embed::error::stacktrace Class Reference\nA structure to hold stack strace source location entries. The size of this class can be changed by changing the embed::config::stacktrace_depth_limit value in the libembeddedhal.tweak.hpp file for your project. This can be used to reduce the stack size of functions that have Boost.LEAF handlers that inspect a embed::error::stacktrace.\n#include \u003cerror.hpp\u003e\nPublic Functions     Name     auto get() constGet the stack trace list items.   void append(boost::leaf::e_source_location p_source_location)Add a source location to the stack trace list.    Public Functions Documentation function get inline auto get() const Get the stack trace list items.\nReturn: auto - return a const span with length equal to the number of entries in the stacktrace list.\nfunction append inline void append(  boost::leaf::e_source_location p_source_location ) Add a source location to the stack trace list.\nParameters:\n p_source_location - source location to be added to the list   Updated on 2022-05-15 at 12:08:46 +0000\n","description":"","tags":null,"title":"embed::error::stacktrace","uri":"/libembeddedhal/api/classes/classembed_1_1error_1_1stacktrace/"},{"content":"embed::error::timeout Struct Reference\nAn error indicating a timeout event. More…\n#include \u003cerror.hpp\u003e\nDetailed Description struct embed::error::timeout; An error indicating a timeout event.\nTimeouts occur when a particular operation is given an amount of time to complete. If the operation cannot be completed in that time, this object should be thrown.\n Updated on 2022-05-15 at 12:08:46 +0000\n","description":"","tags":null,"title":"embed::error::timeout","uri":"/libembeddedhal/api/classes/structembed_1_1error_1_1timeout/"},{"content":"embed::error::universal Struct Reference\nAn association error type for all libembeddedhal drivers that inherit from this class. It is used to disambiguate errors coming from a libembeddedhal embed::driver vs those coming from other libraries.\n#include \u003cerror.hpp\u003e\n Updated on 2022-05-15 at 12:08:46 +0000\n","description":"","tags":null,"title":"embed::error::universal","uri":"/libembeddedhal/api/classes/structembed_1_1error_1_1universal/"},{"content":"embed::frequency Class Reference\nRepresents the frequency of a signal. It consists of a single integer 64-bit number that presents the integer representation of a signal frequency.\n#include \u003cfrequency.hpp\u003e\nPublic Functions     Name     constexpr duty_cycle calculate_duty_cycle(std::uint32_t p_cycles, percent p_percent)Generate a duty_cycle object based on the percent value and the input count value. The count value is split based on the ratio within percent.   constexpr frequency(std::uint32_t p_value)construct the frequency object   constexpr auto cycles_per_second() constGet the frequency as an integer.   constexpr std::uint32_t divide(frequency p_target) constCalculate the frequency divide required to generate the output frequency provided.   boost::leaf::result\u003c std::uint64_t \u003e cycles_per(std::chrono::nanoseconds p_duration) constCalculate the number of cycles of this frequency within the time duration. This function is meant for timers to determine how many count cycles are needed to reach a paricular time duration at this frequency.   template std::chrono::duration\u003c int64_t, Period \u003e wavelength() constCalculates and returns the wavelength of the frequency in seconds.   boost::leaf::result\u003c std::chrono::nanoseconds \u003e duration_from_cycles(std::uint64_t p_cycles) constCalculate the time duration based on the frequency and a number of cycles.   boost::leaf::result\u003c duty_cycle \u003e calculate_duty_cycle(std::chrono::nanoseconds p_duration, percent p_percent) constCalculate a duty cycle based on a time duration, the percent and this driving frequency. Typically used for PWM or clock lines with controllable duty cycles for serial communication.   constexpr duty_cycle calculate_duty_cycle(frequency p_target, percent p_percent) constCalculate a duty cycle based on a target, the percent and this driving frequency. Typically used for PWM or clock lines with controllable duty cycles for serial communication.   constexpr auto operator\u003c=\u003e(const frequency \u0026 ) const =defaultDefault operators for \u003c, \u003c=, \u003e, \u003e= and ==.   template \u003cstd::unsigned_integral Integer\u003e boost::leaf::result\u003c frequency \u003e scale(Integer p_scalar) constScale up a frequency by an integer factor.    Friends     Name     constexpr friend frequency operator/(frequency p_lhs, std::uint32_t p_rhs) Scale down a frequency by an integer factor.   constexpr friend std::uint32_t operator/(frequency p_input, frequency p_target) Scale down a frequency by an integer factor.    Public Functions Documentation function calculate_duty_cycle static inline constexpr duty_cycle calculate_duty_cycle(  std::uint32_t p_cycles,  percent p_percent ) Generate a duty_cycle object based on the percent value and the input count value. The count value is split based on the ratio within percent.\nParameters:\n p_cycles - the number of cycles to be split into a duty cycle p_percent - the target duty cycle percentage  Return: constexpr duty_cycle - the duty cycle cycle counts\nfunction frequency inline explicit constexpr frequency(  std::uint32_t p_value ) construct the frequency object\nParameters:\n p_value - frequency of the object  function cycles_per_second inline constexpr auto cycles_per_second() const Get the frequency as an integer.\nReturn: constexpr auto - frequency value as an integer\nfunction divide inline constexpr std::uint32_t divide(  frequency p_target ) const Calculate the frequency divide required to generate the output frequency provided.\nParameters:\n p_target - the target output frequency  Return: constexpr std::uint32_t - the divide, when applied to this frequency, will achieve the p_target frequency. A value of is an error and 0 indicates that the output frequency is greater than this frequency and there does not exist an integer divide that can produce the output frequency.\nfunction cycles_per inline boost::leaf::result\u003c std::uint64_t \u003e cycles_per(  std::chrono::nanoseconds p_duration ) const Calculate the number of cycles of this frequency within the time duration. This function is meant for timers to determine how many count cycles are needed to reach a paricular time duration at this frequency.\nParameters:\n p_duration - the amount of time to convert to cycles  Return: boost::leaf::resultstd::uint64_t - either the number of cycles or std::errc::result_out_of_range.\nnanoseconds duration cannot exceed 4294967297000000000ns or ~136.1 average Gregorian years otherwise the output of this function is not defined.\nfunction wavelength template \u003ctypename Period =std::femto\u003e inline std::chrono::duration\u003c int64_t, Period \u003e wavelength() const Calculates and returns the wavelength of the frequency in seconds.\nTemplate Parameters:\n Period - desired period (defaults to std::femto for femtoseconds).  Return: std::chrono::duration\u003cint64_t, Period\u003e - time based wavelength of the frequency.\nfunction duration_from_cycles inline boost::leaf::result\u003c std::chrono::nanoseconds \u003e duration_from_cycles(  std::uint64_t p_cycles ) const Calculate the time duration based on the frequency and a number of cycles.\nParameters:\n p_cycles - number of cycles within the time duration  Return: boost::leaf::resultstd::chrono::nanoseconds - time duration based on this frequency and the number of cycles or std::errc::result_out_of_range.\nfunction calculate_duty_cycle inline boost::leaf::result\u003c duty_cycle \u003e calculate_duty_cycle(  std::chrono::nanoseconds p_duration,  percent p_percent ) const Calculate a duty cycle based on a time duration, the percent and this driving frequency. Typically used for PWM or clock lines with controllable duty cycles for serial communication.\nParameters:\n p_duration - target time duration to reach p_percent - ratio of the duty cycle high time  Return: constexpr duty_cycle\nfunction calculate_duty_cycle inline constexpr duty_cycle calculate_duty_cycle(  frequency p_target,  percent p_percent ) const Calculate a duty cycle based on a target, the percent and this driving frequency. Typically used for PWM or clock lines with controllable duty cycles for serial communication.\nParameters:\n p_target - target frequency to reach p_percent - ratio of the duty cycle high time  Template Parameters:\n T - containing type of the percent  Return: constexpr duty_cycle\nfunction operator\u003c=\u003e constexpr auto operator\u003c=\u003e(  const frequency \u0026 ) const =default Default operators for \u003c, \u003c=, \u003e, \u003e= and ==.\nReturn: auto - result of the comparison\nfunction scale template \u003cstd::unsigned_integral Integer\u003e inline boost::leaf::result\u003c frequency \u003e scale(  Integer p_scalar ) const Scale up a frequency by an integer factor.\nParameters:\n p_scalar - the value to scale the frequency up to  Template Parameters:\n Integer - type of unsigned integer  Return: constexpr frequency\nFriends friend operator/ friend constexpr friend frequency operator/(  frequency p_lhs,   std::uint32_t p_rhs ); Scale down a frequency by an integer factor.\nParameters:\n p_lhs - the frequency to be scaled p_rhs - the integer value to scale the frequency by  Return: constexpr frequency\nfriend operator/ friend constexpr friend std::uint32_t operator/(  frequency p_input,   frequency p_target ); Scale down a frequency by an integer factor.\nParameters:\n p_input - the input frequency to be divided down to the target frequency with an integer divide p_target - the target frequency to reach via an integer divide  Return: constexpr std::uint32_t - frequency divide value representing the number of cycles in the input that constitute one cycle in the target frequency.\n Updated on 2022-05-15 at 12:08:46 +0000\n","description":"","tags":null,"title":"embed::frequency","uri":"/libembeddedhal/api/classes/classembed_1_1frequency/"},{"content":"embed::i2c Class Reference\nInter-integrated Circuit (I2C) or Two Wire Interface (TWI) communication protocol hardware abstract interface.\n#include \u003ci2c.hpp\u003e\nPublic Classes     Name     struct settings Generic settings for a standard I2C device.    Public Types     Name     enum class errors { address_not_acknowledged, bus_error}General errors associated with I2C communication failures.    Public Functions     Name     boost::leaf::result\u003c void \u003e configure(const settings \u0026 p_settings)Configure i2c to match the settings supplied.   boost::leaf::result\u003c void \u003e transaction(std::byte p_address, std::span\u003c const std::byte \u003e p_data_out, std::span\u003c std::byte \u003e p_data_in)perform an i2c transaction with another device on the bus. The type of transaction depends on values of input parameters. This function will block until the entire transfer is finished.    Public Types Documentation enum errors    Enumerator Value Description     address_not_acknowledged  Error type indicating that the i2c transaction resulted in a NACK, meaning “not acknowledge”. NACKs occur when an address has been placed on the i2c bus and no device connected to the bus returned an acknowledge signal. How to handle these errors:      In cases where the program is scanning for available addresses, this error is expected behaviour. This is less of an error to handle but an expected return status.\n  If a driver has a set of possible addresses that it can use, and for that driver it makes sense to attempt to search for the valid address, then a handler can keep performing transactions until a valid address is found and then store that address.\n  In the case where the address is consistently NACK’ed but the driver expects a specific address, this is typically not handleable and indicates that the application or driver is incorrect in the device address.\n  In the case where NACK’s are spurious, then this may indicate that the i2c line is faulty or the device is misbehaving. This is not fixable in the application. But in some cases, if a software solution is required, the driver or application can simply retry again until a valid response is returned, but results may vary and are very specific to the devices and context of the situation. | | bus_error | | Error type indicating that the i2c lines were put into an invalid state during the transaction due to interference, misconfiguration of the i2c peripheral or the addressed device or something else. How to handle these errors:\n  In the event of this type of error, state the addressed device undefined. In the case of data reception, the data coming from the addressed device should be considered invalid. Any deeper handling will require deep context regarding the addressed device the transaction taking place. |\n  General errors associated with I2C communication failures.\nPublic Functions Documentation function configure inline boost::leaf::result\u003c void \u003e configure(  const settings \u0026 p_settings ) Configure i2c to match the settings supplied.\nParameters:\n p_settings - settings to apply to i2c driver  Return: boost::leaf::result- any error that occurred during this operation. Will return embed::error::invalid_settings if the settings could not be achieved.\nfunction transaction inline boost::leaf::result\u003c void \u003e transaction(  std::byte p_address,  std::span\u003c const std::byte \u003e p_data_out,  std::span\u003c std::byte \u003e p_data_in ) perform an i2c transaction with another device on the bus. The type of transaction depends on values of input parameters. This function will block until the entire transfer is finished.\nParameters:\n p_address 7-bit address of the device you want to communicate with. To perform a transaction with a 10-bit address, this parameter must be the address upper byte of the 10-bit address OR’d with 0b1111'0000 (the 10-bit address indicator). The lower byte of the address must be contained in the first byte of the p_data_out span. p_data_out data to be written to the addressed device. Set to nullptr with length zero in order to skip writting. p_data_in buffer to store read data from the addressed device. Set to nullptr with length 0 in order to skip reading.  Return: boost::leaf::result- any error that occurred during this operation.\nPerforming Write, Read and Write-Then-Read transactions depends on which span for data_out and data_in are set to null.\n For write transactions, pass p_data_in as an empty span std::span\u003cstd::byte\u003e{} and pass a buffer to p_data_out. For read transactions, pass p_data_out as an empty span std::span\u003cconst std::byte\u003e{} and pass a buffer to p_data_in. For write-then-read transactions, pass a buffer for both p_data_in p_data_out. In the event of arbitration loss, this function will wait for the bus to become free and try again. Arbitration loss means that during the address phase of a transaction 1 or more i2c bus controllers attempted to perform an transaction and one of the i2c bus controllers, that isn’t this one won out.   Updated on 2022-05-15 at 12:08:46 +0000\n","description":"","tags":null,"title":"embed::i2c","uri":"/libembeddedhal/api/classes/classembed_1_1i2c/"},{"content":"embed::i2c::settings Struct Reference\nGeneric settings for a standard I2C device.\n#include \u003ci2c.hpp\u003e\nPublic Attributes     Name     frequency clock_rate The serial clock rate in hertz.    Public Attributes Documentation variable clock_rate frequency clock_rate = default_clock_rate; The serial clock rate in hertz.\n Updated on 2022-05-15 at 12:08:46 +0000\n","description":"","tags":null,"title":"embed::i2c::settings","uri":"/libembeddedhal/api/classes/structembed_1_1i2c_1_1settings/"},{"content":"embed::input_pin Class Reference\nDigital input pin hardware abstraction. More…\n#include \u003cinput_pin.hpp\u003e\nPublic Classes     Name     struct settings Generic settings for input pins.    Public Functions     Name     boost::leaf::result\u003c void \u003e configure(const settings \u0026 p_settings)Configure the input pin to match the settings supplied.   boost::leaf::result\u003c bool \u003e level()Read the state of the input pin.    Detailed Description class embed::input_pin; Digital input pin hardware abstraction.\nUse this to read a pin and determine if the voltage on it is HIGH or LOW.\nPublic Functions Documentation function configure inline boost::leaf::result\u003c void \u003e configure(  const settings \u0026 p_settings ) Configure the input pin to match the settings supplied.\nParameters:\n p_settings - settings to apply to input pin  Return: boost::leaf::result- any error that occurred during this operation. Will return embed::error::invalid_settings if the settings could not be achieved.\nfunction level inline boost::leaf::result\u003c bool \u003e level() Read the state of the input pin.\nReturn: boost::leaf::result- true indicates HIGH voltage and false indicates LOW voltage\n Updated on 2022-05-15 at 12:08:46 +0000\n","description":"","tags":null,"title":"embed::input_pin","uri":"/libembeddedhal/api/classes/classembed_1_1input__pin/"},{"content":"embed::input_pin::settings Struct Reference\nGeneric settings for input pins.\n#include \u003cinput_pin.hpp\u003e\nPublic Attributes     Name     pin_resistor resistor pull resistor for an input pin    Public Attributes Documentation variable resistor pin_resistor resistor = pin_resistor::pull_up; pull resistor for an input pin\n Updated on 2022-05-15 at 12:08:46 +0000\n","description":"","tags":null,"title":"embed::input_pin::settings","uri":"/libembeddedhal/api/classes/structembed_1_1input__pin_1_1settings/"},{"content":"embed::interrupt_pin Class Reference\nDigital interrupt pin hardware abstraction. More…\n#include \u003cinterrupt_pin.hpp\u003e\nPublic Classes     Name     struct settings Generic settings for interrupt pins.    Public Types     Name     enum class trigger_edge { falling = 0, rising = 1, both = 2}The condition in which an interrupt is triggered.    Public Functions     Name     boost::leaf::result\u003c void \u003e configure(const settings \u0026 p_settings)Configure the interrupt pin to match the settings supplied.   boost::leaf::result\u003c bool \u003e level()Return the voltage level of the pin.   boost::leaf::result\u003c void \u003e attach_interrupt(std::function\u003c void(void)\u003e p_callback, trigger_edge p_trigger)Enable interrupts for this pin. Pass in the callback to be executed when the trigger condition is met. This function can be called multiple times if the callback or trigger conditions need to be changed. detach_interrupts() does not need to be called before re-running this function.   boost::leaf::result\u003c void \u003e detach_interrupt()Disable interrupts for this pin.    Detailed Description class embed::interrupt_pin; Digital interrupt pin hardware abstraction.\nUse this to trigger an interrupt service routine (ISR) when a pin detects a falling edge (when the pin’s voltage transitions from HIGH to LOW), a rising edge (when the pin’s voltage transitions from LOW to HIGH), or any transition of state on the pin.\nPublic Types Documentation enum trigger_edge    Enumerator Value Description     falling 0 Trigger and interrupt when a pin transitions from HIGH voltage to LOW voltage.   rising 1 Trigger and interrupt when a pin transitions from LOW voltage to HIGH voltage.   both 2 Trigger and interrupt when a pin transitions it state.    The condition in which an interrupt is triggered.\nPublic Functions Documentation function configure inline boost::leaf::result\u003c void \u003e configure(  const settings \u0026 p_settings ) Configure the interrupt pin to match the settings supplied.\nParameters:\n p_settings - settings to apply to interrupt pin  Return: boost::leaf::result- any error that occurred during this operation. Will return embed::error::invalid_settings if the settings could not be achieved.\nfunction level inline boost::leaf::result\u003c bool \u003e level() Return the voltage level of the pin.\nReturn: boost::leaf::result- any error that occurred during this operation.\nfunction attach_interrupt inline boost::leaf::result\u003c void \u003e attach_interrupt(  std::function\u003c void(void)\u003e p_callback,  trigger_edge p_trigger ) Enable interrupts for this pin. Pass in the callback to be executed when the trigger condition is met. This function can be called multiple times if the callback or trigger conditions need to be changed. detach_interrupts() does not need to be called before re-running this function.\nParameters:\n p_callback function to execute when the trigger condition is met p_trigger the trigger condition that will signal the system to run the callback.  Return: boost::leaf::result- any error that occurred during this operation.\nfunction detach_interrupt inline boost::leaf::result\u003c void \u003e detach_interrupt() Disable interrupts for this pin.\nReturn: boost::leaf::result- any error that occurred during this operation.\n Updated on 2022-05-15 at 12:08:46 +0000\n","description":"","tags":null,"title":"embed::interrupt_pin","uri":"/libembeddedhal/api/classes/classembed_1_1interrupt__pin/"},{"content":"embed::interrupt_pin::settings Struct Reference\nGeneric settings for interrupt pins.\n#include \u003cinterrupt_pin.hpp\u003e\nPublic Attributes     Name     pin_resistor resistor    Public Attributes Documentation variable resistor pin_resistor resistor = pin_resistor::pull_up; pull resistor for an interrupt pin. Generally advised to NOT use pin_resistor::none and if it is used and external pull resistor should be placed on the pin to prevent random interrupt from firing.\n Updated on 2022-05-15 at 12:08:46 +0000\n","description":"","tags":null,"title":"embed::interrupt_pin::settings","uri":"/libembeddedhal/api/classes/structembed_1_1interrupt__pin_1_1settings/"},{"content":"embed::literals Namespace Reference\nFunctions     Name     consteval frequency operator\"\"_Hz(unsigned long long p_value)user defined literals for making frequencies: 1337_Hz   consteval frequency operator\"\"_kHz(unsigned long long p_value)user defined literals for making frequencies in the kilohertz.   consteval frequency operator\"\"_MHz(unsigned long long p_value)user defined literals for making frequencies in the megahertz.    Functions Documentation function operator\"\"_Hz consteval frequency operator\"\"_Hz(  unsigned long long p_value ) user defined literals for making frequencies: 1337_Hz\nParameters:\n p_value - frequency in hertz  Return: consteval frequency - frequency in hertz\nExample range: 1337_Hz == 1,337 Hz\nfunction operator\"\"_kHz consteval frequency operator\"\"_kHz(  unsigned long long p_value ) user defined literals for making frequencies in the kilohertz.\nParameters:\n p_value - frequency in kilohertz  Return: consteval frequency - frequency in kilohertz\nExample range: 20_kHz == 20,000 Hz\nfunction operator\"\"_MHz consteval frequency operator\"\"_MHz(  unsigned long long p_value ) user defined literals for making frequencies in the megahertz.\nParameters:\n p_value - frequency in megahertz  Return: consteval frequency - frequency in megahertz\nExample range: 42_MHz == 42,000,000 Hz\n Updated on 2022-05-15 at 12:08:46 +0000\n","description":"","tags":null,"title":"embed::literals","uri":"/libembeddedhal/api/namespaces/namespaceembed_1_1literals/"},{"content":"embed::microkelvin Struct Reference\nInherits from units:: prefixed_unit\u003c microkelvin, units::isq::si::micro, units::isq::si::kelvin \u003e\n Updated on 2022-05-15 at 12:08:46 +0000\n","description":"","tags":null,"title":"embed::microkelvin","uri":"/libembeddedhal/api/classes/structembed_1_1microkelvin/"},{"content":"embed::micrometre_per_second_sq Struct Reference\nInherits from units::derived_unit\u003c micrometre_per_second_sq, units::isq::si::dim_acceleration, units::isq::si::micrometre, units::isq::si::second \u003e\n Updated on 2022-05-15 at 12:08:46 +0000\n","description":"","tags":null,"title":"embed::micrometre_per_second_sq","uri":"/libembeddedhal/api/classes/structembed_1_1micrometre__per__second__sq/"},{"content":"embed::millikelvin Struct Reference\nInherits from units:: prefixed_unit\u003c millikelvin, units::isq::si::milli, units::isq::si::kelvin \u003e\n Updated on 2022-05-15 at 12:08:46 +0000\n","description":"","tags":null,"title":"embed::millikelvin","uri":"/libembeddedhal/api/classes/structembed_1_1millikelvin/"},{"content":"embed::millimetre_per_second_sq Struct Reference\nInherits from units::derived_unit\u003c millimetre_per_second_sq, units::isq::si::dim_acceleration, units::isq::si::millimetre, units::isq::si::second \u003e\n Updated on 2022-05-15 at 12:08:46 +0000\n","description":"","tags":null,"title":"embed::millimetre_per_second_sq","uri":"/libembeddedhal/api/classes/structembed_1_1millimetre__per__second__sq/"},{"content":"embed::mock Namespace Reference\nClasses     Name     struct embed::mock::dac Mock dac implementation for use in unit tests and simulations with a spy function for write()   struct embed::mock::motor Mock motor implementation for use in unit tests and simulations with a spy function for power()   struct embed::mock::pwm Mock pwm implementation for use in unit tests and simulations with spy functions for configure() and duty_cycle().   struct embed::mock::timer Mock timer implementation for use in unit tests and simulations with spy functions for schedule(), clear(), and is_running()   struct embed::mock::write_only_spi Mock spi implementation for use in unit tests and simulations with a spy functions for configure() and a record for the transfer() out data. The record ignores the in buffer and just stores the data being sent so it can be inspected later.     Updated on 2022-05-15 at 12:08:46 +0000\n","description":"","tags":null,"title":"embed::mock","uri":"/libembeddedhal/api/namespaces/namespaceembed_1_1mock/"},{"content":"embed::mock::dac Struct Reference\nMock dac implementation for use in unit tests and simulations with a spy function for write()\n#include \u003cdac_mock.hpp\u003e\nInherits from embed::dac\nPublic Functions     Name     void reset()Reset spy information for write()    Public Attributes     Name     spy_handler\u003c percent \u003e spy_write Spy handler for embded::dac::write()    Additional inherited members Public Functions inherited from embed::dac\n    Name     boost::leaf::result\u003c void \u003e write(percent p_value)Generate a voltage between a defined LOW and HIGH voltage.    Public Functions Documentation function reset inline void reset() Reset spy information for write()\nPublic Attributes Documentation variable spy_write spy_handler\u003c percent \u003e spy_write; Spy handler for embded::dac::write()\n Updated on 2022-05-15 at 12:08:46 +0000\n","description":"","tags":null,"title":"embed::mock::dac","uri":"/libembeddedhal/api/classes/structembed_1_1mock_1_1dac/"},{"content":"embed::mock::motor Struct Reference\nMock motor implementation for use in unit tests and simulations with a spy function for power()\n#include \u003cmotor_mock.hpp\u003e\nInherits from embed::motor\nPublic Functions     Name     void reset()Reset spy information for power()    Public Attributes     Name     spy_handler\u003c percent \u003e spy_power Spy handler for embded::motor::write()    Additional inherited members Public Functions inherited from embed::motor\n    Name     boost::leaf::result\u003c void \u003e power(percent p_power)Apply a percentage of power to the motor equal to the p_power input parameter.    Public Functions Documentation function reset inline void reset() Reset spy information for power()\nPublic Attributes Documentation variable spy_power spy_handler\u003c percent \u003e spy_power; Spy handler for embded::motor::write()\n Updated on 2022-05-15 at 12:08:46 +0000\n","description":"","tags":null,"title":"embed::mock::motor","uri":"/libembeddedhal/api/classes/structembed_1_1mock_1_1motor/"},{"content":"embed::mock::pwm Struct Reference\nMock pwm implementation for use in unit tests and simulations with spy functions for configure() and duty_cycle().\n#include \u003cpwm_mock.hpp\u003e\nInherits from embed::pwm\nPublic Functions     Name     void reset()Reset spy information for both configure() and duty_cycle()    Public Attributes     Name     spy_handler\u003c settings \u003e spy_configure Spy handler for embed::pwm::configure()   spy_handler\u003c percent \u003e spy_duty_cycle Spy handler for embed::pwm::duty_cycle()    Additional inherited members Public Classes inherited from embed::pwm\n    Name     struct settings    Public Functions inherited from embed::pwm\n    Name     boost::leaf::result\u003c void \u003e configure(const settings \u0026 p_settings)Configure pwm to match the settings supplied.   boost::leaf::result\u003c void \u003e duty_cycle(percent p_duty_cycle)Set the duty cycle percentage.    Public Functions Documentation function reset inline void reset() Reset spy information for both configure() and duty_cycle()\nPublic Attributes Documentation variable spy_configure spy_handler\u003c settings \u003e spy_configure; Spy handler for embed::pwm::configure()\nvariable spy_duty_cycle spy_handler\u003c percent \u003e spy_duty_cycle; Spy handler for embed::pwm::duty_cycle()\n Updated on 2022-05-15 at 12:08:46 +0000\n","description":"","tags":null,"title":"embed::mock::pwm","uri":"/libembeddedhal/api/classes/structembed_1_1mock_1_1pwm/"},{"content":"embed::mock::timer Struct Reference\nMock timer implementation for use in unit tests and simulations with spy functions for schedule(), clear(), and is_running()\n#include \u003ctimer_mock.hpp\u003e\nInherits from embed::timer\nPublic Functions     Name     void reset()Reset spy information for schedule(), clear(), and is_running()    Public Attributes     Name     spy_handler\u003c std::function\u003c void(void)\u003e, std::chrono::nanoseconds \u003e spy_schedule Spy handler for embed::timer::schedule()   spy_handler\u003c bool \u003e spy_is_running Spy handler for embed::timer::is_running()   spy_handler\u003c bool \u003e spy_clear Spy handler for embed::timer::clear()    Additional inherited members Public Classes inherited from embed::timer\n    Name     struct out_of_bounds Error type indicating that the desired time delay is not achievable with this timer.    Public Functions inherited from embed::timer\n    Name     boost::leaf::result\u003c bool \u003e is_running()Determine if the timer is currently running.   boost::leaf::result\u003c void \u003e clear()Stops a scheduled event from happening.   boost::leaf::result\u003c void \u003e schedule(std::function\u003c void(void)\u003e p_callback, std::chrono::nanoseconds p_delay)Schedule an callback to be called at a designated time/interval.    Public Functions Documentation function reset inline void reset() Reset spy information for schedule(), clear(), and is_running()\nPublic Attributes Documentation variable spy_schedule spy_handler\u003c std::function\u003c void(void)\u003e, std::chrono::nanoseconds \u003e spy_schedule; Spy handler for embed::timer::schedule()\nvariable spy_is_running spy_handler\u003c bool \u003e spy_is_running; Spy handler for embed::timer::is_running()\nvariable spy_clear spy_handler\u003c bool \u003e spy_clear; Spy handler for embed::timer::clear()\n Updated on 2022-05-15 at 12:08:46 +0000\n","description":"","tags":null,"title":"embed::mock::timer","uri":"/libembeddedhal/api/classes/structembed_1_1mock_1_1timer/"},{"content":"embed::mock::write_only_spi Struct Reference\nMock spi implementation for use in unit tests and simulations with a spy functions for configure() and a record for the transfer() out data. The record ignores the in buffer and just stores the data being sent so it can be inspected later.\n#include \u003cspi_mock.hpp\u003e\nInherits from embed::spi\nPublic Functions     Name     void reset()Reset spy information for both configure() and transfer()    Public Attributes     Name     spy_handler\u003c settings \u003e spy_configure Spy handler for embed::spi::configure()   std::vector\u003c std::vector\u003c std::byte \u003e \u003e write_record Record of the out data from embed::spi::transfer()    Additional inherited members Public Classes inherited from embed::spi\n    Name     struct settings Generic settings for a standard SPI device.    Public Functions inherited from embed::spi\n    Name     boost::leaf::result\u003c void \u003e configure(const settings \u0026 p_settings)Configure spi to match the settings supplied.   boost::leaf::result\u003c void \u003e transfer(std::span\u003c const std::byte \u003e p_data_out, std::span\u003c std::byte \u003e p_data_in, std::byte p_filler =default_filler) =defaultSend and receieve data between a selected device on the spi bus. This function will block until the entire transfer is finished.    Public Attributes inherited from embed::spi\n    Name     constexpr std::byte default_filler    Public Functions Documentation function reset inline void reset() Reset spy information for both configure() and transfer()\nPublic Attributes Documentation variable spy_configure spy_handler\u003c settings \u003e spy_configure; Spy handler for embed::spi::configure()\nvariable write_record std::vector\u003c std::vector\u003c std::byte \u003e \u003e write_record; Record of the out data from embed::spi::transfer()\n Updated on 2022-05-15 at 12:08:46 +0000\n","description":"","tags":null,"title":"embed::mock::write_only_spi","uri":"/libembeddedhal/api/classes/structembed_1_1mock_1_1write__only__spi/"},{"content":"embed::motor Class Reference\nHardware abstraction for open loop continuous rotary and linear actuators. More…\n#include \u003cmotor.hpp\u003e\nInherited by embed::mock::motor\nPublic Functions     Name     boost::leaf::result\u003c void \u003e power(percent p_power)Apply a percentage of power to the motor equal to the p_power input parameter.    Detailed Description class embed::motor; Hardware abstraction for open loop continuous rotary and linear actuators.\nThe motor interface can represent a variety of things such as:\n A driver for motor controller IC like the DRV8801 A driver for a motor with integrated controller \u0026 serial interface A unidirectional motor controlled by a single transistor A servo with open loop motor control  Public Functions Documentation function power inline boost::leaf::result\u003c void \u003e power(  percent p_power ) Apply a percentage of power to the motor equal to the p_power input parameter.\nParameters:\n p_power - the amount of power to apply to the motor  Return: boost::leaf::result- success or an error that occurred when attempting to set the power output of the motor.\nThe power applied is unitless and thus cannot be used as a way to gauge how fast the motor is moving. In general applying more power means to increase speed and/or torque to the motor.\n 0% power would mean that no power is being applied to the motor. In this situation an unloaded motor will not move. 0% power does not guarantee that the motor will hold its position. These specifics depend greatly on the type of motor used and careful selection of motor and motor driver are important for applications using this interface. 100% power means that the maximum available of power is being applied to the motor. As an example, if the max voltage of a DC brushed motor’s power supply is 12V, then 12V would be supplied to this motor. 50% power would mean that half of the available power is being applied to the motor. Using the same example, in this case 6V would be applied to the motor either as a DC constant voltage or via PWM at 50% duty cycle. Negative percentages will cause the motor to move in the opposite direction as positive percentages. In the event that motor driver can * only go in one direction, this function should clamp the power applied to 0%.   Updated on 2022-05-15 at 12:08:46 +0000\n","description":"","tags":null,"title":"embed::motor","uri":"/libembeddedhal/api/classes/classembed_1_1motor/"},{"content":"embed::nanokelvin Struct Reference\nInherits from units:: prefixed_unit\u003c nanokelvin, units::isq::si::nano, units::isq::si::kelvin \u003e\n Updated on 2022-05-15 at 12:08:46 +0000\n","description":"","tags":null,"title":"embed::nanokelvin","uri":"/libembeddedhal/api/classes/structembed_1_1nanokelvin/"},{"content":"embed::nanometre_per_second_sq Struct Reference\nInherits from units::derived_unit\u003c nanometre_per_second_sq, units::isq::si::dim_acceleration, units::isq::si::nanometre, units::isq::si::second \u003e\n Updated on 2022-05-15 at 12:08:46 +0000\n","description":"","tags":null,"title":"embed::nanometre_per_second_sq","uri":"/libembeddedhal/api/classes/structembed_1_1nanometre__per__second__sq/"},{"content":"embed::output_pin Class Reference\nDigital output pin hardware abstraction. More…\n#include \u003coutput_pin.hpp\u003e\nPublic Classes     Name     struct settings Generic settings for output pins.    Public Functions     Name     boost::leaf::result\u003c void \u003e configure(const settings \u0026 p_settings)Configure the output pin to match the settings supplied.   boost::leaf::result\u003c void \u003e level(bool p_high)Set the state of the pin.   boost::leaf::result\u003c bool \u003e level()Read the state of the output pin. Implementations must read the pin state from hardware and will not simply cache the results from running level(bool).    Detailed Description class embed::output_pin; Digital output pin hardware abstraction.\nUse this to drive a pin HIGH or LOW in order to send a control signal or turn off or on an LED.\nPublic Functions Documentation function configure inline boost::leaf::result\u003c void \u003e configure(  const settings \u0026 p_settings ) Configure the output pin to match the settings supplied.\nParameters:\n p_settings - settings to apply to output pin  Return: boost::leaf::result- any error that occurred during this operation. Will return embed::error::invalid_settings if the settings could not be achieved.\nfunction level inline boost::leaf::result\u003c void \u003e level(  bool p_high ) Set the state of the pin.\nParameters:\n p_high - if true then the pin state is set to HIGH voltage. If false, the pin state is set to LOW voltage.  Return: boost::leaf::result- any error that occurred during this operation.\nfunction level inline boost::leaf::result\u003c bool \u003e level() Read the state of the output pin. Implementations must read the pin state from hardware and will not simply cache the results from running level(bool).\nReturn: boost::leaf::result- true indicates HIGH voltage and false indicates LOW voltage\n Updated on 2022-05-15 at 12:08:46 +0000\n","description":"","tags":null,"title":"embed::output_pin","uri":"/libembeddedhal/api/classes/classembed_1_1output__pin/"},{"content":"embed::output_pin::settings Struct Reference\nGeneric settings for output pins.\n#include \u003coutput_pin.hpp\u003e\nPublic Attributes     Name     pin_resistor resistor   bool open_drain   bool starting_level    Public Attributes Documentation variable resistor pin_resistor resistor = pin_resistor::pull_up; Pull resistor for the pin. This generally only helpful when open drain is enabled.\nvariable open_drain bool open_drain = false; Starting level of the output pin. HIGH voltage defined as true and LOW voltage defined as false.\nvariable starting_level bool starting_level = true; Set the starting level of the output pin on initialization. HIGH voltage defined as true and LOW voltage defined as false.\n Updated on 2022-05-15 at 12:08:46 +0000\n","description":"","tags":null,"title":"embed::output_pin::settings","uri":"/libembeddedhal/api/classes/structembed_1_1output__pin_1_1settings/"},{"content":"embed::overflow_counter Class Reference\nExtend a counter’s count from an arbitrary bit width to 64-bits by detecting overflows in the count. Each detected overflow is added to an overflow counter which is combined with the current count in order create a count up to 64-bits in length. More…\n#include \u003coverflow_counter.hpp\u003e\nPublic Functions     Name     constexpr uint64_t update(uint32_t p_new_count)update the overflow counter, detect if an overflow has occurred, and return the combined   constexpr void reset()Reset the overflow count back to zero.    Detailed Description template \u003csize_t CountBitWidth =32\u003e class embed::overflow_counter; Extend a counter’s count from an arbitrary bit width to 64-bits by detecting overflows in the count. Each detected overflow is added to an overflow counter which is combined with the current count in order create a count up to 64-bits in length.\nTemplate Parameters:\n CountBitWidth - the bit width of the counter before the count value overflows.  Public Functions Documentation function update inline constexpr uint64_t update(  uint32_t p_new_count ) update the overflow counter, detect if an overflow has occurred, and return the combined\nParameters:\n p_new_count - must be an increasing value and should only decrease when an overflow event occurs.  Return: constexpr uint64_t - 64-bit count combining the new count value and the overflow count value.\nfunction reset inline constexpr void reset() Reset the overflow count back to zero.\n Updated on 2022-05-15 at 12:08:46 +0000\n","description":"","tags":null,"title":"embed::overflow_counter","uri":"/libembeddedhal/api/classes/classembed_1_1overflow__counter/"},{"content":"embed::percent Class Reference\nA integer representation of a percentage. More…\n#include \u003cpercent.hpp\u003e\nPublic Types     Name     using std::int32_t int_t The representation of the percentage will be contained within this type.   using std::int64_t overflow_t    Public Functions     Name     constexpr overflow_t raw_max()Get the 100% value in its raw representation.   constexpr overflow_t raw_min()Get the -100% value in its raw representation.   constexpr overflow_t raw_zero()Get the 0% value in its raw representation.   template \u003csize_t BitWidth,std::integral T\u003e constexpr percent convert(T p_value)Convert a fixed width integer value into a percentage based on its distance to the end of its bit width.   template \u003cstd::integral T\u003e constexpr percent from_ratio(T p_progress, T p_maximum)Generate a percentage based on input relative to the maximum possible value.   constexpr percent()Construct 0% percent object.   constexpr percent(std::floating_point auto p_ratio)Construct a percent based on a floating point percentage value.   constexpr auto operator\u003c=\u003e(const percent \u0026 ) const =defaultDefault operators for \u003c, \u003c=, \u003e, \u003e= and ==.   constexpr percent \u0026 operator=(std::floating_point auto p_ratio)Assignment operator for a percent object based on a floating point value.   constexpr auto raw_value() constGet raw integral value.   template \u003cstd::floating_point T\u003e constexpr T to() constConvert percent to a floating point representation.    operator float() constexplicit cast to float.    operator double() constexplicit cast to double.   auto to_string() constconvert this percentage value into a string from -1.0 to +1.0    Friends     Name     constexpr friend auto operator*(T p_value, percent p_scale) Scale an integral value by a percent value.   constexpr friend auto operator*(percent p_scale, T p_value) Same as operator*(U p_value, percent p_scale)    Detailed Description class embed::percent; A integer representation of a percentage.\nPrimary usage is representing numbers with a arbitrary bit-resolution and up scaling them to higher bit resolutions while retaining their proportionality.\nFor example, if a device has an 10-bit unsigned ADC, its range of possible output is 0 to 1024. If a device driver requires an ADC, that driver will need to know the ADC value and the bit resolution in order to deterimine where the decimal number fits within the range of the ADC. percent eliminates this by upscaling all numbers to uint32_t or int32_t and keeping the proportion within the range the same. So 512 out of 1024 is 50% and this class will preserve that 50% value proportional value but within a 32-bit integer.\nPublic Types Documentation using int_t using embed::percent::int_t = std::int32_t; The representation of the percentage will be contained within this type.\nusing overflow_t using embed::percent::overflow_t = std::int64_t; The overflow type must be 2x the size of int_t in order to perform multiplication against two int_t value and not lose any data.\nPublic Functions Documentation function raw_max static inline constexpr overflow_t raw_max() Get the 100% value in its raw representation.\nReturn: constexpr overflow_t - maximum limit of int_t\nfunction raw_min static inline constexpr overflow_t raw_min() Get the -100% value in its raw representation.\nReturn: constexpr overflow_t - minimum limit of int_t\nfunction raw_zero static inline constexpr overflow_t raw_zero() Get the 0% value in its raw representation.\nReturn: constexpr overflow_t - 0 value for int_t\nfunction convert template \u003csize_t BitWidth, std::integral T\u003e static inline constexpr percent convert(  T p_value ) Convert a fixed width integer value into a percentage based on its distance to the end of its bit width.\nParameters:\n p_value - the value of the number  Template Parameters:\n BitWidth - The bit width of the input value T - integral type of input value  Return: constexpr percent - the percent type based on the input value’s distance to the end of the bit width.\nfunction from_ratio template \u003cstd::integral T\u003e static inline constexpr percent from_ratio(  T p_progress,  T p_maximum ) Generate a percentage based on input relative to the maximum possible value.\nParameters:\n p_progress - the number in which a percentage will be generated relative to how close the value is to the p_maximum value. This value can be considered the numerator of a rational number where the denominator is p_maximum. The result will be clamped if the input is above the maximum value. p_maximum - the absolute maximum value of the ratio and the indicator of 100% and -100% progress. Can consider this value as a denominator of a ration number.  Template Parameters:\n T - integral types for the numerator and denominator  Return: constexpr percent\nThe output will be clamped to -100% and 100% if the input value is above or below the constraints of the maximum.\nExamples:\nTo generate 50%, use embed::percent::from_ratio(1, 2); To generate 50%, use embed::percent::from_ratio(50, 100); To generate 50%, use embed::percent::from_ratio(250, 500); To generate 20%, use embed::percent::from_ratio(20, 100); To generate 14%, use embed::percent::from_ratio(35, 250);\nfunction percent inline constexpr percent() Construct 0% percent object.\nfunction percent inline constexpr percent(  std::floating_point auto p_ratio ) Construct a percent based on a floating point percentage value.\nParameters:\n p_ratio - floating point ratio value. For signed numbers this is clamped between 0.0 and 1.0. For signed numbers it is clamped between -1.0 to 1.0.  function operator\u003c=\u003e constexpr auto operator\u003c=\u003e(  const percent \u0026 ) const =default Default operators for \u003c, \u003c=, \u003e, \u003e= and ==.\nReturn: auto - result of the comparison\nfunction operator= inline constexpr percent \u0026 operator=(  std::floating_point auto p_ratio ) Assignment operator for a percent object based on a floating point value.\nParameters:\n p_ratio - floating point ratio value. For signed numbers this is clamped between 0.0 and 1.0. For signed numbers it is clamped between -1.0 to 1.0.  Return: constexpr percent\u0026 - integer percent object based on the floating point percent value.\nfunction raw_value inline constexpr auto raw_value() const Get raw integral value.\nReturn: T - percent value\nfunction to template \u003cstd::floating_point T\u003e inline constexpr T to() const Convert percent to a floating point representation.\nTemplate Parameters:\n T - floating point type  Return: constexpr T - float representation of the percentage between 0.0f and 1.0f.\nfunction operator float inline explicit operator float() const explicit cast to float.\nReturn: float - float representation of the percentage between 0.0f and 1.0f.\nfunction operator double inline explicit operator double() const explicit cast to double.\nReturn: double - double representation of the percentage between 0.0 and 1.0\nfunction to_string inline auto to_string() const convert this percentage value into a string from -1.0 to +1.0\nReturn: auto - string representation of the percent.\nStrings are computed using integer arithmetic only.\nThe format of the string will follow these rules:\n  Will always have a leading + or - sign\n  Will always be 13 characters where the last character is the ‘\\0’\n  Will start with either a ‘1’ or a ‘0’ character Example string:\n  +1.000000000\n  +0.250000000\n  +0.125000000\n  -0.333333333\n  -0.111111111\n  -0.666666667\n  Friends friend operator* friend constexpr friend auto operator*(  T p_value,   percent p_scale ); Scale an integral value by a percent value.\nParameters:\n p_value - value to be scaled p_scale - value scalar  Template Parameters:\n T - type of the integral value to be scaled  Return: auto - the scaled down result of p_value * p_scale.\nReturns a scaled down version of the input value. For example if the input is 100 and the scale value represents a percentage of 50%, then performing the following operation: 100 * percent_50_percent is equivalent to 100 * 0.5f.\nfriend operator* friend constexpr friend auto operator*(  percent p_scale,   T p_value ); Same as operator*(U p_value, percent p_scale)\nParameters:\n p_scale - see other operator* p_value - see other operator*  Template Parameters:\n T - see other operator*  Return: constexpr auto - see other operator*\n Updated on 2022-05-15 at 12:08:46 +0000\n","description":"","tags":null,"title":"embed::percent","uri":"/libembeddedhal/api/classes/classembed_1_1percent/"},{"content":"embed::pwm Class Reference\nPulse Width Modulation (PWM) channel hardware abstraction.\n#include \u003cpwm.hpp\u003e\nInherited by embed::mock::pwm\nPublic Classes     Name     struct settings    Public Functions     Name     boost::leaf::result\u003c void \u003e configure(const settings \u0026 p_settings)Configure pwm to match the settings supplied.   boost::leaf::result\u003c void \u003e duty_cycle(percent p_duty_cycle)Set the duty cycle percentage.    Public Functions Documentation function configure inline boost::leaf::result\u003c void \u003e configure(  const settings \u0026 p_settings ) Configure pwm to match the settings supplied.\nParameters:\n p_settings - settings to apply to pwm driver  Return: boost::leaf::result- any error that occurred during this operation. Will return embed::error::invalid_settings if the settings could not be achieved.\nfunction duty_cycle inline boost::leaf::result\u003c void \u003e duty_cycle(  percent p_duty_cycle ) Set the duty cycle percentage.\nParameters:\n p_duty_cycle - set the duty cycle of the pwm.  Return: boost::leaf::result- any error that occurred during this operation.\n Updated on 2022-05-15 at 12:08:46 +0000\n","description":"","tags":null,"title":"embed::pwm","uri":"/libembeddedhal/api/classes/classembed_1_1pwm/"},{"content":"embed::pwm::settings Struct Reference\nMore…\n#include \u003cpwm.hpp\u003e\nPublic Functions     Name     constexpr auto operator\u003c=\u003e(const settings \u0026 ) const =defaultDefault operators for \u003c, \u003c=, \u003e, \u003e= and ==.    Public Attributes     Name     embed::frequency frequency The target channel PWM frequency.    Detailed Description struct embed::pwm::settings; Generic settings for a hardware Pulse Width Modulation (PWM) generating devices devices.\nPublic Functions Documentation function operator\u003c=\u003e constexpr auto operator\u003c=\u003e(  const settings \u0026 ) const =default Default operators for \u003c, \u003c=, \u003e, \u003e= and ==.\nReturn: auto - result of the comparison\nPublic Attributes Documentation variable frequency embed::frequency frequency = embed::frequency(1'000); The target channel PWM frequency.\n Updated on 2022-05-15 at 12:08:46 +0000\n","description":"","tags":null,"title":"embed::pwm::settings","uri":"/libembeddedhal/api/classes/structembed_1_1pwm_1_1settings/"},{"content":"embed::serial Class Reference\nSerial communication protocol hardware abstract interface. More…\n#include \u003cserial.hpp\u003e\nInherited by embed::stub::serial\nPublic Classes     Name     struct frame_error Error type indicating that a frame error occurred during reception. This error is returned when calling bytes_available().   struct packets_lost Error indicating that packets were lost during reception. This occurs when the buffer is overrun and reaches the end of the circular buffer. This error is returned when calling bytes_available().   struct parity_error Error type indicating that a parity error occurred during reception. This error is returned when calling bytes_available().   struct settings Generic settings for a standard serial device.    Public Functions     Name     boost::leaf::result\u003c void \u003e configure(const settings \u0026 p_settings)Configure serial to match the settings supplied.   boost::leaf::result\u003c void \u003e write(std::span\u003c const std::byte \u003e p_data)Write data on the transmitter line of the port. This function will block until the entire transfer is finished.   boost::leaf::result\u003c size_t \u003e bytes_available()The number of bytes that have been buffered. For frames less than 8-bits, each byte holds a frame. For frames above 8-bits the number of bytes returned indicates the number of bytes a buffer needs to be to return all of the data held in the buffer.   boost::leaf::result\u003c std::span\u003c const std::byte \u003e \u003e read(std::span\u003c std::byte \u003e p_data)Read the bytes received over the ports receiver line and stored in the serial implementations buffer. The number of bytes read will subtract the number of bytes available until it reaches zero.   boost::leaf::result\u003c void \u003e flush()Set bytes_available() to zero and clear any received data stored in hardware registers.    Detailed Description class embed::serial; Serial communication protocol hardware abstract interface.\nUse this interface for hardware that implements a serial protocol like UART, RS232, RS485 and many others that use a similar communication protocol but may use different voltage schemes.\nDue to the asynchronous nature of serial communication protocols, all implementations of serial devices MUST buffer received bytes using DMA or interrupts. A thread should not be used as this generally greatly increases the ROM and RAM cost of using library.\nAll implementations MUST allow the user to supply their own buffer of arbitrary size, such that the amount of buffered data can be tailored to the needs of the application.\nPublic Functions Documentation function configure inline boost::leaf::result\u003c void \u003e configure(  const settings \u0026 p_settings ) Configure serial to match the settings supplied.\nParameters:\n p_settings - settings to apply to serial driver  Return: boost::leaf::result- any error that occurred during this operation. Will return embed::error::invalid_settings if the settings could not be achieved.\nfunction write inline boost::leaf::result\u003c void \u003e write(  std::span\u003c const std::byte \u003e p_data ) Write data on the transmitter line of the port. This function will block until the entire transfer is finished.\nParameters:\n p_data - data to be transmitted over the serial port transmitter line  Return: boost::leaf::result- any error that occurred during this operation.\nData frames are not compact when frame size is less than 8 bits. Meaning that, if you want to send three 5-bit frames, then you will need to use a span of at least 3 bytes to hold each value.\nWhen writing data with frame size greater than 8 is in little endian order. Meaning that the first byte in the sequence is the lower byte and the next is the greater byte. If you wanted to send a 9-bit frame with value 0x14A, the first byte must be 0x4A and the next 0x01.\nserial ports will report transmit_error will an error occurs. Any other reported error will bubble up come from\nfunction bytes_available inline boost::leaf::result\u003c size_t \u003e bytes_available() The number of bytes that have been buffered. For frames less than 8-bits, each byte holds a frame. For frames above 8-bits the number of bytes returned indicates the number of bytes a buffer needs to be to return all of the data held in the buffer.\nReturn: boost::leaf::result\u003csize_t\u003e - number of buffered by the serial driver and are available to be read by the read() function.\nfunction read inline boost::leaf::result\u003c std::span\u003c const std::byte \u003e \u003e read(  std::span\u003c std::byte \u003e p_data ) Read the bytes received over the ports receiver line and stored in the serial implementations buffer. The number of bytes read will subtract the number of bytes available until it reaches zero.\nParameters:\n p_data - Buffer to read bytes back from. If the length of this buffer is greater than the value returned by bytes_available() then buffer is filled up to the length returned by bytes_available(). The rest of the buffer is left untouched.  Return: boost::leaf::result\u003cstd::span\u003e - provides a means to get the length of bytes read into the buffer p_data. The address will ALWAYS be the same as p_data and the length will be equal to the number of bytes read from the buffer.\nfunction flush inline boost::leaf::result\u003c void \u003e flush() Set bytes_available() to zero and clear any received data stored in hardware registers.\nReturn: boost::leaf::result- any error that occurred during this operation.\n Updated on 2022-05-15 at 12:08:46 +0000\n","description":"","tags":null,"title":"embed::serial","uri":"/libembeddedhal/api/classes/classembed_1_1serial/"},{"content":"embed::serial::frame_error Struct Reference\nError type indicating that a frame error occurred during reception. This error is returned when calling bytes_available(). More…\n#include \u003cserial.hpp\u003e\nPublic Attributes     Name     size_t bytes_available The number of bytes the serial port has buffered up.    Detailed Description struct embed::serial::frame_error; Error type indicating that a frame error occurred during reception. This error is returned when calling bytes_available().\nHow to handle these errors:\n In general, the exact nature of a specific frame error is not knowable. The number of bytes that are effected could be 1 or more, thus the only real way to handle this is to flush receive buffer and attempt reception again. Note that the read function should still work to read out which ever bytes were received and this can be used/logged in order for developers to get insight into where the error occurred and how to fix it.  Public Attributes Documentation variable bytes_available size_t bytes_available; The number of bytes the serial port has buffered up.\n Updated on 2022-05-15 at 12:08:46 +0000\n","description":"","tags":null,"title":"embed::serial::frame_error","uri":"/libembeddedhal/api/classes/structembed_1_1serial_1_1frame__error/"},{"content":"embed::serial::packets_lost Struct Reference\nError indicating that packets were lost during reception. This occurs when the buffer is overrun and reaches the end of the circular buffer. This error is returned when calling bytes_available(). More…\n#include \u003cserial.hpp\u003e\nPublic Attributes     Name     std::optional\u003c size_t \u003e packets_dropped   size_t bytes_available The number of bytes the serial port has buffered up.    Detailed Description struct embed::serial::packets_lost; Error indicating that packets were lost during reception. This occurs when the buffer is overrun and reaches the end of the circular buffer. This error is returned when calling bytes_available().\nHow to handle these errors:\n This sort of error is very context heavy. If the packet lengths are short and numerous and with a consistent format, then the application may be able to pull out all but the last few packets of data from the buffer and treat the ones at the end as lost packets. In most other cases where data lost was crucial, then the whole buffer may need to be flushed and the data received again. A way to fix this is to enlarge the receive buffer. This can be done with dynamic memory allocation, but generally, its better to simply increase the buffer size by updating the application rather than growing with need.  Public Attributes Documentation variable packets_dropped std::optional\u003c size_t \u003e packets_dropped; The number of packets dropped. This value is optional because some drivers cannot provide a number for the number of packets dropped.\nvariable bytes_available size_t bytes_available; The number of bytes the serial port has buffered up.\n Updated on 2022-05-15 at 12:08:46 +0000\n","description":"","tags":null,"title":"embed::serial::packets_lost","uri":"/libembeddedhal/api/classes/structembed_1_1serial_1_1packets__lost/"},{"content":"embed::serial::parity_error Struct Reference\nError type indicating that a parity error occurred during reception. This error is returned when calling bytes_available(). More…\n#include \u003cserial.hpp\u003e\nPublic Attributes     Name     size_t bytes_available The number of bytes the serial port has buffered up.    Detailed Description struct embed::serial::parity_error; Error type indicating that a parity error occurred during reception. This error is returned when calling bytes_available().\nHow to handle these errors:\n The nature of this error is almost exactly the same as frame_error. See frame_error’s description on how to handle this.  Public Attributes Documentation variable bytes_available size_t bytes_available; The number of bytes the serial port has buffered up.\n Updated on 2022-05-15 at 12:08:46 +0000\n","description":"","tags":null,"title":"embed::serial::parity_error","uri":"/libembeddedhal/api/classes/structembed_1_1serial_1_1parity__error/"},{"content":"embed::serial::settings Struct Reference\nGeneric settings for a standard serial device.\n#include \u003cserial.hpp\u003e\nPublic Types     Name     enum class uint8_t stop_bits { one = 0, two}Set of available stop bits options.   enum class uint8_t parity { none = 0, odd, even, forced1, forced0}Set of parity bit options.    Public Attributes     Name     uint32_t baud_rate The operating speed of the baud rate (in units of bits per second)   parity parity Parity bit type for each frame.   stop_bits stop Number of stop bits for each frame.   uint8_t frame_size Number of bits in each frame. Typically between 5 to 9.    Public Types Documentation enum stop_bits    Enumerator Value Description     one 0    two      Set of available stop bits options.\nenum parity    Enumerator Value Description     none 0 Disable parity bit as part of the frame.   odd  Enable parity and set 1 (HIGH) when the number of bits is odd.   even  Enable parity and set 1 (HIGH) when the number of bits is even.   forced1  Enable parity bit and always return 1 (HIGH) for ever frame.   forced0  Enable parity bit and always return 0 (LOW) for ever frame.    Set of parity bit options.\nPublic Attributes Documentation variable baud_rate uint32_t baud_rate = 115200; The operating speed of the baud rate (in units of bits per second)\nvariable parity parity parity = parity::none; Parity bit type for each frame.\nvariable stop stop_bits stop = stop_bits::one; Number of stop bits for each frame.\nvariable frame_size uint8_t frame_size = 8; Number of bits in each frame. Typically between 5 to 9.\n Updated on 2022-05-15 at 12:08:46 +0000\n","description":"","tags":null,"title":"embed::serial::settings","uri":"/libembeddedhal/api/classes/structembed_1_1serial_1_1settings/"},{"content":"embed::spi Class Reference\nSerial peripheral interface (SPI) communication protocol hardware abstract interface.\n#include \u003cspi.hpp\u003e\nInherited by embed::mock::write_only_spi, embed::stub::spi\nPublic Classes     Name     struct settings Generic settings for a standard SPI device.    Public Functions     Name     boost::leaf::result\u003c void \u003e configure(const settings \u0026 p_settings)Configure spi to match the settings supplied.   boost::leaf::result\u003c void \u003e transfer(std::span\u003c const std::byte \u003e p_data_out, std::span\u003c std::byte \u003e p_data_in, std::byte p_filler =default_filler) =defaultSend and receieve data between a selected device on the spi bus. This function will block until the entire transfer is finished.    Public Attributes     Name     constexpr std::byte default_filler    Public Functions Documentation function configure inline boost::leaf::result\u003c void \u003e configure(  const settings \u0026 p_settings ) Configure spi to match the settings supplied.\nParameters:\n p_settings - settings to apply to spi  Return: boost::leaf::result- any error that occurred during this operation. Will return embed::error::invalid_settings if the settings could not be achieved.\nfunction transfer inline boost::leaf::result\u003c void \u003e transfer(  std::span\u003c const std::byte \u003e p_data_out,  std::span\u003c std::byte \u003e p_data_in,  std::byte p_filler =default_filler ) =default Send and receieve data between a selected device on the spi bus. This function will block until the entire transfer is finished.\nParameters:\n p_data_out - buffer to write data to the bus. If this is set to null/empty then writing is ignored and the p_filler will be written to the bus. If the length is less than p_data_in, then p_filler will be written to the bus after this buffer has been sent. p_data_in - buffer to read the data off of the bus. If this is null/empty, then the transfer will be write only and the incoming data will be ignored. If the length of this buffer is less than p_data_out, once this buffer has been filled, the rest of the received bytes on the bus will be dropped. p_filler - filler data placed on the bus in place of actual write data when p_data_out has been exhausted.  Return: boost::leaf::result- any error that occurred during this operation.\nPublic Attributes Documentation variable default_filler static constexpr std::byte default_filler = std::byte{ 0xFF }; Default filler data placed on the bus in place of actual write data when the write buffer has been exhausted.\n Updated on 2022-05-15 at 12:08:46 +0000\n","description":"","tags":null,"title":"embed::spi","uri":"/libembeddedhal/api/classes/classembed_1_1spi/"},{"content":"embed::spi::settings Struct Reference\nGeneric settings for a standard SPI device.\n#include \u003cspi.hpp\u003e\nPublic Functions     Name     constexpr auto operator\u003c=\u003e(const settings \u0026 ) const =defaultDefault operators for \u003c, \u003c=, \u003e, \u003e= and ==.    Public Attributes     Name     frequency clock_rate Serial clock frequency.   bool clock_idles_high The polarity of the pins when the signal is idle.   bool data_valid_on_trailing_edge The phase of the clock signal when communicating.    Public Functions Documentation function operator\u003c=\u003e constexpr auto operator\u003c=\u003e(  const settings \u0026 ) const =default Default operators for \u003c, \u003c=, \u003e, \u003e= and ==.\nReturn: auto - result of the comparison\nPublic Attributes Documentation variable clock_rate frequency clock_rate = default_clock_rate; Serial clock frequency.\nvariable clock_idles_high bool clock_idles_high = false; The polarity of the pins when the signal is idle.\nvariable data_valid_on_trailing_edge bool data_valid_on_trailing_edge = false; The phase of the clock signal when communicating.\n Updated on 2022-05-15 at 12:08:46 +0000\n","description":"","tags":null,"title":"embed::spi::settings","uri":"/libembeddedhal/api/classes/structembed_1_1spi_1_1settings/"},{"content":"embed::spy_handler Class Reference\nHelper utility for making mocks for class functions that return boost::leaf::result. More…\n#include \u003ctesting.hpp\u003e\nPublic Functions     Name     void trigger_error_on_call(int p_call_count_before_trigger)Set the record function to return an error after a specified number of recordings.   boost::leaf::result\u003c void \u003e record(args_t… p_args)Record the arguments of a function being spied on.   const auto \u0026 call_history() constReturn the call history of the save function.   void reset()Reset call recordings and turns off error trigger.    Detailed Description template \u003ctypename... args_t\u003e class embed::spy_handler; Helper utility for making mocks for class functions that return boost::leaf::result.\nTemplate Parameters:\n args_t - the arguments of the class function  This class stores records of a functions call history in order to be recovered later for inspection in tests and simulations.\nSee [pwm_mock.hpp] and tests/pwm_mock.test.cpp as an example of how this is done in practice.\nPublic Functions Documentation function trigger_error_on_call inline void trigger_error_on_call(  int p_call_count_before_trigger ) Set the record function to return an error after a specified number of recordings.\nParameters:\n p_call_count_before_trigger - how many calls before an error is returned.  function record inline boost::leaf::result\u003c void \u003e record(  args_t... p_args ) Record the arguments of a function being spied on.\nParameters:\n p_args - arguments to record  Return: boost::leaf::result- returns success or an error if the error trigger has been reached.\nfunction call_history inline const auto \u0026 call_history() const Return the call history of the save function.\nReturn: const auto\u0026 - reference to the call history vector\nfunction reset inline void reset() Reset call recordings and turns off error trigger.\n Updated on 2022-05-15 at 12:08:46 +0000\n","description":"","tags":null,"title":"embed::spy_handler","uri":"/libembeddedhal/api/classes/classembed_1_1spy__handler/"},{"content":"embed::static_callable Class Reference\nGeneral class which will be used to allow for signature to be used and then split by the below class. More…\nDetailed Description template \u003cclass owner_class , int reference_designator, typename signature \u003e class embed::static_callable; General class which will be used to allow for signature to be used and then split by the below class.\nTemplate Parameters:\n owner_class class that this static callable belongs to reference_designator this template argument is used to generate unique static objects for each needed callback signature function signature to be split up in the static_callable specialization   Updated on 2022-05-15 at 12:08:46 +0000\n","description":"","tags":null,"title":"embed::static_callable","uri":"/libembeddedhal/api/classes/classembed_1_1static__callable/"},{"content":"embed::static_callable\u003c owner_class, reference_designator, return_t(args_t… p_args)\u003e Class Reference\nSpecialization of static_callable with the return type and arguments split up. More…\n#include \u003cstatic_callable.hpp\u003e\nPublic Functions     Name      static_callable(std::function\u003c return_t(args_t… p_args)\u003e p_callback)Construct a new static callable object.   auto * get_handler()Get the static function’s address.    Detailed Description template \u003cclass owner_class , int reference_designator, typename return_t , typename... args_t\u003e class embed::static_callable\u003c owner_class, reference_designator, return_t(args_t... p_args)\u003e; Specialization of static_callable with the return type and arguments split up.\nTemplate Parameters:\n owner_class see static_callable reference_designator see static_callable return_t function’s return type args_t function’s set of arguments  Public Functions Documentation function static_callable inline static_callable(  std::function\u003c return_t(args_t... p_args)\u003e p_callback ) Construct a new static callable object.\nParameters:\n p_callback - when the static callback function is called, it will call this callback  function get_handler inline auto * get_handler() Get the static function’s address.\nReturn: auto* - static function’s address\n Updated on 2022-05-15 at 12:08:46 +0000\n","description":"","tags":null,"title":"embed::static_callable\u003c owner_class, reference_designator, return_t(args_t... p_args)\u003e","uri":"/libembeddedhal/api/classes/classembed_1_1static__callable_3_01owner__class_00_01reference__designator_00_01return__t_07args__t_8_8_8_01p__args_08_4/"},{"content":"embed::static_memory_resource Class Reference\nThe static_memory_resource is the polymorphic memory resource allocator that allows libembeddedhal’s libraries to use a C++ standard container such as std::pmr::vector, std::pmr::string, std::pmr::unordered_map, and more without requiring dynamic memory allocation from the heap. It provides a simple way to create an allocator with built in storage, with its size indicated by a single template parameter. It also provides statistics regarding the amount of memory allocated such that developers can determine if they need to reduce or increase the size of the buffer. Memory statistics can also give programs the insight into how much memory space is available and make decisions based on that. In the event that the memory of the static allocator is exceeded, a std::bad_alloc excpetion is thrown. More…\n#include \u003cstatic_memory_resource.hpp\u003e\nInherits from std::pmr::memory_resource\nPublic Functions     Name      static_memory_resource()   constexpr std::size_t capacity() const   std::size_t memory_used() const   int memory_available() const    Protected Functions     Name     void * do_allocate(std::size_t p_bytes, std::size_t p_alignment) overrideImplementation of the do_allocate() method for std::pmr::memory_resource.   void do_deallocate(void * p_address, std::size_t p_bytes, std::size_t p_alignment) overrideImplementation of the do_deallocate() method for std::pmr::memory_resource.   bool do_is_equal(const std::pmr::memory_resource \u0026 p_other) const overrideImplementation of the do_is_equal() method for std::pmr::memory_resource.    Detailed Description template \u003csize_t BufferSize\u003e class embed::static_memory_resource; The static_memory_resource is the polymorphic memory resource allocator that allows libembeddedhal’s libraries to use a C++ standard container such as std::pmr::vector, std::pmr::string, std::pmr::unordered_map, and more without requiring dynamic memory allocation from the heap. It provides a simple way to create an allocator with built in storage, with its size indicated by a single template parameter. It also provides statistics regarding the amount of memory allocated such that developers can determine if they need to reduce or increase the size of the buffer. Memory statistics can also give programs the insight into how much memory space is available and make decisions based on that. In the event that the memory of the static allocator is exceeded, a std::bad_alloc excpetion is thrown.\nTemplate Parameters:\n BufferSize - number of bytes to statically allocate for the memory resource.  USAGE:\n// Make a memory resource with 1kB buffer static_memory_resource\u003c1024\u003e memory_resource; std::pmr::unordered_map\u003cint, const char*\u003e id_name_map(\u0026memory_resource);\nPublic Functions Documentation function static_memory_resource inline static_memory_resource() function capacity inline constexpr std::size_t capacity() const Return: constexpr std::size_t - the total number of bytes that this allocator can allocate before throwing a std::bad_alloc exception.\nfunction memory_used inline std::size_t memory_used() const Return: std::size_t - number of bytes that have already been allocated.\nfunction memory_available inline int memory_available() const Return: int - Bytes that have yet to be allocated from this allocator.\nProtected Functions Documentation function do_allocate inline void * do_allocate(  std::size_t p_bytes,  std::size_t p_alignment ) override Implementation of the do_allocate() method for std::pmr::memory_resource.\nParameters:\n p_bytes - number of bytes to allocate p_alignment - alignment limit for the allocation  Return: void* - address of the newly allocated buffer\nfunction do_deallocate inline void do_deallocate(  void * p_address,  std::size_t p_bytes,  std::size_t p_alignment ) override Implementation of the do_deallocate() method for std::pmr::memory_resource.\nParameters:\n p_address - address of space to be deallocated p_bytes - number of bytes to allocate p_alignment - alignment limit for the allocation  function do_is_equal inline bool do_is_equal(  const std::pmr::memory_resource \u0026 p_other ) const override Implementation of the do_is_equal() method for std::pmr::memory_resource.\nParameters:\n p_other - another memory resource to  Return:\n true - are equal false - are not equal   Updated on 2022-05-15 at 12:08:46 +0000\n","description":"","tags":null,"title":"embed::static_memory_resource","uri":"/libembeddedhal/api/classes/classembed_1_1static__memory__resource/"},{"content":"embed::stub Namespace Reference\nClasses     Name     class embed::stub::adc A stub implementation of embed::adc to be used as a placeholder for drivers that require an optional adc. Calling read() will return the percent variable that is configured in the constructor. This implementaion should only be used when a driver has stated in its documentation that the adc is optional and can be stubbed out.   class embed::stub::dac A stub implementation of embed::dac to be used as a placeholder for drivers that require an optional dac. This implementation should only be used when a driver has stated in its documentation that the dac is optional and can be stubbed out.   class embed::stub::serial   class embed::stub::spi A stub implementation of embed::spi to be used as a placeholder for drivers that require an optional spi interface. This implementation should only be used when a driver has stated in its documentation that the spi interface is optional and can be stubbed out.   class embed::stub::timer A stub implementation of embed::timer to be used as a placeholder for drivers that require an optional timer. Calling clear() will make is_running() return false, calling schedule() will make is_running() return true.     Updated on 2022-05-15 at 12:08:46 +0000\n","description":"","tags":null,"title":"embed::stub","uri":"/libembeddedhal/api/namespaces/namespaceembed_1_1stub/"},{"content":"embed::stub::adc Class Reference\nA stub implementation of embed::adc to be used as a placeholder for drivers that require an optional adc. Calling read() will return the percent variable that is configured in the constructor. This implementaion should only be used when a driver has stated in its documentation that the adc is optional and can be stubbed out.\n#include \u003cadc_stub.hpp\u003e\nInherits from embed::adc\nPublic Functions     Name      adc(embed::percent p_adc_value)Construct a new adc object.    Additional inherited members Public Functions inherited from embed::adc\n    Name     boost::leaf::result\u003c percent \u003e read()Read a sample from the analog to digital converter.    Public Functions Documentation function adc inline adc(  embed::percent p_adc_value ) Construct a new adc object.\nParameters:\n p_adc_value - percent value for adc   Updated on 2022-05-15 at 12:08:46 +0000\n","description":"","tags":null,"title":"embed::stub::adc","uri":"/libembeddedhal/api/classes/classembed_1_1stub_1_1adc/"},{"content":"embed::stub::dac Class Reference\nA stub implementation of embed::dac to be used as a placeholder for drivers that require an optional dac. This implementation should only be used when a driver has stated in its documentation that the dac is optional and can be stubbed out.\n#include \u003cdac_stub.hpp\u003e\nInherits from embed::dac\nAdditional inherited members Public Functions inherited from embed::dac\n    Name     boost::leaf::result\u003c void \u003e write(percent p_value)Generate a voltage between a defined LOW and HIGH voltage.     Updated on 2022-05-15 at 12:08:46 +0000\n","description":"","tags":null,"title":"embed::stub::dac","uri":"/libembeddedhal/api/classes/classembed_1_1stub_1_1dac/"},{"content":"embed::stub::serial Class Reference\nMore…\n#include \u003cserial_stub.hpp\u003e\nInherits from embed::serial\nAdditional inherited members Public Classes inherited from embed::serial\n    Name     struct frame_error Error type indicating that a frame error occurred during reception. This error is returned when calling bytes_available().   struct packets_lost Error indicating that packets were lost during reception. This occurs when the buffer is overrun and reaches the end of the circular buffer. This error is returned when calling bytes_available().   struct parity_error Error type indicating that a parity error occurred during reception. This error is returned when calling bytes_available().   struct settings Generic settings for a standard serial device.    Public Functions inherited from embed::serial\n    Name     boost::leaf::result\u003c void \u003e configure(const settings \u0026 p_settings)Configure serial to match the settings supplied.   boost::leaf::result\u003c void \u003e write(std::span\u003c const std::byte \u003e p_data)Write data on the transmitter line of the port. This function will block until the entire transfer is finished.   boost::leaf::result\u003c size_t \u003e bytes_available()The number of bytes that have been buffered. For frames less than 8-bits, each byte holds a frame. For frames above 8-bits the number of bytes returned indicates the number of bytes a buffer needs to be to return all of the data held in the buffer.   boost::leaf::result\u003c std::span\u003c const std::byte \u003e \u003e read(std::span\u003c std::byte \u003e p_data)Read the bytes received over the ports receiver line and stored in the serial implementations buffer. The number of bytes read will subtract the number of bytes available until it reaches zero.   boost::leaf::result\u003c void \u003e flush()Set bytes_available() to zero and clear any received data stored in hardware registers.    Detailed Description class embed::stub::serial; A stub implementation of embed::serial to be used as a placeholder for drivers that require an optional serial port. This implementation should only be used when a driver has stated in its documentation that the serial port is optional and can be stubbed out.\n Updated on 2022-05-15 at 12:08:46 +0000\n","description":"","tags":null,"title":"embed::stub::serial","uri":"/libembeddedhal/api/classes/classembed_1_1stub_1_1serial/"},{"content":"embed::stub::spi Class Reference\nA stub implementation of embed::spi to be used as a placeholder for drivers that require an optional spi interface. This implementation should only be used when a driver has stated in its documentation that the spi interface is optional and can be stubbed out.\n#include \u003cspi_stub.hpp\u003e\nInherits from embed::spi\nAdditional inherited members Public Classes inherited from embed::spi\n    Name     struct settings Generic settings for a standard SPI device.    Public Functions inherited from embed::spi\n    Name     boost::leaf::result\u003c void \u003e configure(const settings \u0026 p_settings)Configure spi to match the settings supplied.   boost::leaf::result\u003c void \u003e transfer(std::span\u003c const std::byte \u003e p_data_out, std::span\u003c std::byte \u003e p_data_in, std::byte p_filler =default_filler) =defaultSend and receieve data between a selected device on the spi bus. This function will block until the entire transfer is finished.    Public Attributes inherited from embed::spi\n    Name     constexpr std::byte default_filler     Updated on 2022-05-15 at 12:08:46 +0000\n","description":"","tags":null,"title":"embed::stub::spi","uri":"/libembeddedhal/api/classes/classembed_1_1stub_1_1spi/"},{"content":"embed::stub::timer Class Reference\nA stub implementation of embed::timer to be used as a placeholder for drivers that require an optional timer. Calling clear() will make is_running() return false, calling schedule() will make is_running() return true.\n#include \u003ctimer_stub.hpp\u003e\nInherits from embed::timer\nAdditional inherited members Public Classes inherited from embed::timer\n    Name     struct out_of_bounds Error type indicating that the desired time delay is not achievable with this timer.    Public Functions inherited from embed::timer\n    Name     boost::leaf::result\u003c bool \u003e is_running()Determine if the timer is currently running.   boost::leaf::result\u003c void \u003e clear()Stops a scheduled event from happening.   boost::leaf::result\u003c void \u003e schedule(std::function\u003c void(void)\u003e p_callback, std::chrono::nanoseconds p_delay)Schedule an callback to be called at a designated time/interval.     Updated on 2022-05-15 at 12:08:46 +0000\n","description":"","tags":null,"title":"embed::stub::timer","uri":"/libembeddedhal/api/classes/classembed_1_1stub_1_1timer/"},{"content":"embed::temperature_sensor Class Reference\nHardware abstraction interface for temperature sensing devices.\n#include \u003ctemperature.hpp\u003e\nPublic Functions     Name     boost::leaf::result\u003c temperature \u003e read()Read the current temperature from the sensor.    Public Functions Documentation function read inline boost::leaf::result\u003c temperature \u003e read() Read the current temperature from the sensor.\nReturn: boost::leaf::result- current temperature reading or an error.\n Updated on 2022-05-15 at 12:08:46 +0000\n","description":"","tags":null,"title":"embed::temperature_sensor","uri":"/libembeddedhal/api/classes/classembed_1_1temperature__sensor/"},{"content":"embed::this_thread Namespace Reference\nClasses     Name     struct embed::this_thread::global_clocks structure containing internal clock variables and functions    Types     Name     using std::chrono::nanoseconds time_period Smallest increment of time for clocks.   using std::function\u003c void(time_period p_sleep_time)\u003e sleep_function Definition of a sleep function.   using std::function\u003c time_period(void)\u003e uptime_function Definition of an uptime function.    Functions     Name     void sleep_for(time_period p_delay)Delay execution of the program by a predefined time.   auto uptime()Get the current system uptime.   void set_global_sleep(sleep_function p_sleep_function)Set the global sleep object.   void set_global_uptime(uptime_function p_uptime_function)Set the global uptime object.    Types Documentation using time_period using embed::this_thread::time_period = typedef std::chrono::nanoseconds; Smallest increment of time for clocks.\nusing sleep_function using embed::this_thread::sleep_function = typedef std::function\u003cvoid(time_period p_sleep_time)\u003e; Definition of a sleep function.\nusing uptime_function using embed::this_thread::uptime_function = typedef std::function\u003ctime_period(void)\u003e; Definition of an uptime function.\nFunctions Documentation function sleep_for inline void sleep_for(  time_period p_delay ) Delay execution of the program by a predefined time.\nParameters:\n p_delay - the amount of time to delay execution by  function uptime inline auto uptime() Get the current system uptime.\nReturn: auto - the global uptime\nfunction set_global_sleep inline void set_global_sleep(  sleep_function p_sleep_function ) Set the global sleep object.\nParameters:\n p_sleep_function - the function to handle sleeping  function set_global_uptime inline void set_global_uptime(  uptime_function p_uptime_function ) Set the global uptime object.\nParameters:\n p_uptime_function - the function to return the current system uptime   Updated on 2022-05-15 at 12:08:46 +0000\n","description":"","tags":null,"title":"embed::this_thread","uri":"/libembeddedhal/api/namespaces/namespaceembed_1_1this__thread/"},{"content":"embed::this_thread::global_clocks Struct Reference\nstructure containing internal clock variables and functions\n#include \u003ctime.hpp\u003e\nPublic Functions     Name     time_period incremental_uptime()Default uptime timer that simply counts each time it is called. This should almost never be used.   void loop_sleep(time_period p_loop_count)Default sleep function that simply counts until it reaches a designated number.    Public Attributes     Name     sleep_function m_global_sleep Store the global sleep function.   uptime_function m_global_uptime Store the global uptime function.    Public Functions Documentation function incremental_uptime static inline time_period incremental_uptime() Default uptime timer that simply counts each time it is called. This should almost never be used.\nReturn: time_period - fake uptime\nfunction loop_sleep static inline void loop_sleep(  time_period p_loop_count ) Default sleep function that simply counts until it reaches a designated number.\nParameters:\n p_loop_count - number of iterations to loop for to mimick sleeping  Public Attributes Documentation variable m_global_sleep static sleep_function m_global_sleep {}; Store the global sleep function.\nvariable m_global_uptime static uptime_function m_global_uptime {}; Store the global uptime function.\n Updated on 2022-05-15 at 12:08:46 +0000\n","description":"","tags":null,"title":"embed::this_thread::global_clocks","uri":"/libembeddedhal/api/classes/structembed_1_1this__thread_1_1global__clocks/"},{"content":"embed::timer Class Reference\nTimer hardware abstraction interface. More…\n#include \u003ctimer.hpp\u003e\nInherited by embed::mock::timer, embed::stub::timer\nPublic Classes     Name     struct out_of_bounds Error type indicating that the desired time delay is not achievable with this timer.    Public Functions     Name     boost::leaf::result\u003c bool \u003e is_running()Determine if the timer is currently running.   boost::leaf::result\u003c void \u003e clear()Stops a scheduled event from happening.   boost::leaf::result\u003c void \u003e schedule(std::function\u003c void(void)\u003e p_callback, std::chrono::nanoseconds p_delay)Schedule an callback to be called at a designated time/interval.    Detailed Description class embed::timer; Timer hardware abstraction interface.\nUse this interface for devices and peripherals that have timer like capabilities, such that, when a timer’s time has expired, an event/interrupt/signal is generated.\nPublic Functions Documentation function is_running inline boost::leaf::result\u003c bool \u003e is_running() Determine if the timer is currently running.\nReturn:\n boost::leaf::result- true if timer is currently running boost::leaf::result- driver specific error, if any.  function clear inline boost::leaf::result\u003c void \u003e clear() Stops a scheduled event from happening.\nReturn: boost::leaf::result- driver specific error, if any.\nDoes nothing if the timer is not currently running.\nNote that there must be sufficient time between the this call finishing and the scheduled event’s termination. If this call is too close to when the schedule event expires, this function may not complete before the hardware calls the callback.\nfunction schedule inline boost::leaf::result\u003c void \u003e schedule(  std::function\u003c void(void)\u003e p_callback,  std::chrono::nanoseconds p_delay ) Schedule an callback to be called at a designated time/interval.\nParameters:\n p_callback - callback function to be called when the timer expires p_delay - the amount of time before the timer expires  Return: boost::leaf::result- returns delay_too_small or delay_too_large if p_interval cannot be reached.\nIf this is called and the timer has already scheduled an event (in other words, is_running() returns true), then the previous scheduled event will be cleared and the new scheduled event will be started.\n Updated on 2022-05-15 at 12:08:46 +0000\n","description":"","tags":null,"title":"embed::timer","uri":"/libembeddedhal/api/classes/classembed_1_1timer/"},{"content":"embed::timer::out_of_bounds Struct Reference\nError type indicating that the desired time delay is not achievable with this timer. More…\n#include \u003ctimer.hpp\u003e\nPublic Attributes     Name     std::chrono::nanoseconds invalid The invalid delay given to the schedule function.   std::chrono::nanoseconds minimum The minimum possible delay allowed.   std::chrono::nanoseconds maximum The maximum possible delay allowed.    Detailed Description struct embed::timer::out_of_bounds; Error type indicating that the desired time delay is not achievable with this timer.\nUsually this occurs if the time delay is too small or too big based on what is possible with the driving frequency of the timer and along with any prescalars before the counting register.\nHow to handle these errors:\n In cases where the program is scanning for the fastest delay, this is to be expected. The error will report the minimum possible delay which can then be assigned. Same for the maximum possible delay. In most other cases, this is usually a bug in the code and cannot be handled in code and should be treated as such. Drivers using a timer, if they need an exact number will not be usable with this timer if it throws this error, which will either require another timer that can perform this work be used or increasing the clock rate fed into the timer in order to increase its frequency range.  Public Attributes Documentation variable invalid std::chrono::nanoseconds invalid; The invalid delay given to the schedule function.\nvariable minimum std::chrono::nanoseconds minimum; The minimum possible delay allowed.\nvariable maximum std::chrono::nanoseconds maximum; The maximum possible delay allowed.\n Updated on 2022-05-15 at 12:08:46 +0000\n","description":"","tags":null,"title":"embed::timer::out_of_bounds","uri":"/libembeddedhal/api/classes/structembed_1_1timer_1_1out__of__bounds/"},{"content":"embed::uptime_counter Class Reference\nuptime counter takes a hardware counter and calculates the uptime in nanoseconds. More…\n#include \u003cuptime_counter.hpp\u003e\nPublic Functions     Name      uptime_counter(counter \u0026 p_counter)Construct a new uptime counter object.   boost::leaf::result\u003c std::chrono::nanoseconds \u003e uptime()Calculates the number of nanoseconds since the counter has started.    Detailed Description class embed::uptime_counter; uptime counter takes a hardware counter and calculates the uptime in nanoseconds.\nThis class should be used over calling frequency::duration_from_cycles() to calculate uptime because that function will overflow when 9223372 seconds or around 15 weeks have elapsed. This has to do with how the integer arithmetic is handled for converting from frequency to duration using a cycle count.\nSo long as this class’s uptime() is called within a 15 week timespan, the uptime will be accurate up to ~292 years.\nPublic Functions Documentation function uptime_counter inline uptime_counter(  counter \u0026 p_counter ) Construct a new uptime counter object.\nParameters:\n p_counter - hardware counter  function uptime inline boost::leaf::result\u003c std::chrono::nanoseconds \u003e uptime() Calculates the number of nanoseconds since the counter has started.\nReturn: boost::leaf::resultstd::chrono::nanoseconds - returns the\nTo get the correct uptime, this function must be called within a 15 week time period to hold accuracy.\n Updated on 2022-05-15 at 12:08:46 +0000\n","description":"","tags":null,"title":"embed::uptime_counter","uri":"/libembeddedhal/api/classes/classembed_1_1uptime__counter/"},{"content":" Updated on 2022-05-15 at 12:08:46 +0000\n","description":"","tags":null,"title":"Modules","uri":"/libembeddedhal/api/modules/"},{"content":" namespace embed  namespace config  namespace defaults   namespace error namespace literals namespace mock namespace stub namespace this_thread   namespace units   Updated on 2022-05-15 at 12:08:46 +0000\n","description":"","tags":null,"title":"Namespaces","uri":"/libembeddedhal/api/namespaces/"},{"content":" Updated on 2022-05-15 at 12:08:46 +0000\n","description":"","tags":null,"title":"Pages","uri":"/libembeddedhal/api/pages/"},{"content":"","description":"","tags":null,"title":"Tags","uri":"/libembeddedhal/tags/"},{"content":"units Namespace Reference\n Updated on 2022-05-15 at 12:08:46 +0000\n","description":"","tags":null,"title":"units","uri":"/libembeddedhal/api/namespaces/namespaceunits/"},{"content":"Welcome! TBD\n","description":"","tags":null,"title":"Welcome","uri":"/libembeddedhal/"}]