<!doctype html><html lang=en class="js csstransforms3d"><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=generator content="Hugo 0.98.0"><meta name=generator content="Relearn 2.9.2
"><meta name=description content><title>embed :: libembeddedhal docs</title><link href=/libembeddedhal/css/nucleus.css?1652011702 rel=stylesheet><link href=/libembeddedhal/css/fontawesome-all.min.css?1652011702 rel=stylesheet><link href=/libembeddedhal/css/featherlight.min.css?1652011702 rel=stylesheet><link href=/libembeddedhal/css/perfect-scrollbar.min.css?1652011702 rel=stylesheet><link href=/libembeddedhal/css/auto-complete.css?1652011702 rel=stylesheet><link href=/libembeddedhal/css/theme.css?1652011702 rel=stylesheet><link href=/libembeddedhal/css/theme-green.css?1652011702 rel=stylesheet><link href=/libembeddedhal/css/variant.css?1652011702 rel=stylesheet><link href=/libembeddedhal/css/print.css?1652011702 rel=stylesheet media=print><script src=/libembeddedhal/js/jquery.min.js?1652011702></script><style>:root #header+#content>#left>#rlblock_left{display:none!important}</style></head><body data-url=/libembeddedhal/api/namespaces/namespaceembed/><script>var index_url="/libembeddedhal/index.json",root_url="/",baseUri=root_url.replace(/\/$/,'')</script><nav id=sidebar><div id=header-wrapper><div id=header><a id=logo href=/libembeddedhal/ style="color:#3d414d;font-family:work sans,helvetica,tahoma,geneva,arial,sans-serif;font-size:30px;font-weight:300;margin-top:-2px;text-transform:uppercase"><svg id="Capa_1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 0 310.797 310.797" style="enable-background:new 0 0 310.797 310.797;width:50%"><g><path d="M208.859 27.307 208.8 11.308 189.311.0l-87.893 51.407.11 19.635L63.697 93.104l.073 47.457-18.592 11.161-.155 101.334 20.214 11.833 12.422-7.502 18.173 11.395v30.12l20.075 11.895 87.333-50.921-.053-21.302 45.583-26.463v-38.133l17.004-10.152V60.551L208.859 27.307zm-21.557 6.085 6.559-3.846.048 23.674-6.607 3.86V33.392zM158.816 50.059l6.558-3.836.049 23.653-6.606 3.86V50.059zm-29.643 17.33 6.558-3.844.049 23.68-6.606 3.871V67.389zM101.529 87.725l-.049 13.891 20.164 11.813 87.158-51.046.095-17.363 23.033 14.225-107.389 63.021L83.517 98.361l18.012-10.636zM73.18 167.153l20.375-12.225-.105 7.768-20.383 12.171.113-7.714zM72.604 203.263l.018-1.205 20.374-12.225-.105 7.768-20.382 12.17L72.604 203.263zM72.846 242.79l.113-7.716 19.222-11.532-.106 7.768-19.229 11.48zm43.924 21.416-24.647-15.455 14.838-8.553.311-101.059-20.912-12.13-7.59 4.552v-18.703l38 22.237V264.206zm6.706 25.577.086-4.327 6.5-3.833.02 4.32L123.476 289.783zm29.643-17.314v-4.324l6.603-3.849.004 4.303-6.607 3.87zm28.487-16.641v-4.336l6.602-3.861.004 4.296L181.606 255.828zm52.164-51.621-102 59.915V134.869l102-59.72V204.207zm18.042-49.549-3.042 1.85v-7.696l3.167-1.964-.125 7.81zm-3.042-31.371v-7.695l3.151-1.969.139 7.721L248.77 123.287zm3.493-36.656-3.493 2.086v-7.694l3.599-2.159L252.263 86.631z"/></g><g/><g/><g/><g/><g/><g/><g/><g/><g/><g/><g/><g/><g/><g/><g/></svg></br><svg viewBox="0 0 300 25"><text x="50%" y="50%" dominant-baseline="middle" text-anchor="middle">libembeddedhal</text></svg></a></div><div class=searchbox><label for=search-by><i class="fas fa-search"></i></label>
<input data-search-input id=search-by type=search placeholder=Search...>
<span data-search-clear><i class="fas fa-times"></i></span></div><script src=/libembeddedhal/js/lunr.min.js?1652011702></script>
<script src=/libembeddedhal/js/auto-complete.js?1652011702></script>
<script src=/libembeddedhal/js/search.js?1652011702></script></div><div id=homelinks><ul><li><a class=padding href=/libembeddedhal/><i class="fas fa-home"></i> Home</a></li></ul></div><div class=highlightable><ul class=topics><li data-nav-id=/libembeddedhal/installation/ title=Installation class=dd-item><a href=/libembeddedhal/installation/><b>1. </b>Installation</a><ul><li data-nav-id=/libembeddedhal/installation/getting_started/ title="Getting Started" class=dd-item><a href=/libembeddedhal/installation/getting_started/>Getting Started</a></li><li data-nav-id=/libembeddedhal/installation/flashing/ title=Flashing class=dd-item><a href=/libembeddedhal/installation/flashing/>Flashing</a></li><li data-nav-id=/libembeddedhal/installation/jtag/ title=Debugging class=dd-item><a href=/libembeddedhal/installation/jtag/>Debugging</a></li><li data-nav-id=/libembeddedhal/installation/exploring_the_ecosystem/ title="Exploring the Ecosystem" class=dd-item><a href=/libembeddedhal/installation/exploring_the_ecosystem/>Exploring the Ecosystem</a></li></ul></li><li data-nav-id=/libembeddedhal/guides/ title=Guides class=dd-item><a href=/libembeddedhal/guides/><b>2. </b>Guides</a><ul><li data-nav-id=/libembeddedhal/guides/new_project/ title="Creating a Project" class=dd-item><a href=/libembeddedhal/guides/new_project/>Creating a Project</a></li><li data-nav-id=/libembeddedhal/guides/driver_usage/ title="How to Use Drivers" class=dd-item><a href=/libembeddedhal/guides/driver_usage/>How to Use Drivers</a></li><li data-nav-id=/libembeddedhal/guides/error_handling/ title="Error Handling" class=dd-item><a href=/libembeddedhal/guides/error_handling/>Error Handling</a></li><li data-nav-id=/libembeddedhal/guides/multiplatform_apps/ title="Multiplatform Applications" class=dd-item><a href=/libembeddedhal/guides/multiplatform_apps/>Multiplatform Applications</a></li><li data-nav-id=/libembeddedhal/guides/unit_testing/ title="Unit Testing" class=dd-item><a href=/libembeddedhal/guides/unit_testing/>Unit Testing</a></li><li data-nav-id=/libembeddedhal/guides/using_floats/ title="Using Floats" class=dd-item><a href=/libembeddedhal/guides/using_floats/>Using Floats</a></li></ul></li><li data-nav-id=/libembeddedhal/api/ title=API class="dd-item parent"><a href=/libembeddedhal/api/><b>3. </b>API</a><ul><li data-nav-id=/libembeddedhal/api/classes/ title=Classes class="dd-item alwaysopen"><a href=/libembeddedhal/api/classes/>Classes</a><ul><li data-nav-id=/libembeddedhal/api/classes/classembed_1_1accelerometer/ title=embed::accelerometer class=dd-item><a href=/libembeddedhal/api/classes/classembed_1_1accelerometer/>embed::accelerometer</a></li><li data-nav-id=/libembeddedhal/api/classes/structembed_1_1accelerometer_1_1sample/ title=embed::accelerometer::sample class=dd-item><a href=/libembeddedhal/api/classes/structembed_1_1accelerometer_1_1sample/>embed::accelerometer::sample</a></li><li data-nav-id=/libembeddedhal/api/classes/structembed_1_1accelerometer_1_1sample_1_1axis__t/ title=embed::accelerometer::sample::axis_t class=dd-item><a href=/libembeddedhal/api/classes/structembed_1_1accelerometer_1_1sample_1_1axis__t/>embed::accelerometer::sample::axis_t</a></li><li data-nav-id=/libembeddedhal/api/classes/classembed_1_1adc/ title=embed::adc class=dd-item><a href=/libembeddedhal/api/classes/classembed_1_1adc/>embed::adc</a></li><li data-nav-id=/libembeddedhal/api/classes/structembed_1_1bit__limits/ title=embed::bit_limits class=dd-item><a href=/libembeddedhal/api/classes/structembed_1_1bit__limits/>embed::bit_limits</a></li><li data-nav-id=/libembeddedhal/api/classes/classembed_1_1can/ title=embed::can class=dd-item><a href=/libembeddedhal/api/classes/classembed_1_1can/>embed::can</a></li><li data-nav-id=/libembeddedhal/api/classes/classembed_1_1can__network/ title=embed::can_network class=dd-item><a href=/libembeddedhal/api/classes/classembed_1_1can__network/>embed::can_network</a></li><li data-nav-id=/libembeddedhal/api/classes/classembed_1_1can__network_1_1node__t/ title=embed::can_network::node_t class=dd-item><a href=/libembeddedhal/api/classes/classembed_1_1can__network_1_1node__t/>embed::can_network::node_t</a></li><li data-nav-id=/libembeddedhal/api/classes/structembed_1_1can_1_1message__t/ title=embed::can::message_t class=dd-item><a href=/libembeddedhal/api/classes/structembed_1_1can_1_1message__t/>embed::can::message_t</a></li><li data-nav-id=/libembeddedhal/api/classes/structembed_1_1can_1_1settings/ title=embed::can::settings class=dd-item><a href=/libembeddedhal/api/classes/structembed_1_1can_1_1settings/>embed::can::settings</a></li><li data-nav-id=/libembeddedhal/api/classes/classembed_1_1counter/ title=embed::counter class=dd-item><a href=/libembeddedhal/api/classes/classembed_1_1counter/>embed::counter</a></li><li data-nav-id=/libembeddedhal/api/classes/structembed_1_1counter_1_1uptime__t/ title=embed::counter::uptime_t class=dd-item><a href=/libembeddedhal/api/classes/structembed_1_1counter_1_1uptime__t/>embed::counter::uptime_t</a></li><li data-nav-id=/libembeddedhal/api/classes/classembed_1_1dac/ title=embed::dac class=dd-item><a href=/libembeddedhal/api/classes/classembed_1_1dac/>embed::dac</a></li><li data-nav-id=/libembeddedhal/api/classes/structembed_1_1duty__cycle/ title=embed::duty_cycle class=dd-item><a href=/libembeddedhal/api/classes/structembed_1_1duty__cycle/>embed::duty_cycle</a></li><li data-nav-id=/libembeddedhal/api/classes/structembed_1_1error_1_1invalid__option__t/ title=embed::error::invalid_option_t class=dd-item><a href=/libembeddedhal/api/classes/structembed_1_1error_1_1invalid__option__t/>embed::error::invalid_option_t</a></li><li data-nav-id=/libembeddedhal/api/classes/structembed_1_1error_1_1invalid__settings/ title=embed::error::invalid_settings class=dd-item><a href=/libembeddedhal/api/classes/structembed_1_1error_1_1invalid__settings/>embed::error::invalid_settings</a></li><li data-nav-id=/libembeddedhal/api/classes/classembed_1_1error_1_1stacktrace/ title=embed::error::stacktrace class=dd-item><a href=/libembeddedhal/api/classes/classembed_1_1error_1_1stacktrace/>embed::error::stacktrace</a></li><li data-nav-id=/libembeddedhal/api/classes/structembed_1_1error_1_1timeout/ title=embed::error::timeout class=dd-item><a href=/libembeddedhal/api/classes/structembed_1_1error_1_1timeout/>embed::error::timeout</a></li><li data-nav-id=/libembeddedhal/api/classes/structembed_1_1error_1_1universal/ title=embed::error::universal class=dd-item><a href=/libembeddedhal/api/classes/structembed_1_1error_1_1universal/>embed::error::universal</a></li><li data-nav-id=/libembeddedhal/api/classes/classembed_1_1frequency/ title=embed::frequency class=dd-item><a href=/libembeddedhal/api/classes/classembed_1_1frequency/>embed::frequency</a></li><li data-nav-id=/libembeddedhal/api/classes/classembed_1_1i2c/ title=embed::i2c class=dd-item><a href=/libembeddedhal/api/classes/classembed_1_1i2c/>embed::i2c</a></li><li data-nav-id=/libembeddedhal/api/classes/structembed_1_1i2c_1_1settings/ title=embed::i2c::settings class=dd-item><a href=/libembeddedhal/api/classes/structembed_1_1i2c_1_1settings/>embed::i2c::settings</a></li><li data-nav-id=/libembeddedhal/api/classes/classembed_1_1input__pin/ title=embed::input_pin class=dd-item><a href=/libembeddedhal/api/classes/classembed_1_1input__pin/>embed::input_pin</a></li><li data-nav-id=/libembeddedhal/api/classes/structembed_1_1input__pin_1_1settings/ title=embed::input_pin::settings class=dd-item><a href=/libembeddedhal/api/classes/structembed_1_1input__pin_1_1settings/>embed::input_pin::settings</a></li><li data-nav-id=/libembeddedhal/api/classes/classembed_1_1interrupt__pin/ title=embed::interrupt_pin class=dd-item><a href=/libembeddedhal/api/classes/classembed_1_1interrupt__pin/>embed::interrupt_pin</a></li><li data-nav-id=/libembeddedhal/api/classes/structembed_1_1interrupt__pin_1_1settings/ title=embed::interrupt_pin::settings class=dd-item><a href=/libembeddedhal/api/classes/structembed_1_1interrupt__pin_1_1settings/>embed::interrupt_pin::settings</a></li><li data-nav-id=/libembeddedhal/api/classes/structembed_1_1microkelvin/ title=embed::microkelvin class=dd-item><a href=/libembeddedhal/api/classes/structembed_1_1microkelvin/>embed::microkelvin</a></li><li data-nav-id=/libembeddedhal/api/classes/structembed_1_1micrometre__per__second__sq/ title=embed::micrometre_per_second_sq class=dd-item><a href=/libembeddedhal/api/classes/structembed_1_1micrometre__per__second__sq/>embed::micrometre_per_second_sq</a></li><li data-nav-id=/libembeddedhal/api/classes/structembed_1_1millikelvin/ title=embed::millikelvin class=dd-item><a href=/libembeddedhal/api/classes/structembed_1_1millikelvin/>embed::millikelvin</a></li><li data-nav-id=/libembeddedhal/api/classes/structembed_1_1millimetre__per__second__sq/ title=embed::millimetre_per_second_sq class=dd-item><a href=/libembeddedhal/api/classes/structembed_1_1millimetre__per__second__sq/>embed::millimetre_per_second_sq</a></li><li data-nav-id=/libembeddedhal/api/classes/structembed_1_1mock_1_1dac/ title=embed::mock::dac class=dd-item><a href=/libembeddedhal/api/classes/structembed_1_1mock_1_1dac/>embed::mock::dac</a></li><li data-nav-id=/libembeddedhal/api/classes/structembed_1_1mock_1_1motor/ title=embed::mock::motor class=dd-item><a href=/libembeddedhal/api/classes/structembed_1_1mock_1_1motor/>embed::mock::motor</a></li><li data-nav-id=/libembeddedhal/api/classes/structembed_1_1mock_1_1pwm/ title=embed::mock::pwm class=dd-item><a href=/libembeddedhal/api/classes/structembed_1_1mock_1_1pwm/>embed::mock::pwm</a></li><li data-nav-id=/libembeddedhal/api/classes/structembed_1_1mock_1_1timer/ title=embed::mock::timer class=dd-item><a href=/libembeddedhal/api/classes/structembed_1_1mock_1_1timer/>embed::mock::timer</a></li><li data-nav-id=/libembeddedhal/api/classes/structembed_1_1mock_1_1write__only__spi/ title=embed::mock::write_only_spi class=dd-item><a href=/libembeddedhal/api/classes/structembed_1_1mock_1_1write__only__spi/>embed::mock::write_only_spi</a></li><li data-nav-id=/libembeddedhal/api/classes/classembed_1_1motor/ title=embed::motor class=dd-item><a href=/libembeddedhal/api/classes/classembed_1_1motor/>embed::motor</a></li><li data-nav-id=/libembeddedhal/api/classes/structembed_1_1nanokelvin/ title=embed::nanokelvin class=dd-item><a href=/libembeddedhal/api/classes/structembed_1_1nanokelvin/>embed::nanokelvin</a></li><li data-nav-id=/libembeddedhal/api/classes/structembed_1_1nanometre__per__second__sq/ title=embed::nanometre_per_second_sq class=dd-item><a href=/libembeddedhal/api/classes/structembed_1_1nanometre__per__second__sq/>embed::nanometre_per_second_sq</a></li><li data-nav-id=/libembeddedhal/api/classes/classembed_1_1output__pin/ title=embed::output_pin class=dd-item><a href=/libembeddedhal/api/classes/classembed_1_1output__pin/>embed::output_pin</a></li><li data-nav-id=/libembeddedhal/api/classes/structembed_1_1output__pin_1_1settings/ title=embed::output_pin::settings class=dd-item><a href=/libembeddedhal/api/classes/structembed_1_1output__pin_1_1settings/>embed::output_pin::settings</a></li><li data-nav-id=/libembeddedhal/api/classes/classembed_1_1overflow__counter/ title=embed::overflow_counter class=dd-item><a href=/libembeddedhal/api/classes/classembed_1_1overflow__counter/>embed::overflow_counter</a></li><li data-nav-id=/libembeddedhal/api/classes/classembed_1_1percent/ title=embed::percent class=dd-item><a href=/libembeddedhal/api/classes/classembed_1_1percent/>embed::percent</a></li><li data-nav-id=/libembeddedhal/api/classes/classembed_1_1pwm/ title=embed::pwm class=dd-item><a href=/libembeddedhal/api/classes/classembed_1_1pwm/>embed::pwm</a></li><li data-nav-id=/libembeddedhal/api/classes/structembed_1_1pwm_1_1settings/ title=embed::pwm::settings class=dd-item><a href=/libembeddedhal/api/classes/structembed_1_1pwm_1_1settings/>embed::pwm::settings</a></li><li data-nav-id=/libembeddedhal/api/classes/classembed_1_1serial/ title=embed::serial class=dd-item><a href=/libembeddedhal/api/classes/classembed_1_1serial/>embed::serial</a></li><li data-nav-id=/libembeddedhal/api/classes/structembed_1_1serial_1_1frame__error/ title=embed::serial::frame_error class=dd-item><a href=/libembeddedhal/api/classes/structembed_1_1serial_1_1frame__error/>embed::serial::frame_error</a></li><li data-nav-id=/libembeddedhal/api/classes/structembed_1_1serial_1_1packets__lost/ title=embed::serial::packets_lost class=dd-item><a href=/libembeddedhal/api/classes/structembed_1_1serial_1_1packets__lost/>embed::serial::packets_lost</a></li><li data-nav-id=/libembeddedhal/api/classes/structembed_1_1serial_1_1parity__error/ title=embed::serial::parity_error class=dd-item><a href=/libembeddedhal/api/classes/structembed_1_1serial_1_1parity__error/>embed::serial::parity_error</a></li><li data-nav-id=/libembeddedhal/api/classes/structembed_1_1serial_1_1settings/ title=embed::serial::settings class=dd-item><a href=/libembeddedhal/api/classes/structembed_1_1serial_1_1settings/>embed::serial::settings</a></li><li data-nav-id=/libembeddedhal/api/classes/classembed_1_1spi/ title=embed::spi class=dd-item><a href=/libembeddedhal/api/classes/classembed_1_1spi/>embed::spi</a></li><li data-nav-id=/libembeddedhal/api/classes/structembed_1_1spi_1_1settings/ title=embed::spi::settings class=dd-item><a href=/libembeddedhal/api/classes/structembed_1_1spi_1_1settings/>embed::spi::settings</a></li><li data-nav-id=/libembeddedhal/api/classes/classembed_1_1spy__handler/ title=embed::spy_handler class=dd-item><a href=/libembeddedhal/api/classes/classembed_1_1spy__handler/>embed::spy_handler</a></li><li data-nav-id=/libembeddedhal/api/classes/classembed_1_1static__callable/ title=embed::static_callable class=dd-item><a href=/libembeddedhal/api/classes/classembed_1_1static__callable/>embed::static_callable</a></li><li data-nav-id=/libembeddedhal/api/classes/classembed_1_1static__callable_3_01owner__class_00_01reference__designator_00_01return__t_07args__t_8_8_8_01p__args_08_4/ title="embed::static_callable< owner_class, reference_designator, return_t(args_t... p_args)>" class=dd-item><a href=/libembeddedhal/api/classes/classembed_1_1static__callable_3_01owner__class_00_01reference__designator_00_01return__t_07args__t_8_8_8_01p__args_08_4/>embed::static_callable&lt; owner_class, reference_designator, return_t(args_t... p_args)></a></li><li data-nav-id=/libembeddedhal/api/classes/classembed_1_1static__memory__resource/ title=embed::static_memory_resource class=dd-item><a href=/libembeddedhal/api/classes/classembed_1_1static__memory__resource/>embed::static_memory_resource</a></li><li data-nav-id=/libembeddedhal/api/classes/classembed_1_1stub_1_1adc/ title=embed::stub::adc class=dd-item><a href=/libembeddedhal/api/classes/classembed_1_1stub_1_1adc/>embed::stub::adc</a></li><li data-nav-id=/libembeddedhal/api/classes/classembed_1_1stub_1_1dac/ title=embed::stub::dac class=dd-item><a href=/libembeddedhal/api/classes/classembed_1_1stub_1_1dac/>embed::stub::dac</a></li><li data-nav-id=/libembeddedhal/api/classes/classembed_1_1stub_1_1serial/ title=embed::stub::serial class=dd-item><a href=/libembeddedhal/api/classes/classembed_1_1stub_1_1serial/>embed::stub::serial</a></li><li data-nav-id=/libembeddedhal/api/classes/classembed_1_1stub_1_1spi/ title=embed::stub::spi class=dd-item><a href=/libembeddedhal/api/classes/classembed_1_1stub_1_1spi/>embed::stub::spi</a></li><li data-nav-id=/libembeddedhal/api/classes/classembed_1_1stub_1_1timer/ title=embed::stub::timer class=dd-item><a href=/libembeddedhal/api/classes/classembed_1_1stub_1_1timer/>embed::stub::timer</a></li><li data-nav-id=/libembeddedhal/api/classes/classembed_1_1temperature__sensor/ title=embed::temperature_sensor class=dd-item><a href=/libembeddedhal/api/classes/classembed_1_1temperature__sensor/>embed::temperature_sensor</a></li><li data-nav-id=/libembeddedhal/api/classes/structembed_1_1this__thread_1_1global__clocks/ title=embed::this_thread::global_clocks class=dd-item><a href=/libembeddedhal/api/classes/structembed_1_1this__thread_1_1global__clocks/>embed::this_thread::global_clocks</a></li><li data-nav-id=/libembeddedhal/api/classes/classembed_1_1timer/ title=embed::timer class=dd-item><a href=/libembeddedhal/api/classes/classembed_1_1timer/>embed::timer</a></li><li data-nav-id=/libembeddedhal/api/classes/structembed_1_1timer_1_1out__of__bounds/ title=embed::timer::out_of_bounds class=dd-item><a href=/libembeddedhal/api/classes/structembed_1_1timer_1_1out__of__bounds/>embed::timer::out_of_bounds</a></li><li data-nav-id=/libembeddedhal/api/classes/classembed_1_1uptime__counter/ title=embed::uptime_counter class=dd-item><a href=/libembeddedhal/api/classes/classembed_1_1uptime__counter/>embed::uptime_counter</a></li></ul></li><li data-nav-id=/libembeddedhal/api/modules/ title=Modules class="dd-item alwaysopen"><a href=/libembeddedhal/api/modules/>Modules</a><ul></ul></li><li data-nav-id=/libembeddedhal/api/namespaces/ title=Namespaces class="dd-item parent alwaysopen"><a href=/libembeddedhal/api/namespaces/>Namespaces</a><ul><li data-nav-id=/libembeddedhal/api/namespaces/namespaceembed/ title=embed class="dd-item active"><a href=/libembeddedhal/api/namespaces/namespaceembed/>embed</a></li><li data-nav-id=/libembeddedhal/api/namespaces/namespaceembed_1_1config/ title=embed::config class=dd-item><a href=/libembeddedhal/api/namespaces/namespaceembed_1_1config/>embed::config</a></li><li data-nav-id=/libembeddedhal/api/namespaces/namespaceembed_1_1config_1_1defaults/ title=embed::config::defaults class=dd-item><a href=/libembeddedhal/api/namespaces/namespaceembed_1_1config_1_1defaults/>embed::config::defaults</a></li><li data-nav-id=/libembeddedhal/api/namespaces/namespaceembed_1_1error/ title=embed::error class=dd-item><a href=/libembeddedhal/api/namespaces/namespaceembed_1_1error/>embed::error</a></li><li data-nav-id=/libembeddedhal/api/namespaces/namespaceembed_1_1literals/ title=embed::literals class=dd-item><a href=/libembeddedhal/api/namespaces/namespaceembed_1_1literals/>embed::literals</a></li><li data-nav-id=/libembeddedhal/api/namespaces/namespaceembed_1_1mock/ title=embed::mock class=dd-item><a href=/libembeddedhal/api/namespaces/namespaceembed_1_1mock/>embed::mock</a></li><li data-nav-id=/libembeddedhal/api/namespaces/namespaceembed_1_1stub/ title=embed::stub class=dd-item><a href=/libembeddedhal/api/namespaces/namespaceembed_1_1stub/>embed::stub</a></li><li data-nav-id=/libembeddedhal/api/namespaces/namespaceembed_1_1this__thread/ title=embed::this_thread class=dd-item><a href=/libembeddedhal/api/namespaces/namespaceembed_1_1this__thread/>embed::this_thread</a></li><li data-nav-id=/libembeddedhal/api/namespaces/namespaceunits/ title=units class=dd-item><a href=/libembeddedhal/api/namespaces/namespaceunits/>units</a></li></ul></li><li data-nav-id=/libembeddedhal/api/pages/ title=Pages class="dd-item alwaysopen"><a href=/libembeddedhal/api/pages/>Pages</a><ul></ul></li></ul></li><li data-nav-id=/libembeddedhal/design/ title=Design class=dd-item><a href=/libembeddedhal/design/><b>4. </b>Design</a><ul><li data-nav-id=/libembeddedhal/design/driver_design/ title="Driver Interface Design" class=dd-item><a href=/libembeddedhal/design/driver_design/>Driver Interface Design</a></li><li data-nav-id=/libembeddedhal/design/error_handling_design/ title="Error Handling Design" class=dd-item><a href=/libembeddedhal/design/error_handling_design/>Error Handling Design</a></li><li data-nav-id=/libembeddedhal/design/driver_wrappers/ title="Driver Wrappers Design" class=dd-item><a href=/libembeddedhal/design/driver_wrappers/>Driver Wrappers Design</a></li><li data-nav-id=/libembeddedhal/design/handmade_mocks/ title="Handwritten Driver Mocks" class=dd-item><a href=/libembeddedhal/design/handmade_mocks/>Handwritten Driver Mocks</a></li></ul></li><li data-nav-id=/libembeddedhal/expanding/ title="Expanding the Ecosystem" class=dd-item><a href=/libembeddedhal/expanding/><b>5. </b>Expanding the Ecosystem</a><ul><li data-nav-id=/libembeddedhal/expanding/creating_device/ title="Creating a Device Driver" class=dd-item><a href=/libembeddedhal/expanding/creating_device/>Creating a Device Driver</a></li><li data-nav-id=/libembeddedhal/expanding/creating_platform/ title="Creating a Platform" class=dd-item><a href=/libembeddedhal/expanding/creating_platform/>Creating a Platform</a></li><li data-nav-id=/libembeddedhal/expanding/creating_utilities/ title="Creating a Utility Library" class=dd-item><a href=/libembeddedhal/expanding/creating_utilities/>Creating a Utility Library</a></li></ul></li><li data-nav-id=/libembeddedhal/contribution/ title=Contributing class=dd-item><a href=/libembeddedhal/contribution/><b>6. </b>Contributing</a><ul></ul></li></ul><div id=shortcuts><div class=nav-title>More</div><ul><li><a class=padding href=/libembeddedhal/><i><img height=150 src=https://upload.wikimedia.org/wikipedia/commons/b/b5/Conan_package_manager_logo.png style=height:1em></i> Search conan</a></li><li><a class=padding href=/libembeddedhal/><i><img height=150 src=https://vcpkg.io/assets/mark/mark.svg style=height:1em></i> Search vcpkg</a></li><li><a class=padding href=https://github.com/SJSU-Dev2/libembeddedhal><i class="fab fa-fw fa-github"></i> GitHub</a></li><li><a class=padding href=/libembeddedhal/libembeddedhal/showcase/><i class="fas fa-fw fa-camera"></i> Showcases</a></li><li><a class=padding href=/libembeddedhal/libembeddedhal/credits/><i class="fas fa-fw fa-bullhorn"></i> Credits</a></li></ul></div><div id=footer><p>Built with <a href=https://github.com/McShelby/hugo-theme-relearn><i class="fas fa-heart"></i></a> by <a href=https://gohugo.io/>Hugo</a></p></div></div></nav><div id=body><div id=overlay></div><div class="padding highlightable"><div id=top-bar><div id=breadcrumbs><span id=sidebar-toggle-span><a href=# id=sidebar-toggle data-sidebar-toggle><i class="fas fa-bars"></i></a></span>
<span id=toc-menu><i class="fas fa-list-alt"></i></span><ol class=links itemscope itemtype=http://schema.org/BreadcrumbList><meta itemprop=itemListOrder content="Descending"><li itemscope itemtype=https://schema.org/ListItem itemprop=itemListElement><meta itemprop=position content="4"><a itemprop=item href=/libembeddedhal/><span itemprop=name>Welcome</span></a> ></li><li itemscope itemtype=https://schema.org/ListItem itemprop=itemListElement><meta itemprop=position content="3"><a itemprop=item href=/libembeddedhal/api/><span itemprop=name>API</span></a> ></li><li itemscope itemtype=https://schema.org/ListItem itemprop=itemListElement><meta itemprop=position content="2"><a itemprop=item href=/libembeddedhal/api/namespaces/><span itemprop=name>Namespaces</span></a> ></li><li itemscope itemtype=https://schema.org/ListItem itemprop=itemListElement><meta itemprop=position content="1"><a itemprop=item href=/libembeddedhal/api/namespaces/namespaceembed/ aria-disabled=true><span itemprop=name>embed</span></a></li></ol></div><div class=progress><div class=wrapper><nav id=TableOfContents><ul><li><a href=#namespaces>Namespaces</a></li><li><a href=#classes>Classes</a></li><li><a href=#types>Types</a></li><li><a href=#functions>Functions</a></li><li><a href=#attributes>Attributes</a></li><li><a href=#types-documentation>Types Documentation</a><ul><li><a href=#enum-pin_resistor>enum pin_resistor</a></li><li><a href=#using-nm_per_s2>using nm_per_s2</a></li><li><a href=#using-um_per_s2>using um_per_s2</a></li><li><a href=#using-mm_per_s2>using mm_per_s2</a></li><li><a href=#using-acceleration>using acceleration</a></li><li><a href=#using-nk>using nK</a></li><li><a href=#using-uk>using uK</a></li><li><a href=#using-mk>using mK</a></li><li><a href=#using-temperature>using temperature</a></li></ul></li><li><a href=#functions-documentation>Functions Documentation</a><ul><li><a href=#function-generate_field_of_ones>function generate_field_of_ones</a></li><li><a href=#function-is_platform>function is_platform</a></li><li><a href=#function-is_a_test>function is_a_test</a></li><li><a href=#function-wait_for>function wait_for</a></li><li><a href=#function-set_as_global_sleep>function set_as_global_sleep</a></li><li><a href=#function-set_as_global_uptime>function set_as_global_uptime</a></li><li><a href=#function-value>function value</a></li><li><a href=#function-write>function write</a></li><li><a href=#function-read>function read</a></li><li><a href=#function-read-1>function read</a></li><li><a href=#function-write_then_read>function write_then_read</a></li><li><a href=#function-write_then_read-1>function write_then_read</a></li><li><a href=#function-multiply_with_overflow_detection>function multiply_with_overflow_detection</a></li><li><a href=#function-absolute_value>function absolute_value</a></li><li><a href=#function-rounding_division>function rounding_division</a></li><li><a href=#function-upscale_integer>function upscale_integer</a></li><li><a href=#function-wait>function wait</a></li><li><a href=#function-write-1>function write</a></li><li><a href=#function-read-2>function read</a></li><li><a href=#function-read-3>function read</a></li><li><a href=#function-write_then_read-2>function write_then_read</a></li><li><a href=#function-write_then_read-3>function write_then_read</a></li><li><a href=#function-write-2>function write</a></li><li><a href=#function-read-4>function read</a></li><li><a href=#function-read-5>function read</a></li><li><a href=#function-write_then_read-4>function write_then_read</a></li><li><a href=#function-write_then_read-5>function write_then_read</a></li><li><a href=#function-to_array>function to_array</a></li></ul></li><li><a href=#attributes-documentation>Attributes Documentation</a><ul><li><a href=#variable-default_clock_rate>variable default_clock_rate</a></li></ul></li></ul></nav></div></div></div><div id=head-tags></div><main id=body-inner><h1>embed</h1><p><strong>embed Namespace Reference</strong></p><h2 id=namespaces>Namespaces</h2><table><thead><tr><th>Name</th></tr></thead><tbody><tr><td><strong><a href=namespaces/namespaceembed_1_1config/>embed::config</a></strong></td></tr><tr><td><strong><a href=namespaces/namespaceembed_1_1error/>embed::error</a></strong></td></tr><tr><td><strong><a href=namespaces/namespaceembed_1_1literals/>embed::literals</a></strong></td></tr><tr><td><strong><a href=namespaces/namespaceembed_1_1mock/>embed::mock</a></strong></td></tr><tr><td><strong><a href=namespaces/namespaceembed_1_1stub/>embed::stub</a></strong></td></tr><tr><td><strong><a href=namespaces/namespaceembed_1_1this__thread/>embed::this_thread</a></strong></td></tr></tbody></table><h2 id=classes>Classes</h2><table><thead><tr><th></th><th>Name</th></tr></thead><tbody><tr><td>class</td><td><strong><a href=classes/classembed_1_1accelerometer/>embed::accelerometer</a></strong> Accelerometer hardware abstraction interface.</td></tr><tr><td>class</td><td><strong><a href=classes/classembed_1_1adc/>embed::adc</a></strong> Analog to Digital Converter (ADC) hardware abstraction interface.</td></tr><tr><td>struct</td><td><strong><a href=classes/structembed_1_1bit__limits/>embed::bit_limits</a></strong> Similar to std::numeric_limits except that this object can give properties of integral types of arbitrary bit widths.</td></tr><tr><td>class</td><td><strong><a href=classes/classembed_1_1can/>embed::can</a></strong> Controller Area Network (CAN bus) hardware abstraction interface.</td></tr><tr><td>class</td><td><strong><a href=classes/classembed_1_1can__network/>embed::can_network</a></strong> Manage, store, and organize messages received on the can bus.</td></tr><tr><td>class</td><td><strong><a href=classes/classembed_1_1counter/>embed::counter</a></strong> Counter hardware abstraction interface. Use this interface for devices and peripherals that have counting capabilities. Such devices can count up or down. Useful for keeping time. Expect counters to overflow when they reach the end of counting register&rsquo;s limits.</td></tr><tr><td>class</td><td><strong><a href=classes/classembed_1_1dac/>embed::dac</a></strong> Digital to Analog Converter (DAC) hardware abstraction interface.</td></tr><tr><td>struct</td><td><strong><a href=classes/structembed_1_1duty__cycle/>embed::duty_cycle</a></strong> Structure containing cycle count for the high and low side of a signal duty cycle.</td></tr><tr><td>class</td><td><strong><a href=classes/classembed_1_1frequency/>embed::frequency</a></strong> Represents the frequency of a signal. It consists of a single integer 64-bit number that presents the integer representation of a signal frequency.</td></tr><tr><td>class</td><td><strong><a href=classes/classembed_1_1i2c/>embed::i2c</a></strong> Inter-integrated Circuit (I2C) or Two Wire Interface (TWI) communication protocol hardware abstract interface.</td></tr><tr><td>class</td><td><strong><a href=classes/classembed_1_1input__pin/>embed::input_pin</a></strong> Digital input pin hardware abstraction.</td></tr><tr><td>class</td><td><strong><a href=classes/classembed_1_1interrupt__pin/>embed::interrupt_pin</a></strong> Digital interrupt pin hardware abstraction.</td></tr><tr><td>struct</td><td><strong><a href=classes/structembed_1_1microkelvin/>embed::microkelvin</a></strong></td></tr><tr><td>struct</td><td><strong><a href=classes/structembed_1_1micrometre__per__second__sq/>embed::micrometre_per_second_sq</a></strong></td></tr><tr><td>struct</td><td><strong><a href=classes/structembed_1_1millikelvin/>embed::millikelvin</a></strong></td></tr><tr><td>struct</td><td><strong><a href=classes/structembed_1_1millimetre__per__second__sq/>embed::millimetre_per_second_sq</a></strong></td></tr><tr><td>class</td><td><strong><a href=classes/classembed_1_1motor/>embed::motor</a></strong> Hardware abstraction for open loop continuous rotary and linear actuators.</td></tr><tr><td>struct</td><td><strong><a href=classes/structembed_1_1nanokelvin/>embed::nanokelvin</a></strong></td></tr><tr><td>struct</td><td><strong><a href=classes/structembed_1_1nanometre__per__second__sq/>embed::nanometre_per_second_sq</a></strong></td></tr><tr><td>class</td><td><strong><a href=classes/classembed_1_1output__pin/>embed::output_pin</a></strong> Digital output pin hardware abstraction.</td></tr><tr><td>class</td><td><strong><a href=classes/classembed_1_1overflow__counter/>embed::overflow_counter</a></strong> Extend a counter&rsquo;s count from an arbitrary bit width to 64-bits by detecting overflows in the count. Each detected overflow is added to an overflow counter which is combined with the current count in order create a count up to 64-bits in length.</td></tr><tr><td>class</td><td><strong><a href=classes/classembed_1_1percent/>embed::percent</a></strong> A integer representation of a percentage.</td></tr><tr><td>class</td><td><strong><a href=classes/classembed_1_1pwm/>embed::pwm</a></strong> Pulse Width Modulation (PWM) channel hardware abstraction.</td></tr><tr><td>class</td><td><strong><a href=classes/classembed_1_1serial/>embed::serial</a></strong> Serial communication protocol hardware abstract interface.</td></tr><tr><td>class</td><td><strong><a href=classes/classembed_1_1spi/>embed::spi</a></strong> Serial peripheral interface (SPI) communication protocol hardware abstract interface.</td></tr><tr><td>class</td><td><strong><a href=classes/classembed_1_1spy__handler/>embed::spy_handler</a></strong> Helper utility for making mocks for class functions that return boost::leaf::result.</td></tr><tr><td>class</td><td><strong><a href=classes/classembed_1_1static__callable/>embed::static_callable</a></strong> General class which will be used to allow for signature to be used and then split by the below class.</td></tr><tr><td>class</td><td><strong><a href=classes/classembed_1_1static__callable_3_01owner__class_00_01reference__designator_00_01return__t_07args__t_8_8_8_01p__args_08_4/>embed::static_callable&lt; owner_class, reference_designator, return_t(args_t&mldr; p_args)></a></strong> Specialization of <a href=classes/classembed_1_1static__callable/>static_callable</a> with the return type and arguments split up.</td></tr><tr><td>class</td><td><strong><a href=classes/classembed_1_1static__memory__resource/>embed::static_memory_resource</a></strong> The <a href>static_memory_resource</a> is the polymorphic memory resource allocator that allows libembeddedhal&rsquo;s libraries to use a C++ standard container such as std::pmr::vector, std::pmr::string, std::pmr::unordered_map, and more without requiring dynamic memory allocation from the heap. It provides a simple way to create an allocator with built in storage, with its size indicated by a single template parameter. It also provides statistics regarding the amount of memory allocated such that developers can determine if they need to reduce or increase the size of the buffer. Memory statistics can also give programs the insight into how much memory space is available and make decisions based on that. In the event that the memory of the static allocator is exceeded, a std::bad_alloc excpetion is thrown.</td></tr><tr><td>class</td><td><strong><a href=classes/classembed_1_1temperature__sensor/>embed::temperature_sensor</a></strong> Hardware abstraction interface for temperature sensing devices.</td></tr><tr><td>class</td><td><strong><a href=classes/classembed_1_1timer/>embed::timer</a></strong> Timer hardware abstraction interface.</td></tr><tr><td>class</td><td><strong><a href=classes/classembed_1_1uptime__counter/>embed::uptime_counter</a></strong> uptime counter takes a hardware counter and calculates the uptime in nanoseconds.</td></tr></tbody></table><h2 id=types>Types</h2><table><thead><tr><th></th><th>Name</th></tr></thead><tbody><tr><td>enum class</td><td><strong><a href=namespaces/namespaceembed/#enum-pin-resistor>pin_resistor</a></strong> { none = 0, pull_down, pull_up}Set of possible pin mode resistor settings.</td></tr><tr><td>template &lt;units::Representation Rep =std::int64_t> using units::isq::si::acceleration&lt; <a href=classes/structembed_1_1nanometre__per__second__sq/>embed::nanometre_per_second_sq</a>, Rep ></td><td><strong><a href=namespaces/namespaceembed/#using-nm-per-s2>nm_per_s2</a></strong></td></tr><tr><td>template &lt;units::Representation Rep =std::int64_t> using units::isq::si::acceleration&lt; <a href=classes/structembed_1_1micrometre__per__second__sq/>embed::micrometre_per_second_sq</a>, Rep ></td><td><strong><a href=namespaces/namespaceembed/#using-um-per-s2>um_per_s2</a></strong></td></tr><tr><td>template &lt;units::Representation Rep =std::int64_t> using units::isq::si::acceleration&lt; <a href=classes/structembed_1_1millimetre__per__second__sq/>embed::millimetre_per_second_sq</a>, Rep ></td><td><strong><a href=namespaces/namespaceembed/#using-mm-per-s2>mm_per_s2</a></strong></td></tr><tr><td>using nm_per_s2&lt; std::int64_t ></td><td><strong><a href=namespaces/namespaceembed/#using-acceleration>acceleration</a></strong> Universal unit for acceleration.</td></tr><tr><td>template &lt;units::Representation Rep =std::int64_t> using units::isq::si::thermodynamic_temperature&lt; <a href=classes/structembed_1_1nanokelvin/>nanokelvin</a>, Rep ></td><td><strong><a href=namespaces/namespaceembed/#using-nk>nK</a></strong></td></tr><tr><td>template &lt;units::Representation Rep =std::int64_t> using units::isq::si::thermodynamic_temperature&lt; <a href=classes/structembed_1_1microkelvin/>microkelvin</a>, Rep ></td><td><strong><a href=namespaces/namespaceembed/#using-uk>uK</a></strong></td></tr><tr><td>template &lt;units::Representation Rep =std::int64_t> using units::isq::si::thermodynamic_temperature&lt; <a href=classes/structembed_1_1millikelvin/>millikelvin</a>, Rep ></td><td><strong><a href=namespaces/namespaceembed/#using-mk>mK</a></strong></td></tr><tr><td>using nK&lt; std::int64_t ></td><td><strong><a href=namespaces/namespaceembed/#using-temperature>temperature</a></strong> Universal unit for temperature.</td></tr></tbody></table><h2 id=functions>Functions</h2><table><thead><tr><th></th><th>Name</th></tr></thead><tbody><tr><td>template &lt;size_t BitWidth,std::integral T> consteval T</td><td><strong><a href=namespaces/namespaceembed/#function-generate-field-of-ones>generate_field_of_ones</a></strong>()Generate a mask of 1s at compiletime.</td></tr><tr><td>constexpr bool</td><td><strong><a href=namespaces/namespaceembed/#function-is-platform>is_platform</a></strong>(std::string_view p_platform)Determines if the current application was built for a specific platform. For example:</td></tr><tr><td>constexpr bool</td><td><strong><a href=namespaces/namespaceembed/#function-is-a-test>is_a_test</a></strong>()Determines if the application is a test.</td></tr><tr><td>boost::leaf::result&lt; void ></td><td><strong><a href=namespaces/namespaceembed/#function-wait-for>wait_for</a></strong>(<a href=classes/classembed_1_1counter/>counter</a> & p_counter, std::chrono::nanoseconds p_wait_duration)pause execution for this duration of time using a hardware counter object.</td></tr><tr><td>void</td><td><strong><a href=namespaces/namespaceembed/#function-set-as-global-sleep>set_as_global_sleep</a></strong>(<a href=classes/classembed_1_1counter/>counter</a> & p_counter)Use this counter as the global sleep function.</td></tr><tr><td>void</td><td><strong><a href=namespaces/namespaceembed/#function-set-as-global-uptime>set_as_global_uptime</a></strong>(<a href=classes/classembed_1_1uptime__counter/>uptime_counter</a> & p_counter)Use this counter as the global sleep function.</td></tr><tr><td>constexpr auto</td><td><strong><a href=namespaces/namespaceembed/#function-value>value</a></strong>(enumeration auto p_enum_value)Helper function to convert an enum to its integral value.</td></tr><tr><td>boost::leaf::result&lt; void ></td><td><strong><a href=namespaces/namespaceembed/#function-write>write</a></strong>(<a href=classes/classembed_1_1i2c/>i2c</a> & p_i2c, std::byte p_address, std::span&lt; const std::byte > p_data_out)write data to a target device on the <a href>i2c</a> bus</td></tr><tr><td>boost::leaf::result&lt; void ></td><td><strong><a href=namespaces/namespaceembed/#function-read>read</a></strong>(<a href=classes/classembed_1_1i2c/>i2c</a> & p_i2c, std::byte p_address, std::span&lt; std::byte > p_data_in)read bytes from target device on <a href>i2c</a> bus</td></tr><tr><td>template &lt;size_t BytesToRead> boost::leaf::result&lt; std::array&lt; std::byte, BytesToRead > ></td><td><strong><a href=namespaces/namespaceembed/#function-read>read</a></strong>(<a href=classes/classembed_1_1i2c/>i2c</a> & p_i2c, std::byte p_address)return array of read bytes from target device on <a href>i2c</a> bus</td></tr><tr><td>boost::leaf::result&lt; void ></td><td><strong><a href=namespaces/namespaceembed/#function-write-then-read>write_then_read</a></strong>(<a href=classes/classembed_1_1i2c/>i2c</a> & p_i2c, std::byte p_address, std::span&lt; const std::byte > p_data_out, std::span&lt; std::byte > p_data_in)write and then read bytes from target device on <a href>i2c</a> bus</td></tr><tr><td>template &lt;size_t BytesToRead> boost::leaf::result&lt; std::array&lt; std::byte, BytesToRead > ></td><td><strong><a href=namespaces/namespaceembed/#function-write-then-read>write_then_read</a></strong>(<a href=classes/classembed_1_1i2c/>i2c</a> & p_i2c, std::byte p_address, std::span&lt; const std::byte > p_data_out)write and then return an array of read bytes from target device on <a href>i2c</a> bus</td></tr><tr><td>template &lt;typename T > boost::leaf::result&lt; T ></td><td><strong><a href=namespaces/namespaceembed/#function-multiply-with-overflow-detection>multiply_with_overflow_detection</a></strong>(T p_lhs, T p_rhs)Perform multiply operation and return an error code <code>std::errc::result_out_of_range</code> if the two values when multiplied would overflow the containing value.</td></tr><tr><td>template &lt;typename T > constexpr T</td><td><strong><a href=namespaces/namespaceembed/#function-absolute-value>absolute_value</a></strong>(T p_value)Generic absolute value function that works for integer types. This is preferred over the C API for rounding numbers such as abs(), labs() and llabs(). This function relieves the need in template code to check the type of the integer and select the correct function to call.</td></tr><tr><td>template &lt;typename T > constexpr T</td><td><strong><a href=namespaces/namespaceembed/#function-rounding-division>rounding_division</a></strong>(T p_numerator, T p_denominator)Perform integer division and round the value up if the next decimal place is greater than or equal to 0.5.</td></tr><tr><td>template &lt;std::integral T,size_t SourceWidth,std::integral U> constexpr T</td><td><strong><a href=namespaces/namespaceembed/#function-upscale-integer>upscale_integer</a></strong>(U p_value)Upscale an integer value of arbitrary bit resolution to a new fixed with integer value.</td></tr><tr><td>boost::leaf::result&lt; void ></td><td><strong><a href=namespaces/namespaceembed/#function-wait>wait</a></strong>(<a href=classes/classembed_1_1serial/>serial</a> & p_serial, size_t p_length, std::optional&lt; std::chrono::nanoseconds > p_timeout =std::nullopt)</td></tr><tr><td>boost::leaf::result&lt; void ></td><td><strong><a href=namespaces/namespaceembed/#function-write>write</a></strong>(<a href=classes/classembed_1_1serial/>serial</a> & p_serial, std::span&lt; const std::byte > p_data_out)</td></tr><tr><td>boost::leaf::result&lt; std::span&lt; const std::byte > ></td><td><strong><a href=namespaces/namespaceembed/#function-read>read</a></strong>(<a href=classes/classembed_1_1serial/>serial</a> & p_serial, std::span&lt; std::byte > p_data_in, std::optional&lt; std::chrono::nanoseconds > p_timeout =std::nullopt)</td></tr><tr><td>template &lt;size_t BytesToRead> boost::leaf::result&lt; std::array&lt; std::byte, BytesToRead > ></td><td><strong><a href=namespaces/namespaceembed/#function-read>read</a></strong>(<a href=classes/classembed_1_1serial/>serial</a> & p_serial, std::optional&lt; std::chrono::nanoseconds > p_timeout =std::nullopt)</td></tr><tr><td>boost::leaf::result&lt; void ></td><td><strong><a href=namespaces/namespaceembed/#function-write-then-read>write_then_read</a></strong>(<a href=classes/classembed_1_1serial/>serial</a> & p_serial, std::span&lt; const std::byte > p_data_out, std::span&lt; std::byte > p_data_in, std::optional&lt; std::chrono::nanoseconds > p_timeout =std::nullopt)</td></tr><tr><td>template &lt;size_t BytesToRead> boost::leaf::result&lt; std::array&lt; std::byte, BytesToRead > ></td><td><strong><a href=namespaces/namespaceembed/#function-write-then-read>write_then_read</a></strong>(<a href=classes/classembed_1_1serial/>serial</a> & p_serial, std::span&lt; const std::byte > p_data_out, std::optional&lt; std::chrono::nanoseconds > p_timeout =std::nullopt)</td></tr><tr><td>boost::leaf::result&lt; void ></td><td><strong><a href=namespaces/namespaceembed/#function-write>write</a></strong>(<a href=classes/classembed_1_1spi/>spi</a> & p_spi, std::span&lt; const std::byte > p_data_out)Write data to the SPI bus and ignore data sent from peripherals on the bus.</td></tr><tr><td>boost::leaf::result&lt; void ></td><td><strong><a href=namespaces/namespaceembed/#function-read>read</a></strong>(<a href=classes/classembed_1_1spi/>spi</a> & p_spi, std::span&lt; std::byte > p_data_in, std::byte p_filler =<a href=classes/classembed_1_1spi/#variable-default-filler>spi::default_filler</a>)Read data from the SPI bus.</td></tr><tr><td>template &lt;size_t BytesToRead> boost::leaf::result&lt; std::array&lt; std::byte, BytesToRead > ></td><td><strong><a href=namespaces/namespaceembed/#function-read>read</a></strong>(<a href=classes/classembed_1_1spi/>spi</a> & p_spi, std::byte p_filler =<a href=classes/classembed_1_1spi/#variable-default-filler>spi::default_filler</a>)Read data from the SPI bus and return a std::array of bytes.</td></tr><tr><td>boost::leaf::result&lt; void ></td><td><strong><a href=namespaces/namespaceembed/#function-write-then-read>write_then_read</a></strong>(<a href=classes/classembed_1_1spi/>spi</a> & p_spi, std::span&lt; const std::byte > p_data_out, std::span&lt; std::byte > p_data_in, std::byte p_filler =<a href=classes/classembed_1_1spi/#variable-default-filler>spi::default_filler</a>)Write data to the SPI bus and ignore data sent from peripherals on the bus then read data from the SPI and fill the write line with filler bytes.</td></tr><tr><td>template &lt;size_t BytesToRead> boost::leaf::result&lt; std::array&lt; std::byte, BytesToRead > ></td><td><strong><a href=namespaces/namespaceembed/#function-write-then-read>write_then_read</a></strong>(<a href=classes/classembed_1_1spi/>spi</a> & p_spi, std::span&lt; const std::byte > p_data_out, std::byte p_filler =<a href=classes/classembed_1_1spi/#variable-default-filler>spi::default_filler</a>)Write data to the SPI bus and ignore data sent from peripherals on the bus then read data from the SPI, fill the write line with filler bytes and return an array of bytes.</td></tr><tr><td>template &lt;size_t N> constexpr std::array&lt; char, N+1 ></td><td><strong><a href=namespaces/namespaceembed/#function-to-array>to_array</a></strong>(std::string_view p_view)Convert a string_view into a std::array of N number of characters.</td></tr></tbody></table><h2 id=attributes>Attributes</h2><table><thead><tr><th></th><th>Name</th></tr></thead><tbody><tr><td>constexpr <a href=classes/classembed_1_1frequency/>frequency</a></td><td><strong><a href=namespaces/namespaceembed/#variable-default-clock-rate>default_clock_rate</a></strong> Default clock rate for serial communication protocols.</td></tr></tbody></table><h2 id=types-documentation>Types Documentation</h2><h3 id=enum-pin_resistor>enum pin_resistor</h3><table><thead><tr><th>Enumerator</th><th>Value</th><th>Description</th></tr></thead><tbody><tr><td>none</td><td>0</td><td>No pull up. This will cause the pin to float. This may be desirable if the pin has an external resistor attached or if the signal is sensitive to external devices like resistors.</td></tr><tr><td>pull_down</td><td></td><td>Pull the pin down to devices GND. This will ensure that the voltage read by the pin when there is no signal on the pin is LOW (or false).</td></tr><tr><td>pull_up</td><td></td><td>See pull down explanation, but in this case the pin is pulled up to VCC, also called VDD on some systems.</td></tr></tbody></table><p>Set of possible pin mode resistor settings.</p><p>See each enumeration to get more details about when and how these should be used.</p><h3 id=using-nm_per_s2>using nm_per_s2</h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>template</span> <span style=color:#f92672>&lt;</span>units<span style=color:#f92672>::</span>Representation Rep <span style=color:#f92672>=</span>std<span style=color:#f92672>::</span><span style=color:#66d9ef>int64_t</span><span style=color:#f92672>&gt;</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>using</span> embed<span style=color:#f92672>::</span>nm_per_s2 <span style=color:#f92672>=</span> <span style=color:#66d9ef>typedef</span> units<span style=color:#f92672>::</span>isq<span style=color:#f92672>::</span>si<span style=color:#f92672>::</span>acceleration<span style=color:#f92672>&lt;</span>embed<span style=color:#f92672>::</span>nanometre_per_second_sq, Rep<span style=color:#f92672>&gt;</span>;
</span></span></code></pre></div><h3 id=using-um_per_s2>using um_per_s2</h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>template</span> <span style=color:#f92672>&lt;</span>units<span style=color:#f92672>::</span>Representation Rep <span style=color:#f92672>=</span>std<span style=color:#f92672>::</span><span style=color:#66d9ef>int64_t</span><span style=color:#f92672>&gt;</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>using</span> embed<span style=color:#f92672>::</span>um_per_s2 <span style=color:#f92672>=</span> <span style=color:#66d9ef>typedef</span> units<span style=color:#f92672>::</span>isq<span style=color:#f92672>::</span>si<span style=color:#f92672>::</span>acceleration<span style=color:#f92672>&lt;</span>embed<span style=color:#f92672>::</span>micrometre_per_second_sq, Rep<span style=color:#f92672>&gt;</span>;
</span></span></code></pre></div><h3 id=using-mm_per_s2>using mm_per_s2</h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>template</span> <span style=color:#f92672>&lt;</span>units<span style=color:#f92672>::</span>Representation Rep <span style=color:#f92672>=</span>std<span style=color:#f92672>::</span><span style=color:#66d9ef>int64_t</span><span style=color:#f92672>&gt;</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>using</span> embed<span style=color:#f92672>::</span>mm_per_s2 <span style=color:#f92672>=</span> <span style=color:#66d9ef>typedef</span> units<span style=color:#f92672>::</span>isq<span style=color:#f92672>::</span>si<span style=color:#f92672>::</span>acceleration<span style=color:#f92672>&lt;</span>embed<span style=color:#f92672>::</span>millimetre_per_second_sq, Rep<span style=color:#f92672>&gt;</span>;
</span></span></code></pre></div><h3 id=using-acceleration>using acceleration</h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>using</span> embed<span style=color:#f92672>::</span>acceleration <span style=color:#f92672>=</span> <span style=color:#66d9ef>typedef</span> nm_per_s2<span style=color:#f92672>&lt;</span>std<span style=color:#f92672>::</span><span style=color:#66d9ef>int64_t</span><span style=color:#f92672>&gt;</span>;
</span></span></code></pre></div><p>Universal unit for acceleration.</p><h3 id=using-nk>using nK</h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>template</span> <span style=color:#f92672>&lt;</span>units<span style=color:#f92672>::</span>Representation Rep <span style=color:#f92672>=</span>std<span style=color:#f92672>::</span><span style=color:#66d9ef>int64_t</span><span style=color:#f92672>&gt;</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>using</span> embed<span style=color:#f92672>::</span>nK <span style=color:#f92672>=</span> <span style=color:#66d9ef>typedef</span> units<span style=color:#f92672>::</span>isq<span style=color:#f92672>::</span>si<span style=color:#f92672>::</span>thermodynamic_temperature<span style=color:#f92672>&lt;</span>nanokelvin, Rep<span style=color:#f92672>&gt;</span>;
</span></span></code></pre></div><h3 id=using-uk>using uK</h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>template</span> <span style=color:#f92672>&lt;</span>units<span style=color:#f92672>::</span>Representation Rep <span style=color:#f92672>=</span>std<span style=color:#f92672>::</span><span style=color:#66d9ef>int64_t</span><span style=color:#f92672>&gt;</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>using</span> embed<span style=color:#f92672>::</span>uK <span style=color:#f92672>=</span> <span style=color:#66d9ef>typedef</span> units<span style=color:#f92672>::</span>isq<span style=color:#f92672>::</span>si<span style=color:#f92672>::</span>thermodynamic_temperature<span style=color:#f92672>&lt;</span>microkelvin, Rep<span style=color:#f92672>&gt;</span>;
</span></span></code></pre></div><h3 id=using-mk>using mK</h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>template</span> <span style=color:#f92672>&lt;</span>units<span style=color:#f92672>::</span>Representation Rep <span style=color:#f92672>=</span>std<span style=color:#f92672>::</span><span style=color:#66d9ef>int64_t</span><span style=color:#f92672>&gt;</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>using</span> embed<span style=color:#f92672>::</span>mK <span style=color:#f92672>=</span> <span style=color:#66d9ef>typedef</span> units<span style=color:#f92672>::</span>isq<span style=color:#f92672>::</span>si<span style=color:#f92672>::</span>thermodynamic_temperature<span style=color:#f92672>&lt;</span>millikelvin, Rep<span style=color:#f92672>&gt;</span>;
</span></span></code></pre></div><h3 id=using-temperature>using temperature</h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>using</span> embed<span style=color:#f92672>::</span>temperature <span style=color:#f92672>=</span> <span style=color:#66d9ef>typedef</span> nK<span style=color:#f92672>&lt;</span>std<span style=color:#f92672>::</span><span style=color:#66d9ef>int64_t</span><span style=color:#f92672>&gt;</span>;
</span></span></code></pre></div><p>Universal unit for temperature.</p><h2 id=functions-documentation>Functions Documentation</h2><h3 id=function-generate_field_of_ones>function generate_field_of_ones</h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>template</span> <span style=color:#f92672>&lt;</span>size_t BitWidth,
</span></span><span style=display:flex><span>std<span style=color:#f92672>::</span>integral T<span style=color:#f92672>&gt;</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>consteval</span> T generate_field_of_ones()
</span></span></code></pre></div><p>Generate a mask of 1s at compiletime.</p><p><strong>Template Parameters</strong>:</p><ul><li><strong>BitWidth</strong> - number of 1s in the mask</li><li><strong>T</strong> - the type</li></ul><p><strong>Return</strong>: consteval uint32_t - mask with 1s at the LSB</p><h3 id=function-is_platform>function is_platform</h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>constexpr</span> <span style=color:#66d9ef>bool</span> is_platform(
</span></span><span style=display:flex><span>    std<span style=color:#f92672>::</span>string_view p_platform
</span></span><span style=display:flex><span>)
</span></span></code></pre></div><p>Determines if the current application was built for a specific platform. For example:</p><p><strong>Parameters</strong>:</p><ul><li><strong>p_platform</strong> - platform string pattern to check against</li></ul><p><strong>Return</strong>:</p><ul><li>true - matches the platform string</li><li>false - does not matches the platform string</li></ul><p>embed::is_platform(&ldquo;lpc4078&rdquo;);</p><p>Will return true if the PLATFORM macro defined at compile time was equal to lpc4078. If the developer wants to be less specific, let say, to just determine if the platform is in the lpc40xx family then the following example will work.</p><p>embed::is_platform(&ldquo;lpc40&rdquo;);</p><h3 id=function-is_a_test>function is_a_test</h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>constexpr</span> <span style=color:#66d9ef>bool</span> is_a_test()
</span></span></code></pre></div><p>Determines if the application is a test.</p><p><strong>Return</strong>:</p><ul><li>true - this application is a test</li><li>false - this application is not a test</li></ul><h3 id=function-wait_for>function wait_for</h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>inline</span> boost<span style=color:#f92672>::</span>leaf<span style=color:#f92672>::</span>result<span style=color:#f92672>&lt;</span> <span style=color:#66d9ef>void</span> <span style=color:#f92672>&gt;</span> wait_for(
</span></span><span style=display:flex><span>    counter <span style=color:#f92672>&amp;</span> p_counter,
</span></span><span style=display:flex><span>    std<span style=color:#f92672>::</span>chrono<span style=color:#f92672>::</span>nanoseconds p_wait_duration
</span></span><span style=display:flex><span>)
</span></span></code></pre></div><p>pause execution for this duration of time using a hardware counter object.</p><p><strong>Parameters</strong>:</p><ul><li><strong>p_counter</strong> - hardware counter driver</li><li><strong>p_wait_duration</strong> - the amount of time to pause execution for</li></ul><h3 id=function-set_as_global_sleep>function set_as_global_sleep</h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>inline</span> <span style=color:#66d9ef>void</span> set_as_global_sleep(
</span></span><span style=display:flex><span>    counter <span style=color:#f92672>&amp;</span> p_counter
</span></span><span style=display:flex><span>)
</span></span></code></pre></div><p>Use this counter as the global sleep function.</p><p><strong>Parameters</strong>:</p><ul><li><strong>p_counter</strong> - hardware counter driver</li></ul><p>The counter must be infailable meaning that frequency() and uptime() must never return an error, otherwise the program will abort.</p><h3 id=function-set_as_global_uptime>function set_as_global_uptime</h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>inline</span> <span style=color:#66d9ef>void</span> set_as_global_uptime(
</span></span><span style=display:flex><span>    uptime_counter <span style=color:#f92672>&amp;</span> p_counter
</span></span><span style=display:flex><span>)
</span></span></code></pre></div><p>Use this counter as the global sleep function.</p><p><strong>Parameters</strong>:</p><ul><li><strong>p_counter</strong> - hardware counter driver</li></ul><p>The counter must be infailable meaning that frequency() and uptime() must never return an error, otherwise the program will abort.</p><h3 id=function-value>function value</h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>constexpr</span> <span style=color:#66d9ef>auto</span> value(
</span></span><span style=display:flex><span>    enumeration <span style=color:#66d9ef>auto</span> p_enum_value
</span></span><span style=display:flex><span>)
</span></span></code></pre></div><p>Helper function to convert an enum to its integral value.</p><p><strong>Parameters</strong>:</p><ul><li><strong>p_enum_value</strong> - the enumeration you want to convert into an integral value</li></ul><p><strong>Return</strong>: constexpr auto - return the integral value of the enum with the same type as the enumeration.</p><h3 id=function-write>function write</h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>inline</span> boost<span style=color:#f92672>::</span>leaf<span style=color:#f92672>::</span>result<span style=color:#f92672>&lt;</span> <span style=color:#66d9ef>void</span> <span style=color:#f92672>&gt;</span> write(
</span></span><span style=display:flex><span>    i2c <span style=color:#f92672>&amp;</span> p_i2c,
</span></span><span style=display:flex><span>    std<span style=color:#f92672>::</span>byte p_address,
</span></span><span style=display:flex><span>    std<span style=color:#f92672>::</span>span<span style=color:#f92672>&lt;</span> <span style=color:#66d9ef>const</span> std<span style=color:#f92672>::</span>byte <span style=color:#f92672>&gt;</span> p_data_out
</span></span><span style=display:flex><span>)
</span></span></code></pre></div><p>write data to a target device on the <a href>i2c</a> bus</p><p><strong>Parameters</strong>:</p><ul><li><strong>p_i2c</strong> - <a href=classes/classembed_1_1i2c/>i2c</a> driver</li><li><strong>p_address</strong> - target address</li><li><strong>p_data_out</strong> - buffer of bytes to write to the target device</li></ul><p><strong>Return</strong>: boost::leaf::result - any errors associated with the read call</p><p>Shorthand for writing i2c.transfer(&mldr;) for write only operations</p><h3 id=function-read>function read</h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>inline</span> boost<span style=color:#f92672>::</span>leaf<span style=color:#f92672>::</span>result<span style=color:#f92672>&lt;</span> <span style=color:#66d9ef>void</span> <span style=color:#f92672>&gt;</span> read(
</span></span><span style=display:flex><span>    i2c <span style=color:#f92672>&amp;</span> p_i2c,
</span></span><span style=display:flex><span>    std<span style=color:#f92672>::</span>byte p_address,
</span></span><span style=display:flex><span>    std<span style=color:#f92672>::</span>span<span style=color:#f92672>&lt;</span> std<span style=color:#f92672>::</span>byte <span style=color:#f92672>&gt;</span> p_data_in
</span></span><span style=display:flex><span>)
</span></span></code></pre></div><p>read bytes from target device on <a href>i2c</a> bus</p><p><strong>Parameters</strong>:</p><ul><li><strong>p_i2c</strong> - <a href=classes/classembed_1_1i2c/>i2c</a> driver</li><li><strong>p_address</strong> - target address</li><li><strong>p_data_in</strong> - buffer to read bytes into from target device</li></ul><p><strong>Return</strong>: boost::leaf::result - any errors associated with the read call</p><p>Shorthand for writing i2c.transfer(&mldr;) for read only operations</p><h3 id=function-read-1>function read</h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>template</span> <span style=color:#f92672>&lt;</span>size_t BytesToRead<span style=color:#f92672>&gt;</span>
</span></span><span style=display:flex><span>boost<span style=color:#f92672>::</span>leaf<span style=color:#f92672>::</span>result<span style=color:#f92672>&lt;</span> std<span style=color:#f92672>::</span>array<span style=color:#f92672>&lt;</span> std<span style=color:#f92672>::</span>byte, BytesToRead <span style=color:#f92672>&gt;</span> <span style=color:#f92672>&gt;</span> read(
</span></span><span style=display:flex><span>    i2c <span style=color:#f92672>&amp;</span> p_i2c,
</span></span><span style=display:flex><span>    std<span style=color:#f92672>::</span>byte p_address
</span></span><span style=display:flex><span>)
</span></span></code></pre></div><p>return array of read bytes from target device on <a href>i2c</a> bus</p><p><strong>Parameters</strong>:</p><ul><li><strong>p_i2c</strong> - <a href=classes/classembed_1_1i2c/>i2c</a> driver</li><li><strong>p_address</strong> - target address</li></ul><p><strong>Template Parameters</strong>:</p><ul><li><strong>BytesToRead</strong> - number of bytes to read</li></ul><p><strong>Return</strong>: boost::leaf::result&lt;std::array&lt;std::byte, BytesToRead&#187; - array of bytes from target device or an error.</p><p>Eliminates the need to create a buffer and pass it into the read function.</p><h3 id=function-write_then_read>function write_then_read</h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>inline</span> boost<span style=color:#f92672>::</span>leaf<span style=color:#f92672>::</span>result<span style=color:#f92672>&lt;</span> <span style=color:#66d9ef>void</span> <span style=color:#f92672>&gt;</span> write_then_read(
</span></span><span style=display:flex><span>    i2c <span style=color:#f92672>&amp;</span> p_i2c,
</span></span><span style=display:flex><span>    std<span style=color:#f92672>::</span>byte p_address,
</span></span><span style=display:flex><span>    std<span style=color:#f92672>::</span>span<span style=color:#f92672>&lt;</span> <span style=color:#66d9ef>const</span> std<span style=color:#f92672>::</span>byte <span style=color:#f92672>&gt;</span> p_data_out,
</span></span><span style=display:flex><span>    std<span style=color:#f92672>::</span>span<span style=color:#f92672>&lt;</span> std<span style=color:#f92672>::</span>byte <span style=color:#f92672>&gt;</span> p_data_in
</span></span><span style=display:flex><span>)
</span></span></code></pre></div><p>write and then read bytes from target device on <a href>i2c</a> bus</p><p><strong>Parameters</strong>:</p><ul><li><strong>p_i2c</strong> - <a href=classes/classembed_1_1i2c/>i2c</a> driver</li><li><strong>p_address</strong> - target address</li><li><strong>p_data_out</strong> - buffer of bytes to write to the target device</li><li><strong>p_data_in</strong> - buffer to read bytes into from target device</li></ul><p><strong>Return</strong>: boost::leaf::result - any errors associated with the read call</p><p>This API simply calls transaction. This API is here for consistency across the other other communication protocols such as SPI and serial.</p><h3 id=function-write_then_read-1>function write_then_read</h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>template</span> <span style=color:#f92672>&lt;</span>size_t BytesToRead<span style=color:#f92672>&gt;</span>
</span></span><span style=display:flex><span>boost<span style=color:#f92672>::</span>leaf<span style=color:#f92672>::</span>result<span style=color:#f92672>&lt;</span> std<span style=color:#f92672>::</span>array<span style=color:#f92672>&lt;</span> std<span style=color:#f92672>::</span>byte, BytesToRead <span style=color:#f92672>&gt;</span> <span style=color:#f92672>&gt;</span> write_then_read(
</span></span><span style=display:flex><span>    i2c <span style=color:#f92672>&amp;</span> p_i2c,
</span></span><span style=display:flex><span>    std<span style=color:#f92672>::</span>byte p_address,
</span></span><span style=display:flex><span>    std<span style=color:#f92672>::</span>span<span style=color:#f92672>&lt;</span> <span style=color:#66d9ef>const</span> std<span style=color:#f92672>::</span>byte <span style=color:#f92672>&gt;</span> p_data_out
</span></span><span style=display:flex><span>)
</span></span></code></pre></div><p>write and then return an array of read bytes from target device on <a href>i2c</a> bus</p><p><strong>Parameters</strong>:</p><ul><li><strong>p_i2c</strong> - <a href=classes/classembed_1_1i2c/>i2c</a> driver</li><li><strong>p_address</strong> - target address</li><li><strong>p_data_out</strong> - buffer of bytes to write to the target device</li></ul><p><strong>Template Parameters</strong>:</p><ul><li><strong>BytesToRead</strong> - number of bytes to read after write</li></ul><p><strong>Return</strong>: boost::leaf::result&lt;std::array&lt;std::byte, BytesToRead&#187;</p><p>Eliminates the need to create a buffer and pass it into the read function.</p><h3 id=function-multiply_with_overflow_detection>function multiply_with_overflow_detection</h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>template</span> <span style=color:#f92672>&lt;</span><span style=color:#66d9ef>typename</span> T <span style=color:#f92672>&gt;</span>
</span></span><span style=display:flex><span>boost<span style=color:#f92672>::</span>leaf<span style=color:#f92672>::</span>result<span style=color:#f92672>&lt;</span> T <span style=color:#f92672>&gt;</span> multiply_with_overflow_detection(
</span></span><span style=display:flex><span>    T p_lhs,
</span></span><span style=display:flex><span>    T p_rhs
</span></span><span style=display:flex><span>)
</span></span></code></pre></div><p>Perform multiply operation and return an error code <code>std::errc::result_out_of_range</code> if the two values when multiplied would overflow the containing value.</p><p><strong>Parameters</strong>:</p><ul><li><strong>p_lhs</strong> - left hand side integer</li><li><strong>p_rhs</strong> - right hand side integer</li></ul><p><strong>Template Parameters</strong>:</p><ul><li><strong>T</strong> - integer arithmetic type</li></ul><p><strong>Return</strong>: boost::leaf::result - either the resultant or an error <code>std::errc::result_out_of_range</code></p><h3 id=function-absolute_value>function absolute_value</h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>template</span> <span style=color:#f92672>&lt;</span><span style=color:#66d9ef>typename</span> T <span style=color:#f92672>&gt;</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>constexpr</span> T absolute_value(
</span></span><span style=display:flex><span>    T p_value
</span></span><span style=display:flex><span>)
</span></span></code></pre></div><p>Generic absolute value function that works for integer types. This is preferred over the C API for rounding numbers such as abs(), labs() and llabs(). This function relieves the need in template code to check the type of the integer and select the correct function to call.</p><p><strong>Parameters</strong>:</p><ul><li><strong>p_value</strong> - integer value to be made positive</li></ul><p><strong>Return</strong>: constexpr auto - positive representation of the integer</p><h3 id=function-rounding_division>function rounding_division</h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>template</span> <span style=color:#f92672>&lt;</span><span style=color:#66d9ef>typename</span> T <span style=color:#f92672>&gt;</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>constexpr</span> T rounding_division(
</span></span><span style=display:flex><span>    T p_numerator,
</span></span><span style=display:flex><span>    T p_denominator
</span></span><span style=display:flex><span>)
</span></span></code></pre></div><p>Perform integer division and round the value up if the next decimal place is greater than or equal to 0.5.</p><p><strong>Parameters</strong>:</p><ul><li><strong>p_numerator</strong> - the value to be divided</li><li><strong>p_denominator</strong> - the value to divide the numerator against</li></ul><p><strong>Template Parameters</strong>:</p><ul><li><strong>T</strong> - integral type of the two operands</li></ul><p><strong>Return</strong>: constexpr T - rounded quotent between numerator and denominator. Returns 0 if the denominator is greater than the numerator.</p><h3 id=function-upscale_integer>function upscale_integer</h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>template</span> <span style=color:#f92672>&lt;</span>std<span style=color:#f92672>::</span>integral T,
</span></span><span style=display:flex><span>size_t SourceWidth,
</span></span><span style=display:flex><span>std<span style=color:#f92672>::</span>integral U<span style=color:#f92672>&gt;</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>constexpr</span> T upscale_integer(
</span></span><span style=display:flex><span>    U p_value
</span></span><span style=display:flex><span>)
</span></span></code></pre></div><p>Upscale an integer value of arbitrary bit resolution to a new fixed with integer value.</p><p><strong>Parameters</strong>:</p><ul><li><strong>p_value</strong> - the value to be scaled</li></ul><p><strong>Template Parameters</strong>:</p><ul><li><strong>T</strong> - integral type to bring the resolution of U up to.</li><li><strong>SourceWidth</strong> - the bit resolution of the input value</li><li><strong>U</strong> - integral type of the input value</li></ul><p><strong>Return</strong>: constexpr T - p_value but with resolution scaled up to type T</p><p>The purpose of bit scaling a value is to take a value of lower bit resolution, scale it up but keep the percentage relative to the bits resolution. This is useful for bit resolution erasure as well as image upscaling.</p><p>For example, lets take an 8-bit value of 127 (or 0x7F). This value is 50% of an 8-bit number. 50% of an 32-bit would be 2147483647 or 0x7FFFFFFF which is half of 2^32. A perfect upscaling would take 0x7F and generate 0x7FFFFFFF in this case. Doing so is quite costly and requires multiplication and division operations which are slower opetation.</p><p>Fast and efficient bit scaling is done via bit replication. For example, to scale an 8-bit value up to 32-bits would look like this:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#ae81ff>8</span><span style=color:#f92672>-</span>bit   [ <span style=color:#ae81ff>0x7F</span> ]
</span></span><span style=display:flex><span>           <span style=color:#f92672>|</span><span style=color:#960050;background-color:#1e0010>\\\</span>_____________________
</span></span><span style=display:flex><span>           <span style=color:#f92672>|</span> <span style=color:#960050;background-color:#1e0010>\\</span>___________          \
</span></span><span style=display:flex><span>           <span style=color:#f92672>|</span>  <span style=color:#960050;background-color:#1e0010>\</span>____       <span style=color:#960050;background-color:#1e0010>\</span>          \
</span></span><span style=display:flex><span>           <span style=color:#f92672>|</span>       <span style=color:#960050;background-color:#1e0010>\</span>       <span style=color:#960050;background-color:#1e0010>\</span>          <span style=color:#f92672>|</span>
</span></span><span style=display:flex><span>           <span style=color:#f92672>|</span>        <span style=color:#f92672>|</span>       <span style=color:#f92672>|</span>         <span style=color:#f92672>|</span>
</span></span><span style=display:flex><span>           V        V       V         V
</span></span><span style=display:flex><span><span style=color:#ae81ff>32</span><span style=color:#f92672>-</span>bit  [ <span style=color:#ae81ff>0x7F</span> ] [ <span style=color:#ae81ff>0x7F</span> ] [ <span style=color:#ae81ff>0x7F</span> ] [ <span style=color:#ae81ff>0x7F</span> ]
</span></span></code></pre></div><p>Expected 32-bit value is: 0x7FFFFFFF Actual value from scaling: 0x7F7F7F7F % difference is: (0x7FFFFFFF - 0x7F7F7F7F) / 0x7FFFFFFF = 0.39215684% A percent difference well below 1% makes this a viable solution for most applications.</p><h3 id=function-wait>function wait</h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>inline</span> boost<span style=color:#f92672>::</span>leaf<span style=color:#f92672>::</span>result<span style=color:#f92672>&lt;</span> <span style=color:#66d9ef>void</span> <span style=color:#f92672>&gt;</span> wait(
</span></span><span style=display:flex><span>    serial <span style=color:#f92672>&amp;</span> p_serial,
</span></span><span style=display:flex><span>    size_t p_length,
</span></span><span style=display:flex><span>    std<span style=color:#f92672>::</span>optional<span style=color:#f92672>&lt;</span> std<span style=color:#f92672>::</span>chrono<span style=color:#f92672>::</span>nanoseconds <span style=color:#f92672>&gt;</span> p_timeout <span style=color:#f92672>=</span>std<span style=color:#f92672>::</span>nullopt
</span></span><span style=display:flex><span>)
</span></span></code></pre></div><h3 id=function-write-1>function write</h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>inline</span> boost<span style=color:#f92672>::</span>leaf<span style=color:#f92672>::</span>result<span style=color:#f92672>&lt;</span> <span style=color:#66d9ef>void</span> <span style=color:#f92672>&gt;</span> write(
</span></span><span style=display:flex><span>    serial <span style=color:#f92672>&amp;</span> p_serial,
</span></span><span style=display:flex><span>    std<span style=color:#f92672>::</span>span<span style=color:#f92672>&lt;</span> <span style=color:#66d9ef>const</span> std<span style=color:#f92672>::</span>byte <span style=color:#f92672>&gt;</span> p_data_out
</span></span><span style=display:flex><span>)
</span></span></code></pre></div><h3 id=function-read-2>function read</h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>inline</span> boost<span style=color:#f92672>::</span>leaf<span style=color:#f92672>::</span>result<span style=color:#f92672>&lt;</span> std<span style=color:#f92672>::</span>span<span style=color:#f92672>&lt;</span> <span style=color:#66d9ef>const</span> std<span style=color:#f92672>::</span>byte <span style=color:#f92672>&gt;</span> <span style=color:#f92672>&gt;</span> read(
</span></span><span style=display:flex><span>    serial <span style=color:#f92672>&amp;</span> p_serial,
</span></span><span style=display:flex><span>    std<span style=color:#f92672>::</span>span<span style=color:#f92672>&lt;</span> std<span style=color:#f92672>::</span>byte <span style=color:#f92672>&gt;</span> p_data_in,
</span></span><span style=display:flex><span>    std<span style=color:#f92672>::</span>optional<span style=color:#f92672>&lt;</span> std<span style=color:#f92672>::</span>chrono<span style=color:#f92672>::</span>nanoseconds <span style=color:#f92672>&gt;</span> p_timeout <span style=color:#f92672>=</span>std<span style=color:#f92672>::</span>nullopt
</span></span><span style=display:flex><span>)
</span></span></code></pre></div><h3 id=function-read-3>function read</h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>template</span> <span style=color:#f92672>&lt;</span>size_t BytesToRead<span style=color:#f92672>&gt;</span>
</span></span><span style=display:flex><span>boost<span style=color:#f92672>::</span>leaf<span style=color:#f92672>::</span>result<span style=color:#f92672>&lt;</span> std<span style=color:#f92672>::</span>array<span style=color:#f92672>&lt;</span> std<span style=color:#f92672>::</span>byte, BytesToRead <span style=color:#f92672>&gt;</span> <span style=color:#f92672>&gt;</span> read(
</span></span><span style=display:flex><span>    serial <span style=color:#f92672>&amp;</span> p_serial,
</span></span><span style=display:flex><span>    std<span style=color:#f92672>::</span>optional<span style=color:#f92672>&lt;</span> std<span style=color:#f92672>::</span>chrono<span style=color:#f92672>::</span>nanoseconds <span style=color:#f92672>&gt;</span> p_timeout <span style=color:#f92672>=</span>std<span style=color:#f92672>::</span>nullopt
</span></span><span style=display:flex><span>)
</span></span></code></pre></div><h3 id=function-write_then_read-2>function write_then_read</h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>inline</span> boost<span style=color:#f92672>::</span>leaf<span style=color:#f92672>::</span>result<span style=color:#f92672>&lt;</span> <span style=color:#66d9ef>void</span> <span style=color:#f92672>&gt;</span> write_then_read(
</span></span><span style=display:flex><span>    serial <span style=color:#f92672>&amp;</span> p_serial,
</span></span><span style=display:flex><span>    std<span style=color:#f92672>::</span>span<span style=color:#f92672>&lt;</span> <span style=color:#66d9ef>const</span> std<span style=color:#f92672>::</span>byte <span style=color:#f92672>&gt;</span> p_data_out,
</span></span><span style=display:flex><span>    std<span style=color:#f92672>::</span>span<span style=color:#f92672>&lt;</span> std<span style=color:#f92672>::</span>byte <span style=color:#f92672>&gt;</span> p_data_in,
</span></span><span style=display:flex><span>    std<span style=color:#f92672>::</span>optional<span style=color:#f92672>&lt;</span> std<span style=color:#f92672>::</span>chrono<span style=color:#f92672>::</span>nanoseconds <span style=color:#f92672>&gt;</span> p_timeout <span style=color:#f92672>=</span>std<span style=color:#f92672>::</span>nullopt
</span></span><span style=display:flex><span>)
</span></span></code></pre></div><h3 id=function-write_then_read-3>function write_then_read</h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>template</span> <span style=color:#f92672>&lt;</span>size_t BytesToRead<span style=color:#f92672>&gt;</span>
</span></span><span style=display:flex><span>boost<span style=color:#f92672>::</span>leaf<span style=color:#f92672>::</span>result<span style=color:#f92672>&lt;</span> std<span style=color:#f92672>::</span>array<span style=color:#f92672>&lt;</span> std<span style=color:#f92672>::</span>byte, BytesToRead <span style=color:#f92672>&gt;</span> <span style=color:#f92672>&gt;</span> write_then_read(
</span></span><span style=display:flex><span>    serial <span style=color:#f92672>&amp;</span> p_serial,
</span></span><span style=display:flex><span>    std<span style=color:#f92672>::</span>span<span style=color:#f92672>&lt;</span> <span style=color:#66d9ef>const</span> std<span style=color:#f92672>::</span>byte <span style=color:#f92672>&gt;</span> p_data_out,
</span></span><span style=display:flex><span>    std<span style=color:#f92672>::</span>optional<span style=color:#f92672>&lt;</span> std<span style=color:#f92672>::</span>chrono<span style=color:#f92672>::</span>nanoseconds <span style=color:#f92672>&gt;</span> p_timeout <span style=color:#f92672>=</span>std<span style=color:#f92672>::</span>nullopt
</span></span><span style=display:flex><span>)
</span></span></code></pre></div><h3 id=function-write-2>function write</h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>inline</span> boost<span style=color:#f92672>::</span>leaf<span style=color:#f92672>::</span>result<span style=color:#f92672>&lt;</span> <span style=color:#66d9ef>void</span> <span style=color:#f92672>&gt;</span> write(
</span></span><span style=display:flex><span>    spi <span style=color:#f92672>&amp;</span> p_spi,
</span></span><span style=display:flex><span>    std<span style=color:#f92672>::</span>span<span style=color:#f92672>&lt;</span> <span style=color:#66d9ef>const</span> std<span style=color:#f92672>::</span>byte <span style=color:#f92672>&gt;</span> p_data_out
</span></span><span style=display:flex><span>)
</span></span></code></pre></div><p>Write data to the SPI bus and ignore data sent from peripherals on the bus.</p><p><strong>Parameters</strong>:</p><ul><li><strong>p_spi</strong> - spi driver</li><li><strong>p_data_out</strong> - data to be written to the SPI bus</li></ul><p><strong>Return</strong>: boost::leaf::result - any errors associated with this call</p><h3 id=function-read-4>function read</h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>inline</span> boost<span style=color:#f92672>::</span>leaf<span style=color:#f92672>::</span>result<span style=color:#f92672>&lt;</span> <span style=color:#66d9ef>void</span> <span style=color:#f92672>&gt;</span> read(
</span></span><span style=display:flex><span>    spi <span style=color:#f92672>&amp;</span> p_spi,
</span></span><span style=display:flex><span>    std<span style=color:#f92672>::</span>span<span style=color:#f92672>&lt;</span> std<span style=color:#f92672>::</span>byte <span style=color:#f92672>&gt;</span> p_data_in,
</span></span><span style=display:flex><span>    std<span style=color:#f92672>::</span>byte p_filler <span style=color:#f92672>=</span>spi<span style=color:#f92672>::</span>default_filler
</span></span><span style=display:flex><span>)
</span></span></code></pre></div><p>Read data from the SPI bus.</p><p><strong>Parameters</strong>:</p><ul><li><strong>p_spi</strong> - spi driver</li><li><strong>p_data_in</strong> - buffer to receive bytes back from the SPI bus</li><li><strong>p_filler</strong> - filler data placed on the bus in place of actual write data.</li></ul><p><strong>Return</strong>: boost::leaf::result - any errors associated with this call</p><p>Filler bytes will be placed on the write line.</p><h3 id=function-read-5>function read</h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>template</span> <span style=color:#f92672>&lt;</span>size_t BytesToRead<span style=color:#f92672>&gt;</span>
</span></span><span style=display:flex><span>boost<span style=color:#f92672>::</span>leaf<span style=color:#f92672>::</span>result<span style=color:#f92672>&lt;</span> std<span style=color:#f92672>::</span>array<span style=color:#f92672>&lt;</span> std<span style=color:#f92672>::</span>byte, BytesToRead <span style=color:#f92672>&gt;</span> <span style=color:#f92672>&gt;</span> read(
</span></span><span style=display:flex><span>    spi <span style=color:#f92672>&amp;</span> p_spi,
</span></span><span style=display:flex><span>    std<span style=color:#f92672>::</span>byte p_filler <span style=color:#f92672>=</span>spi<span style=color:#f92672>::</span>default_filler
</span></span><span style=display:flex><span>)
</span></span></code></pre></div><p>Read data from the SPI bus and return a std::array of bytes.</p><p><strong>Parameters</strong>:</p><ul><li><strong>p_spi</strong> - spi driver</li><li><strong>p_filler</strong> - filler data placed on the bus in place of actual write data.</li></ul><p><strong>Template Parameters</strong>:</p><ul><li><strong>BytesToRead</strong> - Number of bytes to read</li></ul><p><strong>Return</strong>: boost::leaf::result&lt;std::array&lt;std::byte, BytesToRead&#187; - any errors associated with this call</p><p>Filler bytes will be placed on the write line.</p><h3 id=function-write_then_read-4>function write_then_read</h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>inline</span> boost<span style=color:#f92672>::</span>leaf<span style=color:#f92672>::</span>result<span style=color:#f92672>&lt;</span> <span style=color:#66d9ef>void</span> <span style=color:#f92672>&gt;</span> write_then_read(
</span></span><span style=display:flex><span>    spi <span style=color:#f92672>&amp;</span> p_spi,
</span></span><span style=display:flex><span>    std<span style=color:#f92672>::</span>span<span style=color:#f92672>&lt;</span> <span style=color:#66d9ef>const</span> std<span style=color:#f92672>::</span>byte <span style=color:#f92672>&gt;</span> p_data_out,
</span></span><span style=display:flex><span>    std<span style=color:#f92672>::</span>span<span style=color:#f92672>&lt;</span> std<span style=color:#f92672>::</span>byte <span style=color:#f92672>&gt;</span> p_data_in,
</span></span><span style=display:flex><span>    std<span style=color:#f92672>::</span>byte p_filler <span style=color:#f92672>=</span>spi<span style=color:#f92672>::</span>default_filler
</span></span><span style=display:flex><span>)
</span></span></code></pre></div><p>Write data to the SPI bus and ignore data sent from peripherals on the bus then read data from the SPI and fill the write line with filler bytes.</p><p><strong>Parameters</strong>:</p><ul><li><strong>p_spi</strong> - spi driver</li><li><strong>p_data_out</strong> - bytes to write to the bus</li><li><strong>p_data_in</strong> - buffer to receive bytes back from the SPI bus</li><li><strong>p_filler</strong> - filler data placed on the bus when the read operation begins.</li></ul><p><strong>Return</strong>: boost::leaf::result</p><p>This utility function that fits the use case of many SPI devices where a transaction is not full duplex. In many spi devices, full duplex means that as data is being written to the SPI bus, the peripheral device is sending data back on the read line. In most cases, the protocol is to write data to the bus, and ignore the read line because the peripheral is not writing anything meaningful to that line, then reading from SPI bus and writing nothing meaningful to the write line as the peripheral is ignoring that line.</p><h3 id=function-write_then_read-5>function write_then_read</h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>template</span> <span style=color:#f92672>&lt;</span>size_t BytesToRead<span style=color:#f92672>&gt;</span>
</span></span><span style=display:flex><span>boost<span style=color:#f92672>::</span>leaf<span style=color:#f92672>::</span>result<span style=color:#f92672>&lt;</span> std<span style=color:#f92672>::</span>array<span style=color:#f92672>&lt;</span> std<span style=color:#f92672>::</span>byte, BytesToRead <span style=color:#f92672>&gt;</span> <span style=color:#f92672>&gt;</span> write_then_read(
</span></span><span style=display:flex><span>    spi <span style=color:#f92672>&amp;</span> p_spi,
</span></span><span style=display:flex><span>    std<span style=color:#f92672>::</span>span<span style=color:#f92672>&lt;</span> <span style=color:#66d9ef>const</span> std<span style=color:#f92672>::</span>byte <span style=color:#f92672>&gt;</span> p_data_out,
</span></span><span style=display:flex><span>    std<span style=color:#f92672>::</span>byte p_filler <span style=color:#f92672>=</span>spi<span style=color:#f92672>::</span>default_filler
</span></span><span style=display:flex><span>)
</span></span></code></pre></div><p>Write data to the SPI bus and ignore data sent from peripherals on the bus then read data from the SPI, fill the write line with filler bytes and return an array of bytes.</p><p><strong>Parameters</strong>:</p><ul><li><strong>p_spi</strong> - spi driver</li><li><strong>p_data_out</strong> - bytes to write to the bus</li><li><strong>p_filler</strong> - filler data placed on the bus when the read operation begins.</li></ul><p><strong>Template Parameters</strong>:</p><ul><li><strong>BytesToRead</strong> - Number of bytes to read from the bus</li></ul><p><strong>Return</strong>: boost::leaf::result&lt;std::array&lt;std::byte, BytesToRead&#187;</p><h3 id=function-to_array>function to_array</h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>template</span> <span style=color:#f92672>&lt;</span>size_t N<span style=color:#f92672>&gt;</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>constexpr</span> std<span style=color:#f92672>::</span>array<span style=color:#f92672>&lt;</span> <span style=color:#66d9ef>char</span>, N<span style=color:#f92672>+</span><span style=color:#ae81ff>1</span> <span style=color:#f92672>&gt;</span> to_array(
</span></span><span style=display:flex><span>    std<span style=color:#f92672>::</span>string_view p_view
</span></span><span style=display:flex><span>)
</span></span></code></pre></div><p>Convert a string_view into a std::array of N number of characters.</p><p><strong>Parameters</strong>:</p><ul><li><strong>p_view</strong> - string to be placed into a char array</li></ul><p><strong>Template Parameters</strong>:</p><ul><li><strong>N</strong> - Size of the array</li></ul><p><strong>Return</strong>: constexpr std::array&lt;char, N + 1> - the char array object</p><p>Will always ensure that the array is null terminated</p><h2 id=attributes-documentation>Attributes Documentation</h2><h3 id=variable-default_clock_rate>variable default_clock_rate</h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>constexpr</span> frequency default_clock_rate <span style=color:#f92672>=</span> frequency(<span style=color:#ae81ff>100&#39;000</span>);
</span></span></code></pre></div><p>Default clock rate for serial communication protocols.</p><hr><p>Updated on 2022-05-08 at 12:08:21 +0000</p><footer class=footline></footer></main></div><div id=navigation><a class="nav nav-prev" href=/libembeddedhal/api/namespaces/ title=Namespaces><i class="fa fa-chevron-left"></i></a>
<a class="nav nav-next" href=/libembeddedhal/api/namespaces/namespaceembed_1_1config/ title=embed::config><i class="fa fa-chevron-right"></i></a></div></div><div style=left:-1000px;overflow:scroll;position:absolute;top:-1000px;border:none;box-sizing:content-box;height:200px;margin:0;padding:0;width:200px><div style=border:none;box-sizing:content-box;height:200px;margin:0;padding:0;width:200px></div></div><script src=/libembeddedhal/js/clipboard.min.js?1652011702></script>
<script src=/libembeddedhal/js/perfect-scrollbar.min.js?1652011702></script>
<script src=/libembeddedhal/js/perfect-scrollbar.jquery.min.js?1652011702></script>
<script src=/libembeddedhal/js/jquery.svg.pan.zoom.js?1652011702></script>
<script src=/libembeddedhal/js/featherlight.min.js?1652011702></script>
<script src=/libembeddedhal/js/modernizr.custom-3.6.0.js?1652011702></script>
<script src=/libembeddedhal/js/mermaid.min.js?1652011702></script>
<script>typeof mermaid!="undefined"&&typeof mermaid.mermaidAPI!="undefined"&&mermaid.mermaidAPI.initialize(Object.assign({securityLevel:"antiscript"},JSON.parse('{ "startOnLoad": true }'),{startOnLoad:!1}))</script><script src=/libembeddedhal/js/relearn.js?1652011702></script></body></html>