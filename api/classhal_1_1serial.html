<!-- HTML header for doxygen 1.9.2-->
<!DOCTYPE html
  PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=11" />
  <meta name="generator" content="Doxygen 1.9.4" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>libembeddedhal: hal::serial Class Reference</title>
  <link href="tabs.css" rel="stylesheet" type="text/css" />
  <script type="text/javascript" src="jquery.js"></script>
  <script type="text/javascript" src="dynsections.js"></script>
  <link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
  <link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
  <link href="doxygen.css" rel="stylesheet" type="text/css" />
  <link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only-darkmode-toggle.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only-darkmode-toggle.css" rel="stylesheet" type="text/css"/>
  <script type="text/javascript" src="doxygen-awesome-darkmode-toggle.js"></script>
  <script type="text/javascript">
    DoxygenAwesomeDarkModeToggle.init()
  </script>
</head>
<body>
    <div id="top">
      <!-- do not remove this div, it is closed by doxygen! -->
      <div id="titlearea">
        <table cellspacing="0" cellpadding="0">
          <tbody>
            <tr style="height: 56px;">
              <td id="projectalign" style="padding-left: 0.5em;">
                <div id="projectname">libembeddedhal
                </div>
              </td>
            </tr>
          </tbody>
        </table>
      </div>
      <!-- end header part --><!-- Generated by Doxygen 1.9.4 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search",'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('classhal_1_1serial.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classhal_1_1serial-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">hal::serial Class Reference<span class="mlabels"><span class="mlabel">abstract</span></span><div class="ingroups"><a class="el" href="group__serial.html">Serial</a></div></div></div>
</div><!--header-->
<div class="contents">

<p>Hardware abstract interface for the serial communication protocol.  
 <a href="classhal_1_1serial.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="serial_2interface_8hpp_source.html">interface.hpp</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhal_1_1serial_1_1settings.html">settings</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generic settings for a standard serial device.  <a href="structhal_1_1serial_1_1settings.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ad3d247776562df9621fd002333677ca5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacehal.html#a1607e3547737e35235f946a9c67b61cf">status</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhal_1_1serial.html#ad3d247776562df9621fd002333677ca5">configure</a> (const <a class="el" href="structhal_1_1serial_1_1settings.html">settings</a> &amp;p_settings) noexcept</td></tr>
<tr class="memdesc:ad3d247776562df9621fd002333677ca5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Configure serial to match the settings supplied.  <a href="classhal_1_1serial.html#ad3d247776562df9621fd002333677ca5">More...</a><br /></td></tr>
<tr class="separator:ad3d247776562df9621fd002333677ca5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e7d62bd7dcddc296b6a26021b906066"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacehal.html#a1607e3547737e35235f946a9c67b61cf">status</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhal_1_1serial.html#a6e7d62bd7dcddc296b6a26021b906066">write</a> (std::span&lt; const std::byte &gt; p_data) noexcept</td></tr>
<tr class="memdesc:a6e7d62bd7dcddc296b6a26021b906066"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write data on the transmitter line of the port.  <a href="classhal_1_1serial.html#a6e7d62bd7dcddc296b6a26021b906066">More...</a><br /></td></tr>
<tr class="separator:a6e7d62bd7dcddc296b6a26021b906066"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4396089965fb9870d7862cd79edfed5c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacehal.html#a22b1708df761b2dc40dd4afa2ac0c401">result</a>&lt; size_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhal_1_1serial.html#a4396089965fb9870d7862cd79edfed5c">bytes_available</a> () noexcept</td></tr>
<tr class="memdesc:a4396089965fb9870d7862cd79edfed5c"><td class="mdescLeft">&#160;</td><td class="mdescRight">The number of bytes that have been buffered.  <a href="classhal_1_1serial.html#a4396089965fb9870d7862cd79edfed5c">More...</a><br /></td></tr>
<tr class="separator:a4396089965fb9870d7862cd79edfed5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac1c941f689f8825be0f699e371e3c51"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacehal.html#a22b1708df761b2dc40dd4afa2ac0c401">result</a>&lt; std::span&lt; const std::byte &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhal_1_1serial.html#aac1c941f689f8825be0f699e371e3c51">read</a> (std::span&lt; std::byte &gt; p_data) noexcept</td></tr>
<tr class="memdesc:aac1c941f689f8825be0f699e371e3c51"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read the bytes received over the receiver line into buffer.  <a href="classhal_1_1serial.html#aac1c941f689f8825be0f699e371e3c51">More...</a><br /></td></tr>
<tr class="separator:aac1c941f689f8825be0f699e371e3c51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a808aec1ec3948baf8b55d115fc3a17da"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacehal.html#a1607e3547737e35235f946a9c67b61cf">status</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhal_1_1serial.html#a808aec1ec3948baf8b55d115fc3a17da">flush</a> () noexcept</td></tr>
<tr class="memdesc:a808aec1ec3948baf8b55d115fc3a17da"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set <a class="el" href="classhal_1_1serial.html#a4396089965fb9870d7862cd79edfed5c" title="The number of bytes that have been buffered.">bytes_available()</a> to zero and clear any received data stored in hardware registers.  <a href="classhal_1_1serial.html#a808aec1ec3948baf8b55d115fc3a17da">More...</a><br /></td></tr>
<tr class="separator:a808aec1ec3948baf8b55d115fc3a17da"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p >Hardware abstract interface for the serial communication protocol. </p>
<p >Use this interface for hardware that implements a serial protocol like UART, RS232, RS485 and others that use a similar communication protocol but may use different voltage schemes.</p>
<p >This interface only works 8-bit serial data frames.</p>
<p >Due to the asynchronous nature of serial communication protocols, all implementations of serial devices must be buffered. Buffered, in this case, is defined as automatic storage of received bytes without direct application intervention.</p>
<p >All implementations MUST allow the user to supply their own buffer of arbitrary size up to the limits of what hardware can support. This allows a developer the ability to tailored the buffer size to the needs of the application.</p>
<p >Examples of buffering schemes are:</p>
<ul>
<li>Using DMA to copy data from a serial peripheral to a region of memory</li>
<li>Using interrupts when a serial peripheral's queue has filled to a point </li>
</ul>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a id="a4396089965fb9870d7862cd79edfed5c" name="a4396089965fb9870d7862cd79edfed5c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4396089965fb9870d7862cd79edfed5c">&#9670;&nbsp;</a></span>bytes_available()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacehal.html#a22b1708df761b2dc40dd4afa2ac0c401">result</a>&lt; size_t &gt; hal::serial::bytes_available </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The number of bytes that have been buffered. </p>
<dl class="section return"><dt>Returns</dt><dd>result&lt;size_t&gt; - number of bytes that can be read out of this serial port. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::errc::protocol_error</td><td>indicates that a parity error occurred during reception. </td></tr>
    <tr><td class="paramname">std::errc::io_error</td><td>indicates that a frame error occurred during reception. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad3d247776562df9621fd002333677ca5" name="ad3d247776562df9621fd002333677ca5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad3d247776562df9621fd002333677ca5">&#9670;&nbsp;</a></span>configure()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacehal.html#a1607e3547737e35235f946a9c67b61cf">status</a> hal::serial::configure </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structhal_1_1serial_1_1settings.html">settings</a> &amp;&#160;</td>
          <td class="paramname"><em>p_settings</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Configure serial to match the settings supplied. </p>
<p >Implementing drivers must verify if the settings can be applied to hardware before modifying the hardware. This will ensure that if this operation fails, the state of the serial device has not changed.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p_settings</td><td>- settings to apply to serial driver </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>status </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::errc::invalid_argument</td><td>if the settings could not be achieved </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a808aec1ec3948baf8b55d115fc3a17da" name="a808aec1ec3948baf8b55d115fc3a17da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a808aec1ec3948baf8b55d115fc3a17da">&#9670;&nbsp;</a></span>flush()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacehal.html#a1607e3547737e35235f946a9c67b61cf">status</a> hal::serial::flush </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set <a class="el" href="classhal_1_1serial.html#a4396089965fb9870d7862cd79edfed5c" title="The number of bytes that have been buffered.">bytes_available()</a> to zero and clear any received data stored in hardware registers. </p>
<dl class="section return"><dt>Returns</dt><dd>status </dd></dl>

</div>
</div>
<a id="aac1c941f689f8825be0f699e371e3c51" name="aac1c941f689f8825be0f699e371e3c51"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aac1c941f689f8825be0f699e371e3c51">&#9670;&nbsp;</a></span>read()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacehal.html#a22b1708df761b2dc40dd4afa2ac0c401">result</a>&lt; std::span&lt; const std::byte &gt; &gt; hal::serial::read </td>
          <td>(</td>
          <td class="paramtype">std::span&lt; std::byte &gt;&#160;</td>
          <td class="paramname"><em>p_data</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Read the bytes received over the receiver line into buffer. </p>
<p >This operation copies the bytes from the serial driver's internal buffer to the buffer supplied. This call will subtract from the number returned from <a class="el" href="classhal_1_1serial.html#a4396089965fb9870d7862cd79edfed5c" title="The number of bytes that have been buffered.">bytes_available()</a> function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p_data</td><td>- Buffer to read bytes back from. If the length of this buffer is greater than bytes available, then the buffer is filled up to the length returned by <a class="el" href="classhal_1_1serial.html#a4396089965fb9870d7862cd79edfed5c" title="The number of bytes that have been buffered.">bytes_available()</a>. The rest of the buffer is left untouched. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="namespacehal.html#a22b1708df761b2dc40dd4afa2ac0c401">result&lt;std::span&lt;const std::byte&gt;&gt;</a> - The address will ALWAYS be the same as p_data and the length will be equal to the number of bytes read from the buffer. </dd></dl>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classhal_1_1serial_aac1c941f689f8825be0f699e371e3c51_icgraph.svg" width="236" height="38"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="a6e7d62bd7dcddc296b6a26021b906066" name="a6e7d62bd7dcddc296b6a26021b906066"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6e7d62bd7dcddc296b6a26021b906066">&#9670;&nbsp;</a></span>write()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacehal.html#a1607e3547737e35235f946a9c67b61cf">status</a> hal::serial::write </td>
          <td>(</td>
          <td class="paramtype">std::span&lt; const std::byte &gt;&#160;</td>
          <td class="paramname"><em>p_data</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Write data on the transmitter line of the port. </p>
<p >This function will block until the entire transfer is finished.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p_data</td><td>- data to be transmitted over the serial port </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>status </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>/github/workspace/include/libembeddedhal/serial/<a class="el" href="serial_2interface_8hpp_source.html">interface.hpp</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespacehal.html">hal</a></li><li class="navelem"><a class="el" href="classhal_1_1serial.html">serial</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.4 </li>
  </ul>
</div>
</body>
</html>
