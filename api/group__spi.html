<!-- HTML header for doxygen 1.9.2-->
<!DOCTYPE html
  PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=11" />
  <meta name="generator" content="Doxygen 1.9.4" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>libembeddedhal: Spi</title>
  <link href="tabs.css" rel="stylesheet" type="text/css" />
  <script type="text/javascript" src="jquery.js"></script>
  <script type="text/javascript" src="dynsections.js"></script>
  <link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
  <link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
  <link href="doxygen.css" rel="stylesheet" type="text/css" />
  <link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only-darkmode-toggle.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only-darkmode-toggle.css" rel="stylesheet" type="text/css"/>
  <script type="text/javascript" src="doxygen-awesome-darkmode-toggle.js"></script>
  <script type="text/javascript">
    DoxygenAwesomeDarkModeToggle.init()
  </script>
</head>
<body>
    <div id="top">
      <!-- do not remove this div, it is closed by doxygen! -->
      <div id="titlearea">
        <table cellspacing="0" cellpadding="0">
          <tbody>
            <tr style="height: 56px;">
              <td id="projectalign" style="padding-left: 0.5em;">
                <div id="projectname">libembeddedhal
                </div>
              </td>
            </tr>
          </tbody>
        </table>
      </div>
      <!-- end header part --><!-- Generated by Doxygen 1.9.4 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search",'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('group__spi.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">Spi</div></div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classembed_1_1spi.html">embed::spi</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Serial peripheral interface (SPI) communication protocol hardware abstract interface.  <a href="classembed_1_1spi.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structembed_1_1mock_1_1write__only__spi.html">embed::mock::write_only_spi</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mock spi implementation for use in unit tests and simulations with a spy functions for <a class="el" href="classembed_1_1spi.html#a4bf0b00fba6ab98ddddbe35aa2613b34" title="Configure spi to match the settings supplied.">configure()</a> and a record for the <a class="el" href="classembed_1_1spi.html#aa1c8496025bee3c20b2e6167aac14b34" title="Send and receive data between a selected device on the spi bus. This function will block until the en...">transfer()</a> out data. The record ignores the in buffer and just stores the data being sent so it can be inspected later.  <a href="structembed_1_1mock_1_1write__only__spi.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga08cb65267b0814b8ca7215f7efc5a2e3"><td class="memItemLeft" align="right" valign="top">boost::leaf::result&lt; void &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__spi.html#ga08cb65267b0814b8ca7215f7efc5a2e3">embed::write</a> (<a class="el" href="classembed_1_1spi.html">spi</a> &amp;p_spi, std::span&lt; const std::byte &gt; p_data_out) noexcept</td></tr>
<tr class="memdesc:ga08cb65267b0814b8ca7215f7efc5a2e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write data to the SPI bus and ignore data sent from peripherals on the bus.  <a href="group__spi.html#ga08cb65267b0814b8ca7215f7efc5a2e3">More...</a><br /></td></tr>
<tr class="separator:ga08cb65267b0814b8ca7215f7efc5a2e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafc3ba828668c22d0f6c5e3a2349e2671"><td class="memItemLeft" align="right" valign="top">boost::leaf::result&lt; void &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__spi.html#gafc3ba828668c22d0f6c5e3a2349e2671">embed::read</a> (<a class="el" href="classembed_1_1spi.html">spi</a> &amp;p_spi, std::span&lt; std::byte &gt; p_data_in, std::byte p_filler=<a class="el" href="classembed_1_1spi.html#a6efdb2425adcb00811b99e88cf8893bf">spi::default_filler</a>) noexcept</td></tr>
<tr class="memdesc:gafc3ba828668c22d0f6c5e3a2349e2671"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read data from the SPI bus.  <a href="group__spi.html#gafc3ba828668c22d0f6c5e3a2349e2671">More...</a><br /></td></tr>
<tr class="separator:gafc3ba828668c22d0f6c5e3a2349e2671"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga607a4ee40654d534bbceca31c0fb4cda"><td class="memTemplParams" colspan="2">template&lt;size_t BytesToRead&gt; </td></tr>
<tr class="memitem:ga607a4ee40654d534bbceca31c0fb4cda"><td class="memTemplItemLeft" align="right" valign="top">boost::leaf::result&lt; std::array&lt; std::byte, BytesToRead &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__spi.html#ga607a4ee40654d534bbceca31c0fb4cda">embed::read</a> (<a class="el" href="classembed_1_1spi.html">spi</a> &amp;p_spi, std::byte p_filler=<a class="el" href="classembed_1_1spi.html#a6efdb2425adcb00811b99e88cf8893bf">spi::default_filler</a>) noexcept</td></tr>
<tr class="memdesc:ga607a4ee40654d534bbceca31c0fb4cda"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read data from the SPI bus and return a std::array of bytes.  <a href="group__spi.html#ga607a4ee40654d534bbceca31c0fb4cda">More...</a><br /></td></tr>
<tr class="separator:ga607a4ee40654d534bbceca31c0fb4cda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae9ae311fd79b085710fca67dcb4ff2a0"><td class="memItemLeft" align="right" valign="top">boost::leaf::result&lt; void &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__spi.html#gae9ae311fd79b085710fca67dcb4ff2a0">embed::write_then_read</a> (<a class="el" href="classembed_1_1spi.html">spi</a> &amp;p_spi, std::span&lt; const std::byte &gt; p_data_out, std::span&lt; std::byte &gt; p_data_in, std::byte p_filler=<a class="el" href="classembed_1_1spi.html#a6efdb2425adcb00811b99e88cf8893bf">spi::default_filler</a>) noexcept</td></tr>
<tr class="memdesc:gae9ae311fd79b085710fca67dcb4ff2a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write data to the SPI bus and ignore data sent from peripherals on the bus then read data from the SPI and fill the write line with filler bytes.  <a href="group__spi.html#gae9ae311fd79b085710fca67dcb4ff2a0">More...</a><br /></td></tr>
<tr class="separator:gae9ae311fd79b085710fca67dcb4ff2a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1bca4125f1f3e8c96cc7449883d1c515"><td class="memTemplParams" colspan="2">template&lt;size_t BytesToRead&gt; </td></tr>
<tr class="memitem:ga1bca4125f1f3e8c96cc7449883d1c515"><td class="memTemplItemLeft" align="right" valign="top">boost::leaf::result&lt; std::array&lt; std::byte, BytesToRead &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__spi.html#ga1bca4125f1f3e8c96cc7449883d1c515">embed::write_then_read</a> (<a class="el" href="classembed_1_1spi.html">spi</a> &amp;p_spi, std::span&lt; const std::byte &gt; p_data_out, std::byte p_filler=<a class="el" href="classembed_1_1spi.html#a6efdb2425adcb00811b99e88cf8893bf">spi::default_filler</a>) noexcept</td></tr>
<tr class="memdesc:ga1bca4125f1f3e8c96cc7449883d1c515"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write data to the SPI bus and ignore data sent from peripherals on the bus then read data from the SPI, fill the write line with filler bytes and return an array of bytes.  <a href="group__spi.html#ga1bca4125f1f3e8c96cc7449883d1c515">More...</a><br /></td></tr>
<tr class="separator:ga1bca4125f1f3e8c96cc7449883d1c515"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p >Available spi APIs </p>
<h2 class="groupheader">Function Documentation</h2>
<a id="ga607a4ee40654d534bbceca31c0fb4cda" name="ga607a4ee40654d534bbceca31c0fb4cda"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga607a4ee40654d534bbceca31c0fb4cda">&#9670;&nbsp;</a></span>read() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t BytesToRead&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">boost::leaf::result&lt; std::array&lt; std::byte, BytesToRead &gt; &gt; embed::read </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classembed_1_1spi.html">spi</a> &amp;&#160;</td>
          <td class="paramname"><em>p_spi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::byte&#160;</td>
          <td class="paramname"><em>p_filler</em> = <code><a class="el" href="classembed_1_1spi.html#a6efdb2425adcb00811b99e88cf8893bf">spi::default_filler</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Read data from the SPI bus and return a std::array of bytes. </p>
<p >Filler bytes will be placed on the write line.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">BytesToRead</td><td>- Number of bytes to read </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p_spi</td><td>- spi driver </td></tr>
    <tr><td class="paramname">p_filler</td><td>- filler data placed on the bus in place of actual write data. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>boost::leaf::result&lt;std::array&lt;std::byte, BytesToRead&gt;&gt; - any errors associated with this call </dd></dl>

</div>
</div>
<a id="gafc3ba828668c22d0f6c5e3a2349e2671" name="gafc3ba828668c22d0f6c5e3a2349e2671"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafc3ba828668c22d0f6c5e3a2349e2671">&#9670;&nbsp;</a></span>read() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">boost::leaf::result&lt; void &gt; embed::read </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classembed_1_1spi.html">spi</a> &amp;&#160;</td>
          <td class="paramname"><em>p_spi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::span&lt; std::byte &gt;&#160;</td>
          <td class="paramname"><em>p_data_in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::byte&#160;</td>
          <td class="paramname"><em>p_filler</em> = <code><a class="el" href="classembed_1_1spi.html#a6efdb2425adcb00811b99e88cf8893bf">spi::default_filler</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Read data from the SPI bus. </p>
<p >Filler bytes will be placed on the write line.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p_spi</td><td>- spi driver </td></tr>
    <tr><td class="paramname">p_data_in</td><td>- buffer to receive bytes back from the SPI bus </td></tr>
    <tr><td class="paramname">p_filler</td><td>- filler data placed on the bus in place of actual write data. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>boost::leaf::result&lt;void&gt; - any errors associated with this call </dd></dl>

</div>
</div>
<a id="ga08cb65267b0814b8ca7215f7efc5a2e3" name="ga08cb65267b0814b8ca7215f7efc5a2e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga08cb65267b0814b8ca7215f7efc5a2e3">&#9670;&nbsp;</a></span>write()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">boost::leaf::result&lt; void &gt; embed::write </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classembed_1_1spi.html">spi</a> &amp;&#160;</td>
          <td class="paramname"><em>p_spi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::span&lt; const std::byte &gt;&#160;</td>
          <td class="paramname"><em>p_data_out</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Write data to the SPI bus and ignore data sent from peripherals on the bus. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p_spi</td><td>- spi driver </td></tr>
    <tr><td class="paramname">p_data_out</td><td>- data to be written to the SPI bus </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>boost::leaf::result&lt;void&gt; - any errors associated with this call </dd></dl>

</div>
</div>
<a id="ga1bca4125f1f3e8c96cc7449883d1c515" name="ga1bca4125f1f3e8c96cc7449883d1c515"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1bca4125f1f3e8c96cc7449883d1c515">&#9670;&nbsp;</a></span>write_then_read() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t BytesToRead&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">boost::leaf::result&lt; std::array&lt; std::byte, BytesToRead &gt; &gt; embed::write_then_read </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classembed_1_1spi.html">spi</a> &amp;&#160;</td>
          <td class="paramname"><em>p_spi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::span&lt; const std::byte &gt;&#160;</td>
          <td class="paramname"><em>p_data_out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::byte&#160;</td>
          <td class="paramname"><em>p_filler</em> = <code><a class="el" href="classembed_1_1spi.html#a6efdb2425adcb00811b99e88cf8893bf">spi::default_filler</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Write data to the SPI bus and ignore data sent from peripherals on the bus then read data from the SPI, fill the write line with filler bytes and return an array of bytes. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">BytesToRead</td><td>- Number of bytes to read from the bus </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p_spi</td><td>- spi driver </td></tr>
    <tr><td class="paramname">p_data_out</td><td>- bytes to write to the bus </td></tr>
    <tr><td class="paramname">p_filler</td><td>- filler data placed on the bus when the read operation begins. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>boost::leaf::result&lt;std::array&lt;std::byte, BytesToRead&gt;&gt; </dd></dl>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="group__spi_ga1bca4125f1f3e8c96cc7449883d1c515_cgraph.svg" width="515" height="38"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="gae9ae311fd79b085710fca67dcb4ff2a0" name="gae9ae311fd79b085710fca67dcb4ff2a0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae9ae311fd79b085710fca67dcb4ff2a0">&#9670;&nbsp;</a></span>write_then_read() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">boost::leaf::result&lt; void &gt; embed::write_then_read </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classembed_1_1spi.html">spi</a> &amp;&#160;</td>
          <td class="paramname"><em>p_spi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::span&lt; const std::byte &gt;&#160;</td>
          <td class="paramname"><em>p_data_out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::span&lt; std::byte &gt;&#160;</td>
          <td class="paramname"><em>p_data_in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::byte&#160;</td>
          <td class="paramname"><em>p_filler</em> = <code><a class="el" href="classembed_1_1spi.html#a6efdb2425adcb00811b99e88cf8893bf">spi::default_filler</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Write data to the SPI bus and ignore data sent from peripherals on the bus then read data from the SPI and fill the write line with filler bytes. </p>
<p >This utility function that fits the use case of many SPI devices where a transaction is not full duplex. In many spi devices, full duplex means that as data is being written to the SPI bus, the peripheral device is sending data back on the read line. In most cases, the protocol is to write data to the bus, and ignore the read line because the peripheral is not writing anything meaningful to that line, then reading from SPI bus and writing nothing meaningful to the write line as the peripheral is ignoring that line.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p_spi</td><td>- spi driver </td></tr>
    <tr><td class="paramname">p_data_out</td><td>- bytes to write to the bus </td></tr>
    <tr><td class="paramname">p_data_in</td><td>- buffer to receive bytes back from the SPI bus </td></tr>
    <tr><td class="paramname">p_filler</td><td>- filler data placed on the bus when the read operation begins. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>boost::leaf::result&lt;void&gt; </dd></dl>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="group__spi_gae9ae311fd79b085710fca67dcb4ff2a0_cgraph.svg" width="515" height="88"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.4 </li>
  </ul>
</div>
</body>
</html>
